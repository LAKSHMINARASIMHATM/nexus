{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/lib/db.ts"],"sourcesContent":["import { Pool } from '@neondatabase/serverless';\r\nimport * as dotenv from 'dotenv';\r\n\r\ndotenv.config({ path: '.env.local' });\r\ndotenv.config({ path: '.env' });\r\n\r\nconsole.log('Initializing Neon DB pool...');\r\n\r\nconst pool = new Pool({\r\n    connectionString: process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:5432/search_engine',\r\n    ssl: true,\r\n});\r\n\r\nexport default pool;\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,iJAAa,CAAC;IAAE,MAAM;AAAa;AACnC,iJAAa,CAAC;IAAE,MAAM;AAAO;AAE7B,QAAQ,GAAG,CAAC;AAEZ,MAAM,OAAO,IAAI,gKAAI,CAAC;IAClB,kBAAkB,QAAQ,GAAG,CAAC,YAAY,IAAI;IAC9C,KAAK;AACT;uCAEe"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/lib/services/search-service.ts"],"sourcesContent":["import pool from '../db';\r\n\r\nexport interface SearchParams {\r\n    query: string;\r\n    page?: number;\r\n    pageSize?: number;\r\n    filters?: {\r\n        language?: string;\r\n        dateRange?: {\r\n            start?: string;\r\n            end?: string;\r\n        };\r\n        site?: string | string[];\r\n    };\r\n}\r\n\r\nexport interface SearchResult {\r\n    doc_id: string;\r\n    url: string;\r\n    title: string;\r\n    snippet: string;\r\n    score: number;\r\n    highlights: string[];\r\n    metadata: {\r\n        author?: string;\r\n        published_date?: string;\r\n        language?: string;\r\n    };\r\n}\r\n\r\nexport interface SearchResponse {\r\n    query: {\r\n        original: string;\r\n        corrected?: string;\r\n        intent?: string;\r\n    };\r\n    results: SearchResult[];\r\n    total_results: number;\r\n    page: number;\r\n    page_size: number;\r\n    query_time_ms: number;\r\n    suggestions: string[];\r\n}\r\n\r\nexport class SearchService {\r\n    async search(params: SearchParams): Promise<SearchResponse> {\r\n        const startTime = Date.now();\r\n        const { query, page = 1, pageSize = 10 } = params;\r\n        const offset = (page - 1) * pageSize;\r\n\r\n        // Handle single character/variable searches with pattern matching\r\n        const isSingleChar = query.trim().length === 1;\r\n        const siteFilter = params.filters?.site;\r\n        const hasSiteFilter = siteFilter && (Array.isArray(siteFilter) ? siteFilter.length > 0 : true);\r\n        const siteCondition = hasSiteFilter\r\n            ? Array.isArray(siteFilter)\r\n                ? `AND url ILIKE ANY($${isSingleChar ? 5 : 4})`\r\n                : `AND url ILIKE $${isSingleChar ? 5 : 4}`\r\n            : '';\r\n\r\n        let sql;\r\n        let queryParams: any[];\r\n\r\n        if (isSingleChar) {\r\n            // For single character searches, use pattern matching instead of full-text search\r\n            const searchPattern = `%${query.trim()}%`;\r\n            sql = `\r\n                WITH ranked_docs AS (\r\n                    SELECT \r\n                        doc_id,\r\n                        url,\r\n                        title,\r\n                        meta_description,\r\n                        body,\r\n                        pagerank,\r\n                        crawl_timestamp,\r\n                        language,\r\n                        CASE \r\n                            WHEN title ILIKE $1 THEN 3.0\r\n                            WHEN meta_description ILIKE $1 THEN 2.0\r\n                            WHEN body ILIKE $1 THEN 1.0\r\n                            ELSE 0.5\r\n                        END as rank\r\n                    FROM documents\r\n                    WHERE \r\n                        (title ILIKE $1 OR \r\n                         meta_description ILIKE $1 OR \r\n                         body ILIKE $1)\r\n                        ${siteCondition}\r\n                ),\r\n                total_count AS (\r\n                    SELECT COUNT(*) as count FROM ranked_docs\r\n                )\r\n                SELECT \r\n                    rd.*,\r\n                    tc.count as total_results,\r\n                    CASE \r\n                        WHEN title ILIKE $1 THEN regexp_replace(title, '(' || $2 || ')', '<em>\\\\1</em>', 'gi')\r\n                        ELSE title\r\n                    END as title_highlight,\r\n                    CASE \r\n                        WHEN body ILIKE $1 THEN regexp_replace(substring(body, 1, 500), '(' || $2 || ')', '<em>\\\\1</em>', 'gi')\r\n                        ELSE substring(body, 1, 500)\r\n                    END as body_highlight\r\n                FROM ranked_docs rd, total_count tc\r\n                ORDER BY rank DESC, pagerank DESC\r\n                LIMIT $3 OFFSET $4\r\n            `;\r\n            queryParams = [searchPattern, query.trim(), pageSize, offset];\r\n            if (hasSiteFilter) {\r\n                const patterns = Array.isArray(siteFilter) ? siteFilter.map(s => `%${s}%`) : `%${siteFilter}%`;\r\n                queryParams.push(patterns);\r\n            }\r\n        } else {\r\n            // PostgreSQL Full-Text Search for longer queries\r\n            sql = `\r\n                WITH search_query AS (\r\n                    SELECT websearch_to_tsquery('english', $1) as query\r\n                ),\r\n                ranked_docs AS (\r\n                    SELECT \r\n                        doc_id,\r\n                        url,\r\n                        title,\r\n                        meta_description,\r\n                        body,\r\n                        pagerank,\r\n                        crawl_timestamp,\r\n                        language,\r\n                        ts_rank_cd(\r\n                            setweight(to_tsvector('english', title), 'A') ||\r\n                            setweight(to_tsvector('english', coalesce(meta_description, '')), 'B') ||\r\n                            setweight(to_tsvector('english', coalesce(body, '')), 'C'),\r\n                            (SELECT query FROM search_query)\r\n                        ) as rank\r\n                    FROM documents\r\n                    WHERE \r\n                        (\r\n                            setweight(to_tsvector('english', title), 'A') ||\r\n                            setweight(to_tsvector('english', coalesce(meta_description, '')), 'B') ||\r\n                            setweight(to_tsvector('english', coalesce(body, '')), 'C')\r\n                        ) @@ (SELECT query FROM search_query)\r\n                        ${siteCondition}\r\n                ),\r\n                total_count AS (\r\n                    SELECT COUNT(*) as count FROM ranked_docs\r\n                )\r\n                SELECT \r\n                    rd.*,\r\n                    tc.count as total_results,\r\n                    ts_headline('english', rd.body, (SELECT query FROM search_query), \r\n                        'StartSel=<em>, StopSel=</em>, MaxWords=35, MinWords=15, ShortWord=3, HighlightAll=FALSE, MaxFragments=1, FragmentDelimiter=\"...\"'\r\n                    ) as body_highlight,\r\n                    ts_headline('english', rd.title, (SELECT query FROM search_query), \r\n                        'StartSel=<em>, StopSel=</em>, HighlightAll=FALSE'\r\n                    ) as title_highlight\r\n                FROM ranked_docs rd, total_count tc\r\n                ORDER BY rank DESC, pagerank DESC\r\n                LIMIT $2 OFFSET $3\r\n            `;\r\n            queryParams = [query, pageSize, offset];\r\n            if (hasSiteFilter) {\r\n                const patterns = Array.isArray(siteFilter) ? siteFilter.map(s => `%${s}%`) : `%${siteFilter}%`;\r\n                queryParams.push(patterns);\r\n            }\r\n        }\r\n\r\n        try {\r\n            console.log(`Executing ${isSingleChar ? 'single character' : 'full-text'} search for query: \"${query}\"`);\r\n            const result = await pool.query(sql, queryParams);\r\n            console.log(`SQL executed. Rows: ${result.rows.length}`);\r\n\r\n            const totalResults = result.rows.length > 0 ? parseInt(result.rows[0].total_results, 10) : 0;\r\n\r\n            const searchResults: SearchResult[] = result.rows.map((row: any) => ({\r\n                doc_id: row.doc_id,\r\n                url: row.url,\r\n                title: row.title,\r\n                snippet: isSingleChar\r\n                    ? (row.body_highlight || row.meta_description || row.body || '').substring(0, 200) + '...'\r\n                    : (row.body_highlight || row.meta_description || ''),\r\n                score: parseFloat(row.rank) || 0,\r\n                highlights: [\r\n                    row.title_highlight,\r\n                    row.body_highlight\r\n                ].filter(Boolean),\r\n                metadata: {\r\n                    language: row.language,\r\n                    published_date: row.crawl_timestamp,\r\n                },\r\n            }));\r\n\r\n            const endTime = Date.now();\r\n\r\n            // Log the search event\r\n            this.logSearchEvent(query, totalResults, endTime - startTime);\r\n\r\n            return {\r\n                query: {\r\n                    original: query,\r\n                },\r\n                results: searchResults,\r\n                total_results: totalResults,\r\n                page,\r\n                page_size: pageSize,\r\n                query_time_ms: endTime - startTime,\r\n                suggestions: [],\r\n            };\r\n        } catch (error) {\r\n            console.error('Search error:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async logSearchEvent(query: string, resultCount: number, executionTime: number) {\r\n        try {\r\n            const sql = `\r\n                INSERT INTO search_events (query_text, result_count, execution_time_ms)\r\n                VALUES ($1, $2, $3)\r\n            `;\r\n            await pool.query(sql, [query, resultCount, executionTime]);\r\n        } catch (err) {\r\n            console.error('Failed to log search event:', err);\r\n        }\r\n    }\r\n\r\n    async suggest(query: string, limit: number = 10): Promise<string[]> {\r\n        const sql = `\r\n            SELECT query_text \r\n            FROM query_suggestions \r\n            WHERE query_text ILIKE $1 \r\n            ORDER BY frequency DESC \r\n            LIMIT $2\r\n        `;\r\n        try {\r\n            const result = await pool.query(sql, [`${query}%`, limit]);\r\n            return result.rows.map((row: any) => row.query_text);\r\n        } catch (error) {\r\n            console.error('Suggestion error:', error);\r\n            return [];\r\n        }\r\n    }\r\n}\r\n\r\nexport const searchService = new SearchService();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 299, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/app/api/v1/suggest/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { searchService } from '@/lib/services/search-service';\r\n\r\nexport async function GET(req: NextRequest) {\r\n    const searchParams = req.nextUrl.searchParams;\r\n    const query = searchParams.get('q');\r\n    const limit = parseInt(searchParams.get('limit') || '10', 10);\r\n\r\n    if (!query) {\r\n        return NextResponse.json(\r\n            {\r\n                query: '',\r\n                suggestions: [],\r\n            },\r\n            { status: 200 }\r\n        );\r\n    }\r\n\r\n    const suggestions = await searchService.suggest(query, limit);\r\n\r\n    return NextResponse.json({\r\n        query,\r\n        suggestions: suggestions.map((text) => ({\r\n            text,\r\n            frequency: 0, // Mock frequency if not available\r\n        })),\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IAAI,GAAgB;IACtC,MAAM,eAAe,IAAI,OAAO,CAAC,YAAY;IAC7C,MAAM,QAAQ,aAAa,GAAG,CAAC;IAC/B,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY,MAAM;IAE1D,IAAI,CAAC,OAAO;QACR,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,OAAO;YACP,aAAa,EAAE;QACnB,GACA;YAAE,QAAQ;QAAI;IAEtB;IAEA,MAAM,cAAc,MAAM,uJAAa,CAAC,OAAO,CAAC,OAAO;IAEvD,OAAO,gJAAY,CAAC,IAAI,CAAC;QACrB;QACA,aAAa,YAAY,GAAG,CAAC,CAAC,OAAS,CAAC;gBACpC;gBACA,WAAW;YACf,CAAC;IACL;AACJ"}}]
}