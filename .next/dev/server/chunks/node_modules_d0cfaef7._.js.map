{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/dotenv/package.json"],"sourcesContent":["{\"name\":\"dotenv\",\"version\":\"17.2.3\",\"description\":\"Loads environment variables from .env file\",\"main\":\"lib/main.js\",\"types\":\"lib/main.d.ts\",\"exports\":{\".\":{\"types\":\"./lib/main.d.ts\",\"require\":\"./lib/main.js\",\"default\":\"./lib/main.js\"},\"./config\":\"./config.js\",\"./config.js\":\"./config.js\",\"./lib/env-options\":\"./lib/env-options.js\",\"./lib/env-options.js\":\"./lib/env-options.js\",\"./lib/cli-options\":\"./lib/cli-options.js\",\"./lib/cli-options.js\":\"./lib/cli-options.js\",\"./package.json\":\"./package.json\"},\"scripts\":{\"dts-check\":\"tsc --project tests/types/tsconfig.json\",\"lint\":\"standard\",\"pretest\":\"npm run lint && npm run dts-check\",\"test\":\"tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000\",\"test:coverage\":\"tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov\",\"prerelease\":\"npm test\",\"release\":\"standard-version\"},\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/motdotla/dotenv.git\"},\"homepage\":\"https://github.com/motdotla/dotenv#readme\",\"funding\":\"https://dotenvx.com\",\"keywords\":[\"dotenv\",\"env\",\".env\",\"environment\",\"variables\",\"config\",\"settings\"],\"readmeFilename\":\"README.md\",\"license\":\"BSD-2-Clause\",\"devDependencies\":{\"@types/node\":\"^18.11.3\",\"decache\":\"^4.6.2\",\"sinon\":\"^14.0.1\",\"standard\":\"^17.0.0\",\"standard-version\":\"^9.5.0\",\"tap\":\"^19.2.0\",\"typescript\":\"^4.8.4\"},\"engines\":{\"node\":\">=12\"},\"browser\":{\"fs\":false}}"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 3, "column": 1435}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/dotenv/lib/main.js"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\n// Array of tips to display randomly\nconst TIPS = [\n  'üîê encrypt with Dotenvx: https://dotenvx.com',\n  'üîê prevent committing .env to code: https://dotenvx.com/precommit',\n  'üîê prevent building .env in docker: https://dotenvx.com/prebuild',\n  'üì° add observability to secrets: https://dotenvx.com/ops',\n  'üë• sync secrets across teammates & machines: https://dotenvx.com/ops',\n  'üóÇÔ∏è backup and recover secrets: https://dotenvx.com/ops',\n  '‚úÖ audit secrets and track compliance: https://dotenvx.com/ops',\n  'üîÑ add secrets lifecycle management: https://dotenvx.com/ops',\n  'üîë add access controls to secrets: https://dotenvx.com/ops',\n  'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`',\n  '‚öôÔ∏è  specify custom .env file path with { path: \\'/custom/path/.env\\' }',\n  '‚öôÔ∏è  enable debug logging with { debug: true }',\n  '‚öôÔ∏è  override existing env vars with { override: true }',\n  '‚öôÔ∏è  suppress all logs with { quiet: true }',\n  '‚öôÔ∏è  write to custom object with { processEnv: myObject }',\n  '‚öôÔ∏è  load multiple .env files with { path: [\\'.env.local\\', \\'.env\\'] }'\n]\n\n// Get a random tip from the tips array\nfunction _getRandomTip () {\n  return TIPS[Math.floor(Math.random() * TIPS.length)]\n}\n\nfunction parseBoolean (value) {\n  if (typeof value === 'string') {\n    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase())\n  }\n  return Boolean(value)\n}\n\nfunction supportsAnsi () {\n  return process.stdout.isTTY // && process.env.TERM !== 'dumb'\n}\n\nfunction dim (text) {\n  return supportsAnsi() ? `\\x1b[2m${text}\\x1b[0m` : text\n}\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.error(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  const populated = DotenvModule.populate(processEnv, parsedAll, options)\n\n  // handle user settings DOTENV_CONFIG_ options inside .env file(s)\n  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug)\n  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(populated).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n  const populated = {}\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n        populated[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n      populated[key] = parsed[key]\n    }\n  }\n\n  return populated\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/util.js"],"sourcesContent":["'use strict';\n\nexports.getValueAsString = function getValueString(value) {\n\tif (Number.isNaN(value)) {\n\t\treturn 'Nan';\n\t} else if (!Number.isFinite(value)) {\n\t\tif (value < 0) {\n\t\t\treturn '-Inf';\n\t\t} else {\n\t\t\treturn '+Inf';\n\t\t}\n\t} else {\n\t\treturn `${value}`;\n\t}\n};\n\nexports.removeLabels = function removeLabels(\n\thashMap,\n\tlabels,\n\tsortedLabelNames,\n) {\n\tconst hash = hashObject(labels, sortedLabelNames);\n\tdelete hashMap[hash];\n};\n\nexports.setValue = function setValue(hashMap, value, labels) {\n\tconst hash = hashObject(labels);\n\thashMap[hash] = {\n\t\tvalue: typeof value === 'number' ? value : 0,\n\t\tlabels: labels || {},\n\t};\n\treturn hashMap;\n};\n\nexports.setValueDelta = function setValueDelta(\n\thashMap,\n\tdeltaValue,\n\tlabels,\n\thash = '',\n) {\n\tconst value = typeof deltaValue === 'number' ? deltaValue : 0;\n\tif (hashMap[hash]) {\n\t\thashMap[hash].value += value;\n\t} else {\n\t\thashMap[hash] = { value, labels };\n\t}\n\treturn hashMap;\n};\n\nexports.getLabels = function (labelNames, args) {\n\tif (typeof args[0] === 'object') {\n\t\treturn args[0];\n\t}\n\n\tif (labelNames.length !== args.length) {\n\t\tthrow new Error(\n\t\t\t`Invalid number of arguments (${args.length}): \"${args.join(\n\t\t\t\t', ',\n\t\t\t)}\" for label names (${labelNames.length}): \"${labelNames.join(', ')}\".`,\n\t\t);\n\t}\n\n\tconst acc = {};\n\tfor (let i = 0; i < labelNames.length; i++) {\n\t\tacc[labelNames[i]] = args[i];\n\t}\n\treturn acc;\n};\n\nfunction fastHashObject(keys, labels) {\n\tif (keys.length === 0) {\n\t\treturn '';\n\t}\n\n\tlet hash = '';\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst value = labels[key];\n\t\tif (value === undefined) continue;\n\n\t\thash += `${key}:${value},`;\n\t}\n\n\treturn hash;\n}\n\nfunction hashObject(labels, labelNames) {\n\t// We don't actually need a hash here. We just need a string that\n\t// is unique for each possible labels object and consistent across\n\t// calls with equivalent labels objects.\n\n\tif (labelNames) {\n\t\treturn fastHashObject(labelNames, labels);\n\t}\n\n\tconst keys = Object.keys(labels);\n\tif (keys.length > 1) {\n\t\tkeys.sort(); // need consistency across calls\n\t}\n\n\treturn fastHashObject(keys, labels);\n}\nexports.hashObject = hashObject;\n\nexports.isObject = function isObject(obj) {\n\treturn obj !== null && typeof obj === 'object';\n};\n\nexports.nowTimestamp = function nowTimestamp() {\n\treturn Date.now() / 1000;\n};\n\nclass Grouper extends Map {\n\t/**\n\t * Adds the `value` to the `key`'s array of values.\n\t * @param {*} key Key to set.\n\t * @param {*} value Value to add to `key`'s array.\n\t * @returns {undefined} undefined.\n\t */\n\tadd(key, value) {\n\t\tif (this.has(key)) {\n\t\t\tthis.get(key).push(value);\n\t\t} else {\n\t\t\tthis.set(key, [value]);\n\t\t}\n\t}\n}\n\nexports.Grouper = Grouper;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 497, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/registry.js"],"sourcesContent":["'use strict';\n\nconst { getValueAsString } = require('./util');\n\nclass Registry {\n\tstatic get PROMETHEUS_CONTENT_TYPE() {\n\t\treturn 'text/plain; version=0.0.4; charset=utf-8';\n\t}\n\n\tstatic get OPENMETRICS_CONTENT_TYPE() {\n\t\treturn 'application/openmetrics-text; version=1.0.0; charset=utf-8';\n\t}\n\n\tconstructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {\n\t\tthis._metrics = {};\n\t\tthis._collectors = [];\n\t\tthis._defaultLabels = {};\n\t\tif (\n\t\t\tregContentType !== Registry.PROMETHEUS_CONTENT_TYPE &&\n\t\t\tregContentType !== Registry.OPENMETRICS_CONTENT_TYPE\n\t\t) {\n\t\t\tthrow new TypeError(`Content type ${regContentType} is unsupported`);\n\t\t}\n\t\tthis._contentType = regContentType;\n\t}\n\n\tgetMetricsAsArray() {\n\t\treturn Object.values(this._metrics);\n\t}\n\n\tasync getMetricsAsString(metrics) {\n\t\tconst metric =\n\t\t\ttypeof metrics.getForPromString === 'function'\n\t\t\t\t? await metrics.getForPromString()\n\t\t\t\t: await metrics.get();\n\n\t\tconst name = escapeString(metric.name);\n\t\tconst help = `# HELP ${name} ${escapeString(metric.help)}`;\n\t\tconst type = `# TYPE ${name} ${metric.type}`;\n\t\tconst values = [help, type];\n\n\t\tconst defaultLabels =\n\t\t\tObject.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;\n\n\t\tconst isOpenMetrics =\n\t\t\tthis.contentType === Registry.OPENMETRICS_CONTENT_TYPE;\n\n\t\tfor (const val of metric.values || []) {\n\t\t\tlet { metricName = name, labels = {} } = val;\n\t\t\tconst { sharedLabels = {} } = val;\n\t\t\tif (isOpenMetrics && metric.type === 'counter') {\n\t\t\t\tmetricName = `${metricName}_total`;\n\t\t\t}\n\n\t\t\tif (defaultLabels) {\n\t\t\t\tlabels = { ...labels, ...defaultLabels, ...labels };\n\t\t\t}\n\n\t\t\t// We have to flatten these separately to avoid duplicate labels appearing\n\t\t\t// between the base labels and the shared labels\n\t\t\tconst formattedLabels = formatLabels(labels, sharedLabels);\n\n\t\t\tconst flattenedShared = flattenSharedLabels(sharedLabels);\n\t\t\tconst labelParts = [...formattedLabels, flattenedShared].filter(Boolean);\n\t\t\tconst labelsString = labelParts.length ? `{${labelParts.join(',')}}` : '';\n\t\t\tlet fullMetricLine = `${metricName}${labelsString} ${getValueAsString(\n\t\t\t\tval.value,\n\t\t\t)}`;\n\n\t\t\tconst { exemplar } = val;\n\t\t\tif (exemplar && isOpenMetrics) {\n\t\t\t\tconst formattedExemplars = formatLabels(exemplar.labelSet);\n\t\t\t\tfullMetricLine += ` # {${formattedExemplars.join(\n\t\t\t\t\t',',\n\t\t\t\t)}} ${getValueAsString(exemplar.value)} ${exemplar.timestamp}`;\n\t\t\t}\n\t\t\tvalues.push(fullMetricLine);\n\t\t}\n\n\t\treturn values.join('\\n');\n\t}\n\n\tasync metrics() {\n\t\tconst isOpenMetrics =\n\t\t\tthis.contentType === Registry.OPENMETRICS_CONTENT_TYPE;\n\n\t\tconst promises = this.getMetricsAsArray().map(metric => {\n\t\t\tif (isOpenMetrics && metric.type === 'counter') {\n\t\t\t\tmetric.name = standardizeCounterName(metric.name);\n\t\t\t}\n\t\t\treturn this.getMetricsAsString(metric);\n\t\t});\n\n\t\tconst resolves = await Promise.all(promises);\n\n\t\treturn isOpenMetrics\n\t\t\t? `${resolves.join('\\n')}\\n# EOF\\n`\n\t\t\t: `${resolves.join('\\n\\n')}\\n`;\n\t}\n\n\tregisterMetric(metric) {\n\t\tif (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {\n\t\t\tthrow new Error(\n\t\t\t\t`A metric with the name ${metric.name} has already been registered.`,\n\t\t\t);\n\t\t}\n\n\t\tthis._metrics[metric.name] = metric;\n\t}\n\n\tclear() {\n\t\tthis._metrics = {};\n\t\tthis._defaultLabels = {};\n\t}\n\n\tasync getMetricsAsJSON() {\n\t\tconst metrics = [];\n\t\tconst defaultLabelNames = Object.keys(this._defaultLabels);\n\n\t\tconst promises = [];\n\n\t\tfor (const metric of this.getMetricsAsArray()) {\n\t\t\tpromises.push(metric.get());\n\t\t}\n\n\t\tconst resolves = await Promise.all(promises);\n\n\t\tfor (const item of resolves) {\n\t\t\tif (item.values && defaultLabelNames.length > 0) {\n\t\t\t\tfor (const val of item.values) {\n\t\t\t\t\t// Make a copy before mutating\n\t\t\t\t\tval.labels = Object.assign({}, val.labels);\n\n\t\t\t\t\tfor (const labelName of defaultLabelNames) {\n\t\t\t\t\t\tval.labels[labelName] =\n\t\t\t\t\t\t\tval.labels[labelName] || this._defaultLabels[labelName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmetrics.push(item);\n\t\t}\n\n\t\treturn metrics;\n\t}\n\n\tremoveSingleMetric(name) {\n\t\tdelete this._metrics[name];\n\t}\n\n\tgetSingleMetricAsString(name) {\n\t\treturn this.getMetricsAsString(this._metrics[name]);\n\t}\n\n\tgetSingleMetric(name) {\n\t\treturn this._metrics[name];\n\t}\n\n\tsetDefaultLabels(labels) {\n\t\tthis._defaultLabels = labels;\n\t}\n\n\tresetMetrics() {\n\t\tfor (const metric in this._metrics) {\n\t\t\tthis._metrics[metric].reset();\n\t\t}\n\t}\n\n\tget contentType() {\n\t\treturn this._contentType;\n\t}\n\n\tsetContentType(metricsContentType) {\n\t\tif (\n\t\t\tmetricsContentType === Registry.OPENMETRICS_CONTENT_TYPE ||\n\t\t\tmetricsContentType === Registry.PROMETHEUS_CONTENT_TYPE\n\t\t) {\n\t\t\tthis._contentType = metricsContentType;\n\t\t} else {\n\t\t\tthrow new Error(`Content type ${metricsContentType} is unsupported`);\n\t\t}\n\t}\n\n\tstatic merge(registers) {\n\t\tconst regType = registers[0].contentType;\n\t\tfor (const reg of registers) {\n\t\t\tif (reg.contentType !== regType) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Registers can only be merged if they have the same content type',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst mergedRegistry = new Registry(regType);\n\n\t\tconst metricsToMerge = registers.reduce(\n\t\t\t(acc, reg) => acc.concat(reg.getMetricsAsArray()),\n\t\t\t[],\n\t\t);\n\n\t\tmetricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);\n\t\treturn mergedRegistry;\n\t}\n}\n\nfunction formatLabels(labels, exclude) {\n\tconst { hasOwnProperty } = Object.prototype;\n\tconst formatted = [];\n\tfor (const [name, value] of Object.entries(labels)) {\n\t\tif (!exclude || !hasOwnProperty.call(exclude, name)) {\n\t\t\tformatted.push(`${name}=\"${escapeLabelValue(value)}\"`);\n\t\t}\n\t}\n\treturn formatted;\n}\n\nconst sharedLabelCache = new WeakMap();\nfunction flattenSharedLabels(labels) {\n\tconst cached = sharedLabelCache.get(labels);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst formattedLabels = formatLabels(labels);\n\tconst flattened = formattedLabels.join(',');\n\tsharedLabelCache.set(labels, flattened);\n\treturn flattened;\n}\nfunction escapeLabelValue(str) {\n\tif (typeof str !== 'string') {\n\t\treturn str;\n\t}\n\treturn escapeString(str).replace(/\"/g, '\\\\\"');\n}\nfunction escapeString(str) {\n\treturn str.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n');\n}\nfunction standardizeCounterName(name) {\n\treturn name.replace(/_total$/, '');\n}\n\nmodule.exports = Registry;\nmodule.exports.globalRegistry = new Registry();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/validation.js"],"sourcesContent":["'use strict';\n\nconst util = require('util');\n\n// These are from https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels\nconst metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;\nconst labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\nexports.validateMetricName = function (name) {\n\treturn metricRegexp.test(name);\n};\n\nexports.validateLabelName = function (names = []) {\n\treturn names.every(name => labelRegexp.test(name));\n};\n\nexports.validateLabel = function validateLabel(savedLabels, labels) {\n\tfor (const label in labels) {\n\t\tif (!savedLabels.includes(label)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Added label \"${label}\" is not included in initial labelset: ${util.inspect(\n\t\t\t\t\tsavedLabels,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t}\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,yFAAyF;AACzF,MAAM,eAAe;AACrB,MAAM,cAAc;AAEpB,QAAQ,kBAAkB,GAAG,SAAU,IAAI;IAC1C,OAAO,aAAa,IAAI,CAAC;AAC1B;AAEA,QAAQ,iBAAiB,GAAG,SAAU,QAAQ,EAAE;IAC/C,OAAO,MAAM,KAAK,CAAC,CAAA,OAAQ,YAAY,IAAI,CAAC;AAC7C;AAEA,QAAQ,aAAa,GAAG,SAAS,cAAc,WAAW,EAAE,MAAM;IACjE,IAAK,MAAM,SAAS,OAAQ;QAC3B,IAAI,CAAC,YAAY,QAAQ,CAAC,QAAQ;YACjC,MAAM,IAAI,MACT,CAAC,aAAa,EAAE,MAAM,uCAAuC,EAAE,KAAK,OAAO,CAC1E,cACE;QAEL;IACD;AACD","ignoreList":[0]}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metric.js"],"sourcesContent":["'use strict';\n\nconst Registry = require('./registry');\nconst { isObject } = require('./util');\nconst { validateMetricName, validateLabelName } = require('./validation');\n\n/**\n * @abstract\n */\nclass Metric {\n\tconstructor(config, defaults = {}) {\n\t\tif (!isObject(config)) {\n\t\t\tthrow new TypeError('constructor expected a config object');\n\t\t}\n\t\tObject.assign(\n\t\t\tthis,\n\t\t\t{\n\t\t\t\tlabelNames: [],\n\t\t\t\tregisters: [Registry.globalRegistry],\n\t\t\t\taggregator: 'sum',\n\t\t\t\tenableExemplars: false,\n\t\t\t},\n\t\t\tdefaults,\n\t\t\tconfig,\n\t\t);\n\t\tif (!this.registers) {\n\t\t\t// in case config.registers is `undefined`\n\t\t\tthis.registers = [Registry.globalRegistry];\n\t\t}\n\t\tif (!this.help) {\n\t\t\tthrow new Error('Missing mandatory help parameter');\n\t\t}\n\t\tif (!this.name) {\n\t\t\tthrow new Error('Missing mandatory name parameter');\n\t\t}\n\t\tif (!validateMetricName(this.name)) {\n\t\t\tthrow new Error('Invalid metric name');\n\t\t}\n\t\tif (!validateLabelName(this.labelNames)) {\n\t\t\tthrow new Error('Invalid label name');\n\t\t}\n\n\t\tif (this.collect && typeof this.collect !== 'function') {\n\t\t\tthrow new Error('Optional \"collect\" parameter must be a function');\n\t\t}\n\n\t\tif (this.labelNames) {\n\t\t\tthis.sortedLabelNames = [...this.labelNames].sort();\n\t\t} else {\n\t\t\tthis.sortedLabelNames = [];\n\t\t}\n\n\t\tthis.reset();\n\n\t\tfor (const register of this.registers) {\n\t\t\tif (\n\t\t\t\tthis.enableExemplars &&\n\t\t\t\tregister.contentType === Registry.PROMETHEUS_CONTENT_TYPE\n\t\t\t) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'Exemplars are supported only on OpenMetrics registries',\n\t\t\t\t);\n\t\t\t}\n\t\t\tregister.registerMetric(this);\n\t\t}\n\t}\n\n\treset() {\n\t\t/* abstract */\n\t}\n}\n\nmodule.exports = { Metric };\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM,EAAE,QAAQ,EAAE;AAClB,MAAM,EAAE,kBAAkB,EAAE,iBAAiB,EAAE;AAE/C;;CAEC,GACD,MAAM;IACL,YAAY,MAAM,EAAE,WAAW,CAAC,CAAC,CAAE;QAClC,IAAI,CAAC,SAAS,SAAS;YACtB,MAAM,IAAI,UAAU;QACrB;QACA,OAAO,MAAM,CACZ,IAAI,EACJ;YACC,YAAY,EAAE;YACd,WAAW;gBAAC,SAAS,cAAc;aAAC;YACpC,YAAY;YACZ,iBAAiB;QAClB,GACA,UACA;QAED,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACpB,0CAA0C;YAC1C,IAAI,CAAC,SAAS,GAAG;gBAAC,SAAS,cAAc;aAAC;QAC3C;QACA,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACf,MAAM,IAAI,MAAM;QACjB;QACA,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACf,MAAM,IAAI,MAAM;QACjB;QACA,IAAI,CAAC,mBAAmB,IAAI,CAAC,IAAI,GAAG;YACnC,MAAM,IAAI,MAAM;QACjB;QACA,IAAI,CAAC,kBAAkB,IAAI,CAAC,UAAU,GAAG;YACxC,MAAM,IAAI,MAAM;QACjB;QAEA,IAAI,IAAI,CAAC,OAAO,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,YAAY;YACvD,MAAM,IAAI,MAAM;QACjB;QAEA,IAAI,IAAI,CAAC,UAAU,EAAE;YACpB,IAAI,CAAC,gBAAgB,GAAG;mBAAI,IAAI,CAAC,UAAU;aAAC,CAAC,IAAI;QAClD,OAAO;YACN,IAAI,CAAC,gBAAgB,GAAG,EAAE;QAC3B;QAEA,IAAI,CAAC,KAAK;QAEV,KAAK,MAAM,YAAY,IAAI,CAAC,SAAS,CAAE;YACtC,IACC,IAAI,CAAC,eAAe,IACpB,SAAS,WAAW,KAAK,SAAS,uBAAuB,EACxD;gBACD,MAAM,IAAI,UACT;YAEF;YACA,SAAS,cAAc,CAAC,IAAI;QAC7B;IACD;IAEA,QAAQ;IACP,YAAY,GACb;AACD;AAEA,OAAO,OAAO,GAAG;IAAE;AAAO","ignoreList":[0]}},
    {"offset": {"line": 767, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/exemplar.js"],"sourcesContent":["'use strict';\n\n/**\n * Class representing an OpenMetrics exemplar.\n *\n * @property {object} labelSet\n * @property {number} value\n * @property {number} [timestamp]\n * */\nclass Exemplar {\n\tconstructor(labelSet = {}, value = null) {\n\t\tthis.labelSet = labelSet;\n\t\tthis.value = value;\n\t}\n\n\t/**\n\t * Validation for the label set format.\n\t * https://github.com/OpenObservability/OpenMetrics/blob/d99b705f611b75fec8f450b05e344e02eea6921d/specification/OpenMetrics.md#exemplars\n\t *\n\t * @param {object} labelSet - Exemplar labels.\n\t * @throws {RangeError}\n\t * @return {void}\n\t */\n\tvalidateExemplarLabelSet(labelSet) {\n\t\tlet res = '';\n\t\tfor (const [labelName, labelValue] of Object.entries(labelSet)) {\n\t\t\tres += `${labelName}${labelValue}`;\n\t\t}\n\t\tif (res.length > 128) {\n\t\t\tthrow new RangeError(\n\t\t\t\t'Label set size must be smaller than 128 UTF-8 chars',\n\t\t\t);\n\t\t}\n\t}\n}\n\nmodule.exports = Exemplar;\n"],"names":[],"mappings":"AAEA;;;;;;GAMG,GACH,MAAM;IACL,YAAY,WAAW,CAAC,CAAC,EAAE,QAAQ,IAAI,CAAE;QACxC,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG;IACd;IAEA;;;;;;;EAOC,GACD,yBAAyB,QAAQ,EAAE;QAClC,IAAI,MAAM;QACV,KAAK,MAAM,CAAC,WAAW,WAAW,IAAI,OAAO,OAAO,CAAC,UAAW;YAC/D,OAAO,GAAG,YAAY,YAAY;QACnC;QACA,IAAI,IAAI,MAAM,GAAG,KAAK;YACrB,MAAM,IAAI,WACT;QAEF;IACD;AACD;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 800, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/counter.js"],"sourcesContent":["/**\n * Counter metric\n */\n'use strict';\n\nconst util = require('util');\nconst {\n\thashObject,\n\tisObject,\n\tgetLabels,\n\tremoveLabels,\n\tnowTimestamp,\n} = require('./util');\nconst { validateLabel } = require('./validation');\nconst { Metric } = require('./metric');\nconst Exemplar = require('./exemplar');\n\nclass Counter extends Metric {\n\tconstructor(config) {\n\t\tsuper(config);\n\t\tthis.type = 'counter';\n\t\tthis.defaultLabels = {};\n\t\tthis.defaultValue = 1;\n\t\tthis.defaultExemplarLabelSet = {};\n\t\tif (config.enableExemplars) {\n\t\t\tthis.enableExemplars = true;\n\t\t\tthis.inc = this.incWithExemplar;\n\t\t} else {\n\t\t\tthis.inc = this.incWithoutExemplar;\n\t\t}\n\t}\n\n\t/**\n\t * Increment counter\n\t * @param {object} labels - What label you want to be incremented\n\t * @param {Number} value - Value to increment, if omitted increment with 1\n\t * @returns {object} results - object with information about the inc operation\n\t * @returns {string} results.labelHash - hash representation of the labels\n\t */\n\tincWithoutExemplar(labels, value) {\n\t\tlet hash = '';\n\t\tif (isObject(labels)) {\n\t\t\thash = hashObject(labels, this.sortedLabelNames);\n\t\t\tvalidateLabel(this.labelNames, labels);\n\t\t} else {\n\t\t\tvalue = labels;\n\t\t\tlabels = {};\n\t\t}\n\n\t\tif (value && !Number.isFinite(value)) {\n\t\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t\t}\n\t\tif (value < 0) {\n\t\t\tthrow new Error('It is not possible to decrease a counter');\n\t\t}\n\n\t\tif (value === null || value === undefined) value = 1;\n\n\t\tsetValue(this.hashMap, value, labels, hash);\n\n\t\treturn { labelHash: hash };\n\t}\n\n\t/**\n\t * Increment counter with exemplar, same as inc but accepts labels for an\n\t * exemplar.\n\t * If no label is provided the current exemplar labels are kept unchanged\n\t * (defaults to empty set).\n\t *\n\t * @param {object} incOpts - Object with options about what metric to increase\n\t * @param {object} incOpts.labels - What label you want to be incremented,\n\t *                                  defaults to null (metric with no labels)\n\t * @param {Number} incOpts.value - Value to increment, defaults to 1\n\t * @param {object} incOpts.exemplarLabels - Key-value  labels for the\n\t *                                          exemplar, defaults to empty set {}\n\t * @returns {void}\n\t */\n\tincWithExemplar({\n\t\tlabels = this.defaultLabels,\n\t\tvalue = this.defaultValue,\n\t\texemplarLabels = this.defaultExemplarLabelSet,\n\t} = {}) {\n\t\tconst res = this.incWithoutExemplar(labels, value);\n\t\tthis.updateExemplar(exemplarLabels, value, res.labelHash);\n\t}\n\n\tupdateExemplar(exemplarLabels, value, hash) {\n\t\tif (exemplarLabels === this.defaultExemplarLabelSet) return;\n\t\tif (!isObject(this.hashMap[hash].exemplar)) {\n\t\t\tthis.hashMap[hash].exemplar = new Exemplar();\n\t\t}\n\t\tthis.hashMap[hash].exemplar.validateExemplarLabelSet(exemplarLabels);\n\t\tthis.hashMap[hash].exemplar.labelSet = exemplarLabels;\n\t\tthis.hashMap[hash].exemplar.value = value ? value : 1;\n\t\tthis.hashMap[hash].exemplar.timestamp = nowTimestamp();\n\t}\n\n\t/**\n\t * Reset counter\n\t * @returns {void}\n\t */\n\treset() {\n\t\tthis.hashMap = {};\n\t\tif (this.labelNames.length === 0) {\n\t\t\tsetValue(this.hashMap, 0);\n\t\t}\n\t}\n\n\tasync get() {\n\t\tif (this.collect) {\n\t\t\tconst v = this.collect();\n\t\t\tif (v instanceof Promise) await v;\n\t\t}\n\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype: this.type,\n\t\t\tvalues: Object.values(this.hashMap),\n\t\t\taggregator: this.aggregator,\n\t\t};\n\t}\n\n\tlabels(...args) {\n\t\tconst labels = getLabels(this.labelNames, args) || {};\n\t\treturn {\n\t\t\tinc: this.inc.bind(this, labels),\n\t\t};\n\t}\n\n\tremove(...args) {\n\t\tconst labels = getLabels(this.labelNames, args) || {};\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n\t}\n}\n\nfunction setValue(hashMap, value, labels = {}, hash = '') {\n\tif (hashMap[hash]) {\n\t\thashMap[hash].value += value;\n\t} else {\n\t\thashMap[hash] = { value, labels };\n\t}\n\treturn hashMap;\n}\n\nmodule.exports = Counter;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/gauge.js"],"sourcesContent":["/**\n * Gauge metric\n */\n'use strict';\n\nconst util = require('util');\n\nconst {\n\tsetValue,\n\tsetValueDelta,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tremoveLabels,\n} = require('./util');\nconst { validateLabel } = require('./validation');\nconst { Metric } = require('./metric');\n\nclass Gauge extends Metric {\n\tconstructor(config) {\n\t\tsuper(config);\n\t\tthis.type = 'gauge';\n\t}\n\n\t/**\n\t * Set a gauge to a value\n\t * @param {object} labels - Object with labels and their values\n\t * @param {Number} value - Value to set the gauge to, must be positive\n\t * @returns {void}\n\t */\n\tset(labels, value) {\n\t\tvalue = getValueArg(labels, value);\n\t\tlabels = getLabelArg(labels);\n\t\tset(this, labels, value);\n\t}\n\n\t/**\n\t * Reset gauge\n\t * @returns {void}\n\t */\n\treset() {\n\t\tthis.hashMap = {};\n\t\tif (this.labelNames.length === 0) {\n\t\t\tsetValue(this.hashMap, 0, {});\n\t\t}\n\t}\n\n\t/**\n\t * Increment a gauge value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to increment - if omitted, increment with 1\n\t * @returns {void}\n\t */\n\tinc(labels, value) {\n\t\tvalue = getValueArg(labels, value);\n\t\tlabels = getLabelArg(labels);\n\t\tif (value === undefined) value = 1;\n\t\tsetDelta(this, labels, value);\n\t}\n\n\t/**\n\t * Decrement a gauge value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to decrement - if omitted, decrement with 1\n\t * @returns {void}\n\t */\n\tdec(labels, value) {\n\t\tvalue = getValueArg(labels, value);\n\t\tlabels = getLabelArg(labels);\n\t\tif (value === undefined) value = 1;\n\t\tsetDelta(this, labels, -value);\n\t}\n\n\t/**\n\t * Set the gauge to current unix epoch\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {void}\n\t */\n\tsetToCurrentTime(labels) {\n\t\tconst now = Date.now() / 1000;\n\t\tif (labels === undefined) {\n\t\t\tthis.set(now);\n\t\t} else {\n\t\t\tthis.set(labels, now);\n\t\t}\n\t}\n\n\t/**\n\t * Start a timer\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Invoke this function to set the duration in seconds since you started the timer.\n\t * @example\n\t * var done = gauge.startTimer();\n\t * makeXHRRequest(function(err, response) {\n\t *\tdone(); //Duration of the request will be saved\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tconst value = delta[0] + delta[1] / 1e9;\n\t\t\tthis.set(Object.assign({}, labels, endLabels), value);\n\t\t\treturn value;\n\t\t};\n\t}\n\n\tasync get() {\n\t\tif (this.collect) {\n\t\t\tconst v = this.collect();\n\t\t\tif (v instanceof Promise) await v;\n\t\t}\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype: this.type,\n\t\t\tvalues: Object.values(this.hashMap),\n\t\t\taggregator: this.aggregator,\n\t\t};\n\t}\n\n\t_getValue(labels) {\n\t\tconst hash = hashObject(labels || {}, this.sortedLabelNames);\n\t\treturn this.hashMap[hash] ? this.hashMap[hash].value : 0;\n\t}\n\n\tlabels(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn {\n\t\t\tinc: this.inc.bind(this, labels),\n\t\t\tdec: this.dec.bind(this, labels),\n\t\t\tset: this.set.bind(this, labels),\n\t\t\tsetToCurrentTime: this.setToCurrentTime.bind(this, labels),\n\t\t\tstartTimer: this.startTimer.bind(this, labels),\n\t\t};\n\t}\n\n\tremove(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tremoveLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n\t}\n}\n\nfunction set(gauge, labels, value) {\n\tif (typeof value !== 'number') {\n\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t}\n\n\tvalidateLabel(gauge.labelNames, labels);\n\tsetValue(gauge.hashMap, value, labels);\n}\n\nfunction setDelta(gauge, labels, delta) {\n\tif (typeof delta !== 'number') {\n\t\tthrow new TypeError(`Delta is not a valid number: ${util.format(delta)}`);\n\t}\n\n\tvalidateLabel(gauge.labelNames, labels);\n\tconst hash = hashObject(labels, gauge.sortedLabelNames);\n\tsetValueDelta(gauge.hashMap, delta, labels, hash);\n}\n\nfunction getLabelArg(labels) {\n\treturn isObject(labels) ? labels : {};\n}\n\nfunction getValueArg(labels, value) {\n\treturn isObject(labels) ? value : labels;\n}\n\nmodule.exports = Gauge;\n"],"names":[],"mappings":"AAAA;;CAEC,GAGD,MAAM;AAEN,MAAM,EACL,QAAQ,EACR,aAAa,EACb,SAAS,EACT,UAAU,EACV,QAAQ,EACR,YAAY,EACZ;AACD,MAAM,EAAE,aAAa,EAAE;AACvB,MAAM,EAAE,MAAM,EAAE;AAEhB,MAAM,cAAc;IACnB,YAAY,MAAM,CAAE;QACnB,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;IACb;IAEA;;;;;EAKC,GACD,IAAI,MAAM,EAAE,KAAK,EAAE;QAClB,QAAQ,YAAY,QAAQ;QAC5B,SAAS,YAAY;QACrB,IAAI,IAAI,EAAE,QAAQ;IACnB;IAEA;;;EAGC,GACD,QAAQ;QACP,IAAI,CAAC,OAAO,GAAG,CAAC;QAChB,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,KAAK,GAAG;YACjC,SAAS,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC;QAC5B;IACD;IAEA;;;;;EAKC,GACD,IAAI,MAAM,EAAE,KAAK,EAAE;QAClB,QAAQ,YAAY,QAAQ;QAC5B,SAAS,YAAY;QACrB,IAAI,UAAU,WAAW,QAAQ;QACjC,SAAS,IAAI,EAAE,QAAQ;IACxB;IAEA;;;;;EAKC,GACD,IAAI,MAAM,EAAE,KAAK,EAAE;QAClB,QAAQ,YAAY,QAAQ;QAC5B,SAAS,YAAY;QACrB,IAAI,UAAU,WAAW,QAAQ;QACjC,SAAS,IAAI,EAAE,QAAQ,CAAC;IACzB;IAEA;;;;EAIC,GACD,iBAAiB,MAAM,EAAE;QACxB,MAAM,MAAM,KAAK,GAAG,KAAK;QACzB,IAAI,WAAW,WAAW;YACzB,IAAI,CAAC,GAAG,CAAC;QACV,OAAO;YACN,IAAI,CAAC,GAAG,CAAC,QAAQ;QAClB;IACD;IAEA;;;;;;;;;EASC,GACD,WAAW,MAAM,EAAE;QAClB,MAAM,QAAQ,QAAQ,MAAM;QAC5B,OAAO,CAAA;YACN,MAAM,QAAQ,QAAQ,MAAM,CAAC;YAC7B,MAAM,QAAQ,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,GAAG;YACpC,IAAI,CAAC,GAAG,CAAC,OAAO,MAAM,CAAC,CAAC,GAAG,QAAQ,YAAY;YAC/C,OAAO;QACR;IACD;IAEA,MAAM,MAAM;QACX,IAAI,IAAI,CAAC,OAAO,EAAE;YACjB,MAAM,IAAI,IAAI,CAAC,OAAO;YACtB,IAAI,aAAa,SAAS,MAAM;QACjC;QACA,OAAO;YACN,MAAM,IAAI,CAAC,IAAI;YACf,MAAM,IAAI,CAAC,IAAI;YACf,MAAM,IAAI,CAAC,IAAI;YACf,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO;YAClC,YAAY,IAAI,CAAC,UAAU;QAC5B;IACD;IAEA,UAAU,MAAM,EAAE;QACjB,MAAM,OAAO,WAAW,UAAU,CAAC,GAAG,IAAI,CAAC,gBAAgB;QAC3D,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG;IACxD;IAEA,OAAO,GAAG,IAAI,EAAE;QACf,MAAM,SAAS,UAAU,IAAI,CAAC,UAAU,EAAE;QAC1C,cAAc,IAAI,CAAC,UAAU,EAAE;QAC/B,OAAO;YACN,KAAK,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE;YACzB,KAAK,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE;YACzB,KAAK,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE;YACzB,kBAAkB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE;YACnD,YAAY,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE;QACxC;IACD;IAEA,OAAO,GAAG,IAAI,EAAE;QACf,MAAM,SAAS,UAAU,IAAI,CAAC,UAAU,EAAE;QAC1C,cAAc,IAAI,CAAC,UAAU,EAAE;QAC/B,aAAa,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,QAAQ,IAAI,CAAC,gBAAgB;IACpE;AACD;AAEA,SAAS,IAAI,KAAK,EAAE,MAAM,EAAE,KAAK;IAChC,IAAI,OAAO,UAAU,UAAU;QAC9B,MAAM,IAAI,UAAU,CAAC,6BAA6B,EAAE,KAAK,MAAM,CAAC,QAAQ;IACzE;IAEA,cAAc,MAAM,UAAU,EAAE;IAChC,SAAS,MAAM,OAAO,EAAE,OAAO;AAChC;AAEA,SAAS,SAAS,KAAK,EAAE,MAAM,EAAE,KAAK;IACrC,IAAI,OAAO,UAAU,UAAU;QAC9B,MAAM,IAAI,UAAU,CAAC,6BAA6B,EAAE,KAAK,MAAM,CAAC,QAAQ;IACzE;IAEA,cAAc,MAAM,UAAU,EAAE;IAChC,MAAM,OAAO,WAAW,QAAQ,MAAM,gBAAgB;IACtD,cAAc,MAAM,OAAO,EAAE,OAAO,QAAQ;AAC7C;AAEA,SAAS,YAAY,MAAM;IAC1B,OAAO,SAAS,UAAU,SAAS,CAAC;AACrC;AAEA,SAAS,YAAY,MAAM,EAAE,KAAK;IACjC,OAAO,SAAS,UAAU,QAAQ;AACnC;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 1067, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/histogram.js"],"sourcesContent":["/**\n * Histogram\n */\n'use strict';\n\nconst util = require('util');\nconst {\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tremoveLabels,\n\tnowTimestamp,\n} = require('./util');\nconst { validateLabel } = require('./validation');\nconst { Metric } = require('./metric');\nconst Exemplar = require('./exemplar');\n\nclass Histogram extends Metric {\n\tconstructor(config) {\n\t\tsuper(config, {\n\t\t\tbuckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],\n\t\t});\n\n\t\tthis.type = 'histogram';\n\t\tthis.defaultLabels = {};\n\t\tthis.defaultExemplarLabelSet = {};\n\t\tthis.enableExemplars = false;\n\n\t\tfor (const label of this.labelNames) {\n\t\t\tif (label === 'le') {\n\t\t\t\tthrow new Error('le is a reserved label keyword');\n\t\t\t}\n\t\t}\n\n\t\tthis.upperBounds = this.buckets;\n\t\tthis.bucketValues = this.upperBounds.reduce((acc, upperBound) => {\n\t\t\tacc[upperBound] = 0;\n\t\t\treturn acc;\n\t\t}, {});\n\n\t\tif (config.enableExemplars) {\n\t\t\tthis.enableExemplars = true;\n\t\t\tthis.bucketExemplars = this.upperBounds.reduce((acc, upperBound) => {\n\t\t\t\tacc[upperBound] = null;\n\t\t\t\treturn acc;\n\t\t\t}, {});\n\t\t\tObject.freeze(this.bucketExemplars);\n\t\t\tthis.observe = this.observeWithExemplar;\n\t\t} else {\n\t\t\tthis.observe = this.observeWithoutExemplar;\n\t\t}\n\n\t\tObject.freeze(this.bucketValues);\n\t\tObject.freeze(this.upperBounds);\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: createBaseValues(\n\t\t\t\t\t{},\n\t\t\t\t\tthis.bucketValues,\n\t\t\t\t\tthis.bucketExemplars,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Observe a value in histogram\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe in the histogram\n\t * @returns {void}\n\t */\n\tobserveWithoutExemplar(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tobserveWithExemplar({\n\t\tlabels = this.defaultLabels,\n\t\tvalue,\n\t\texemplarLabels = this.defaultExemplarLabelSet,\n\t} = {}) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t\tthis.updateExemplar(labels, value, exemplarLabels);\n\t}\n\n\tupdateExemplar(labels, value, exemplarLabels) {\n\t\tif (Object.keys(exemplarLabels).length === 0) return;\n\t\tconst hash = hashObject(labels, this.sortedLabelNames);\n\t\tconst bound = findBound(this.upperBounds, value);\n\t\tconst { bucketExemplars } = this.hashMap[hash];\n\t\tlet exemplar = bucketExemplars[bound];\n\t\tif (!isObject(exemplar)) {\n\t\t\texemplar = new Exemplar();\n\t\t\tbucketExemplars[bound] = exemplar;\n\t\t}\n\t\texemplar.validateExemplarLabelSet(exemplarLabels);\n\t\texemplar.labelSet = exemplarLabels;\n\t\texemplar.value = value;\n\t\texemplar.timestamp = nowTimestamp();\n\t}\n\n\tasync get() {\n\t\tconst data = await this.getForPromString();\n\t\tdata.values = data.values.map(splayLabels);\n\t\treturn data;\n\t}\n\n\tasync getForPromString() {\n\t\tif (this.collect) {\n\t\t\tconst v = this.collect();\n\t\t\tif (v instanceof Promise) await v;\n\t\t}\n\t\tconst data = Object.values(this.hashMap);\n\t\tconst values = data\n\t\t\t.map(extractBucketValuesForExport(this))\n\t\t\t.reduce(addSumAndCountForExport(this), []);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype: this.type,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator,\n\t\t};\n\t}\n\n\treset() {\n\t\tthis.hashMap = {};\n\t}\n\n\t/**\n\t * Initialize the metrics for the given combination of labels to zero\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {void}\n\t */\n\tzero(labels) {\n\t\tconst hash = hashObject(labels, this.sortedLabelNames);\n\t\tthis.hashMap[hash] = createBaseValues(\n\t\t\tlabels,\n\t\t\tthis.bucketValues,\n\t\t\tthis.bucketExemplars,\n\t\t);\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {object} exemplarLabels - Object with labels for exemplar where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = histogram.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t * \tconst duration = end(); //Observe the duration of expensiveXHRRequest and returns duration in seconds\n\t * \tconsole.log('Duration', duration);\n\t * });\n\t */\n\tstartTimer(labels, exemplarLabels) {\n\t\treturn this.enableExemplars\n\t\t\t? startTimerWithExemplar.call(this, labels, exemplarLabels)()\n\t\t\t: startTimer.call(this, labels)();\n\t}\n\n\tlabels(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels),\n\t\t};\n\t}\n\n\tremove(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tremoveLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n\t}\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tconst value = delta[0] + delta[1] / 1e9;\n\t\t\tthis.observe(Object.assign({}, startLabels, endLabels), value);\n\t\t\treturn value;\n\t\t};\n\t};\n}\n\nfunction startTimerWithExemplar(startLabels, startExemplarLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn (endLabels, endExemplarLabels) => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tconst value = delta[0] + delta[1] / 1e9;\n\t\t\tthis.observe({\n\t\t\t\tlabels: Object.assign({}, startLabels, endLabels),\n\t\t\t\tvalue,\n\t\t\t\texemplarLabels: Object.assign(\n\t\t\t\t\t{},\n\t\t\t\t\tstartExemplarLabels,\n\t\t\t\t\tendExemplarLabels,\n\t\t\t\t),\n\t\t\t});\n\t\t\treturn value;\n\t\t};\n\t};\n}\n\nfunction setValuePair(labels, value, metricName, exemplar, sharedLabels = {}) {\n\treturn {\n\t\tlabels,\n\t\tsharedLabels,\n\t\tvalue,\n\t\tmetricName,\n\t\texemplar,\n\t};\n}\n\nfunction findBound(upperBounds, value) {\n\tfor (let i = 0; i < upperBounds.length; i++) {\n\t\tconst bound = upperBounds[i];\n\t\tif (value <= bound) {\n\t\t\treturn bound;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, labelValuePair.labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`,\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels, this.sortedLabelNames);\n\t\tlet valueFromMap = this.hashMap[hash];\n\t\tif (!valueFromMap) {\n\t\t\tvalueFromMap = createBaseValues(\n\t\t\t\tlabelValuePair.labels,\n\t\t\t\tthis.bucketValues,\n\t\t\t\tthis.bucketExemplars,\n\t\t\t);\n\t\t}\n\n\t\tconst b = findBound(this.upperBounds, labelValuePair.value);\n\n\t\tvalueFromMap.sum += labelValuePair.value;\n\t\tvalueFromMap.count += 1;\n\n\t\tif (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b)) {\n\t\t\tvalueFromMap.bucketValues[b] += 1;\n\t\t}\n\n\t\tthis.hashMap[hash] = valueFromMap;\n\t};\n}\n\nfunction createBaseValues(labels, bucketValues, bucketExemplars) {\n\tconst result = {\n\t\tlabels,\n\t\tbucketValues: { ...bucketValues },\n\t\tsum: 0,\n\t\tcount: 0,\n\t};\n\tif (bucketExemplars) {\n\t\tresult.bucketExemplars = { ...bucketExemplars };\n\t}\n\treturn result;\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\treturn isObject(labels)\n\t\t? {\n\t\t\t\tlabels,\n\t\t\t\tvalue,\n\t\t\t}\n\t\t: {\n\t\t\t\tvalue: labels,\n\t\t\t\tlabels: {},\n\t\t\t};\n}\n\nfunction extractBucketValuesForExport(histogram) {\n\tconst name = `${histogram.name}_bucket`;\n\treturn bucketData => {\n\t\tlet acc = 0;\n\t\tconst buckets = histogram.upperBounds.map(upperBound => {\n\t\t\tacc += bucketData.bucketValues[upperBound];\n\t\t\treturn setValuePair(\n\t\t\t\t{ le: upperBound },\n\t\t\t\tacc,\n\t\t\t\tname,\n\t\t\t\tbucketData.bucketExemplars\n\t\t\t\t\t? bucketData.bucketExemplars[upperBound]\n\t\t\t\t\t: null,\n\t\t\t\tbucketData.labels,\n\t\t\t);\n\t\t});\n\t\treturn { buckets, data: bucketData };\n\t};\n}\n\nfunction addSumAndCountForExport(histogram) {\n\treturn (acc, d) => {\n\t\tacc.push(...d.buckets);\n\n\t\tconst infLabel = { le: '+Inf' };\n\t\tacc.push(\n\t\t\tsetValuePair(\n\t\t\t\tinfLabel,\n\t\t\t\td.data.count,\n\t\t\t\t`${histogram.name}_bucket`,\n\t\t\t\td.data.bucketExemplars ? d.data.bucketExemplars['-1'] : null,\n\t\t\t\td.data.labels,\n\t\t\t),\n\t\t\tsetValuePair(\n\t\t\t\t{},\n\t\t\t\td.data.sum,\n\t\t\t\t`${histogram.name}_sum`,\n\t\t\t\tundefined,\n\t\t\t\td.data.labels,\n\t\t\t),\n\t\t\tsetValuePair(\n\t\t\t\t{},\n\t\t\t\td.data.count,\n\t\t\t\t`${histogram.name}_count`,\n\t\t\t\tundefined,\n\t\t\t\td.data.labels,\n\t\t\t),\n\t\t);\n\t\treturn acc;\n\t};\n}\n\nfunction splayLabels(bucket) {\n\tconst { sharedLabels, labels, ...newBucket } = bucket;\n\tfor (const label of Object.keys(sharedLabels)) {\n\t\tlabels[label] = sharedLabels[label];\n\t}\n\tnewBucket.labels = labels;\n\treturn newBucket;\n}\n\nmodule.exports = Histogram;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1339, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/timeWindowQuantiles.js"],"sourcesContent":["'use strict';\n\nconst { TDigest } = require('tdigest');\n\nclass TimeWindowQuantiles {\n\tconstructor(maxAgeSeconds, ageBuckets) {\n\t\tthis.maxAgeSeconds = maxAgeSeconds || 0;\n\t\tthis.ageBuckets = ageBuckets || 0;\n\n\t\tthis.shouldRotate = maxAgeSeconds && ageBuckets;\n\n\t\tthis.ringBuffer = Array(ageBuckets).fill(new TDigest());\n\t\tthis.currentBuffer = 0;\n\n\t\tthis.lastRotateTimestampMillis = Date.now();\n\t\tthis.durationBetweenRotatesMillis =\n\t\t\t(maxAgeSeconds * 1000) / ageBuckets || Infinity;\n\t}\n\n\tsize() {\n\t\tconst bucket = rotate.call(this);\n\t\treturn bucket.size();\n\t}\n\n\tpercentile(quantile) {\n\t\tconst bucket = rotate.call(this);\n\t\treturn bucket.percentile(quantile);\n\t}\n\n\tpush(value) {\n\t\trotate.call(this);\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.push(value);\n\t\t});\n\t}\n\n\treset() {\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.reset();\n\t\t});\n\t}\n\n\tcompress() {\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.compress();\n\t\t});\n\t}\n}\n\nfunction rotate() {\n\tlet timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;\n\twhile (\n\t\ttimeSinceLastRotateMillis > this.durationBetweenRotatesMillis &&\n\t\tthis.shouldRotate\n\t) {\n\t\tthis.ringBuffer[this.currentBuffer] = new TDigest();\n\n\t\tif (++this.currentBuffer >= this.ringBuffer.length) {\n\t\t\tthis.currentBuffer = 0;\n\t\t}\n\t\ttimeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;\n\t\tthis.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;\n\t}\n\treturn this.ringBuffer[this.currentBuffer];\n}\n\nmodule.exports = TimeWindowQuantiles;\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,OAAO,EAAE;AAEjB,MAAM;IACL,YAAY,aAAa,EAAE,UAAU,CAAE;QACtC,IAAI,CAAC,aAAa,GAAG,iBAAiB;QACtC,IAAI,CAAC,UAAU,GAAG,cAAc;QAEhC,IAAI,CAAC,YAAY,GAAG,iBAAiB;QAErC,IAAI,CAAC,UAAU,GAAG,MAAM,YAAY,IAAI,CAAC,IAAI;QAC7C,IAAI,CAAC,aAAa,GAAG;QAErB,IAAI,CAAC,yBAAyB,GAAG,KAAK,GAAG;QACzC,IAAI,CAAC,4BAA4B,GAChC,AAAC,gBAAgB,OAAQ,cAAc;IACzC;IAEA,OAAO;QACN,MAAM,SAAS,OAAO,IAAI,CAAC,IAAI;QAC/B,OAAO,OAAO,IAAI;IACnB;IAEA,WAAW,QAAQ,EAAE;QACpB,MAAM,SAAS,OAAO,IAAI,CAAC,IAAI;QAC/B,OAAO,OAAO,UAAU,CAAC;IAC1B;IAEA,KAAK,KAAK,EAAE;QACX,OAAO,IAAI,CAAC,IAAI;QAChB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;YACvB,OAAO,IAAI,CAAC;QACb;IACD;IAEA,QAAQ;QACP,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;YACvB,OAAO,KAAK;QACb;IACD;IAEA,WAAW;QACV,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;YACvB,OAAO,QAAQ;QAChB;IACD;AACD;AAEA,SAAS;IACR,IAAI,4BAA4B,KAAK,GAAG,KAAK,IAAI,CAAC,yBAAyB;IAC3E,MACC,4BAA4B,IAAI,CAAC,4BAA4B,IAC7D,IAAI,CAAC,YAAY,CAChB;QACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,IAAI;QAE1C,IAAI,EAAE,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;YACnD,IAAI,CAAC,aAAa,GAAG;QACtB;QACA,6BAA6B,IAAI,CAAC,4BAA4B;QAC9D,IAAI,CAAC,yBAAyB,IAAI,IAAI,CAAC,4BAA4B;IACpE;IACA,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC;AAC3C;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 1392, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/summary.js"],"sourcesContent":["/**\n * Summary\n */\n'use strict';\n\nconst util = require('util');\nconst { getLabels, hashObject, removeLabels } = require('./util');\nconst { validateLabel } = require('./validation');\nconst { Metric } = require('./metric');\nconst timeWindowQuantiles = require('./timeWindowQuantiles');\n\nconst DEFAULT_COMPRESS_COUNT = 1000; // every 1000 measurements\n\nclass Summary extends Metric {\n\tconstructor(config) {\n\t\tsuper(config, {\n\t\t\tpercentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],\n\t\t\tcompressCount: DEFAULT_COMPRESS_COUNT,\n\t\t\thashMap: {},\n\t\t});\n\n\t\tthis.type = 'summary';\n\n\t\tfor (const label of this.labelNames) {\n\t\t\tif (label === 'quantile')\n\t\t\t\tthrow new Error('quantile is a reserved label keyword');\n\t\t}\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: {\n\t\t\t\t\tlabels: {},\n\t\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tsum: 0,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Observe a value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe\n\t * @returns {void}\n\t */\n\tobserve(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tasync get() {\n\t\tif (this.collect) {\n\t\t\tconst v = this.collect();\n\t\t\tif (v instanceof Promise) await v;\n\t\t}\n\t\tconst hashKeys = Object.keys(this.hashMap);\n\t\tconst values = [];\n\n\t\thashKeys.forEach(hashKey => {\n\t\t\tconst s = this.hashMap[hashKey];\n\t\t\tif (s) {\n\t\t\t\tif (this.pruneAgedBuckets && s.td.size() === 0) {\n\t\t\t\t\tdelete this.hashMap[hashKey];\n\t\t\t\t} else {\n\t\t\t\t\textractSummariesForExport(s, this.percentiles).forEach(v => {\n\t\t\t\t\t\tvalues.push(v);\n\t\t\t\t\t});\n\t\t\t\t\tvalues.push(getSumForExport(s, this));\n\t\t\t\t\tvalues.push(getCountForExport(s, this));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype: this.type,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator,\n\t\t};\n\t}\n\n\treset() {\n\t\tconst data = Object.values(this.hashMap);\n\t\tdata.forEach(s => {\n\t\t\ts.td.reset();\n\t\t\ts.count = 0;\n\t\t\ts.sum = 0;\n\t\t});\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = summary.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t *\tend(); //Observe the duration of expensiveXHRRequest\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tlabels(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels),\n\t\t};\n\t}\n\n\tremove(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tremoveLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n\t}\n}\n\nfunction extractSummariesForExport(summaryOfLabels, percentiles) {\n\tsummaryOfLabels.td.compress();\n\n\treturn percentiles.map(percentile => {\n\t\tconst percentileValue = summaryOfLabels.td.percentile(percentile);\n\t\treturn {\n\t\t\tlabels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),\n\t\t\tvalue: percentileValue ? percentileValue : 0,\n\t\t};\n\t});\n}\n\nfunction getCountForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_count`,\n\t\tlabels: value.labels,\n\t\tvalue: value.count,\n\t};\n}\n\nfunction getSumForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_sum`,\n\t\tlabels: value.labels,\n\t\tvalue: value.sum,\n\t};\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tconst value = delta[0] + delta[1] / 1e9;\n\t\t\tthis.observe(Object.assign({}, startLabels, endLabels), value);\n\t\t\treturn value;\n\t\t};\n\t};\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`,\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels, this.sortedLabelNames);\n\t\tlet summaryOfLabel = this.hashMap[hash];\n\t\tif (!summaryOfLabel) {\n\t\t\tsummaryOfLabel = {\n\t\t\t\tlabels: labelValuePair.labels,\n\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\tcount: 0,\n\t\t\t\tsum: 0,\n\t\t\t};\n\t\t}\n\n\t\tsummaryOfLabel.td.push(labelValuePair.value);\n\t\tsummaryOfLabel.count++;\n\t\tif (summaryOfLabel.count % this.compressCount === 0) {\n\t\t\tsummaryOfLabel.td.compress();\n\t\t}\n\t\tsummaryOfLabel.sum += labelValuePair.value;\n\t\tthis.hashMap[hash] = summaryOfLabel;\n\t};\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (value === undefined) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {},\n\t\t};\n\t}\n\n\treturn {\n\t\tlabels,\n\t\tvalue,\n\t};\n}\n\nmodule.exports = Summary;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1581, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/pushgateway.js"],"sourcesContent":["'use strict';\n\nconst url = require('url');\nconst http = require('http');\nconst https = require('https');\nconst { gzipSync } = require('zlib');\nconst { globalRegistry } = require('./registry');\n\nclass Pushgateway {\n\tconstructor(gatewayUrl, options, registry) {\n\t\tif (!registry) {\n\t\t\tregistry = globalRegistry;\n\t\t}\n\t\tthis.registry = registry;\n\t\tthis.gatewayUrl = gatewayUrl;\n\t\tconst { requireJobName, ...requestOptions } = {\n\t\t\trequireJobName: true,\n\t\t\t...options,\n\t\t};\n\t\tthis.requireJobName = requireJobName;\n\t\tthis.requestOptions = requestOptions;\n\t}\n\n\tpushAdd(params = {}) {\n\t\tif (this.requireJobName && !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\treturn useGateway.call(this, 'POST', params.jobName, params.groupings);\n\t}\n\n\tpush(params = {}) {\n\t\tif (this.requireJobName && !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\treturn useGateway.call(this, 'PUT', params.jobName, params.groupings);\n\t}\n\n\tdelete(params = {}) {\n\t\tif (this.requireJobName && !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\treturn useGateway.call(this, 'DELETE', params.jobName, params.groupings);\n\t}\n}\nasync function useGateway(method, job, groupings) {\n\t// `URL` first added in v6.13.0\n\t// eslint-disable-next-line n/no-deprecated-api\n\tconst gatewayUrlParsed = url.parse(this.gatewayUrl);\n\tconst gatewayUrlPath =\n\t\tgatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== '/'\n\t\t\t? gatewayUrlParsed.pathname\n\t\t\t: '';\n\tconst jobPath = job\n\t\t? `/job/${encodeURIComponent(job)}${generateGroupings(groupings)}`\n\t\t: '';\n\tconst path = `${gatewayUrlPath}/metrics${jobPath}`;\n\n\t// eslint-disable-next-line n/no-deprecated-api\n\tconst target = url.resolve(this.gatewayUrl, path);\n\t// eslint-disable-next-line n/no-deprecated-api\n\tconst requestParams = url.parse(target);\n\tconst httpModule = isHttps(requestParams.href) ? https : http;\n\tconst options = Object.assign(requestParams, this.requestOptions, {\n\t\tmethod,\n\t});\n\n\treturn new Promise((resolve, reject) => {\n\t\tif (method === 'DELETE' && options.headers) {\n\t\t\tdelete options.headers['Content-Encoding'];\n\t\t}\n\t\tconst req = httpModule.request(options, resp => {\n\t\t\tlet body = '';\n\t\t\tresp.setEncoding('utf8');\n\t\t\tresp.on('data', chunk => {\n\t\t\t\tbody += chunk;\n\t\t\t});\n\t\t\tresp.on('end', () => {\n\t\t\t\tif (resp.statusCode >= 400) {\n\t\t\t\t\treject(\n\t\t\t\t\t\tnew Error(`push failed with status ${resp.statusCode}, ${body}`),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tresolve({ resp, body });\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treq.on('error', err => {\n\t\t\treject(err);\n\t\t});\n\n\t\treq.on('timeout', () => {\n\t\t\treq.destroy(new Error('Pushgateway request timed out'));\n\t\t});\n\n\t\tif (method !== 'DELETE') {\n\t\t\tthis.registry\n\t\t\t\t.metrics()\n\t\t\t\t.then(metrics => {\n\t\t\t\t\tif (\n\t\t\t\t\t\toptions.headers &&\n\t\t\t\t\t\toptions.headers['Content-Encoding'] === 'gzip'\n\t\t\t\t\t) {\n\t\t\t\t\t\tmetrics = gzipSync(metrics);\n\t\t\t\t\t}\n\t\t\t\t\treq.write(metrics);\n\t\t\t\t\treq.end();\n\t\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\treject(err);\n\t\t\t\t});\n\t\t} else {\n\t\t\treq.end();\n\t\t}\n\t});\n}\n\nfunction generateGroupings(groupings) {\n\tif (!groupings) {\n\t\treturn '';\n\t}\n\treturn Object.keys(groupings)\n\t\t.map(\n\t\t\tkey =>\n\t\t\t\t`/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`,\n\t\t)\n\t\t.join('');\n}\n\nfunction isHttps(href) {\n\treturn href.search(/^https/) !== -1;\n}\n\nmodule.exports = Pushgateway;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1690, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/bucketGenerators.js"],"sourcesContent":["'use strict';\n\nexports.linearBuckets = (start, width, count) => {\n\tif (count < 1) {\n\t\tthrow new Error('Linear buckets needs a positive count');\n\t}\n\n\tconst buckets = new Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tbuckets[i] = start + i * width;\n\t}\n\treturn buckets;\n};\n\nexports.exponentialBuckets = (start, factor, count) => {\n\tif (start <= 0) {\n\t\tthrow new Error('Exponential buckets needs a positive start');\n\t}\n\tif (count < 1) {\n\t\tthrow new Error('Exponential buckets needs a positive count');\n\t}\n\tif (factor <= 1) {\n\t\tthrow new Error('Exponential buckets needs a factor greater than 1');\n\t}\n\tconst buckets = new Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tbuckets[i] = start;\n\t\tstart *= factor;\n\t}\n\treturn buckets;\n};\n"],"names":[],"mappings":"AAEA,QAAQ,aAAa,GAAG,CAAC,OAAO,OAAO;IACtC,IAAI,QAAQ,GAAG;QACd,MAAM,IAAI,MAAM;IACjB;IAEA,MAAM,UAAU,IAAI,MAAM;IAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;QAC/B,OAAO,CAAC,EAAE,GAAG,QAAQ,IAAI;IAC1B;IACA,OAAO;AACR;AAEA,QAAQ,kBAAkB,GAAG,CAAC,OAAO,QAAQ;IAC5C,IAAI,SAAS,GAAG;QACf,MAAM,IAAI,MAAM;IACjB;IACA,IAAI,QAAQ,GAAG;QACd,MAAM,IAAI,MAAM;IACjB;IACA,IAAI,UAAU,GAAG;QAChB,MAAM,IAAI,MAAM;IACjB;IACA,MAAM,UAAU,IAAI,MAAM;IAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;QAC/B,OAAO,CAAC,EAAE,GAAG;QACb,SAAS;IACV;IACA,OAAO;AACR","ignoreList":[0]}},
    {"offset": {"line": 1721, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/processCpuTotal.js"],"sourcesContent":["'use strict';\n\nconst OtelApi = require('@opentelemetry/api');\nconst Counter = require('../counter');\n\nconst PROCESS_CPU_USER_SECONDS = 'process_cpu_user_seconds_total';\nconst PROCESS_CPU_SYSTEM_SECONDS = 'process_cpu_system_seconds_total';\nconst PROCESS_CPU_SECONDS = 'process_cpu_seconds_total';\n\nmodule.exports = (registry, config = {}) => {\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst exemplars = config.enableExemplars ? config.enableExemplars : false;\n\tconst labelNames = Object.keys(labels);\n\n\tlet lastCpuUsage = process.cpuUsage();\n\n\tconst cpuUserUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_USER_SECONDS,\n\t\thelp: 'Total user CPU time spent in seconds.',\n\t\tenableExemplars: exemplars,\n\t\tregisters,\n\t\tlabelNames,\n\t\t// Use this one metric's `collect` to set all metrics' values.\n\t\tcollect() {\n\t\t\tconst cpuUsage = process.cpuUsage();\n\n\t\t\tconst userUsageMicros = cpuUsage.user - lastCpuUsage.user;\n\t\t\tconst systemUsageMicros = cpuUsage.system - lastCpuUsage.system;\n\n\t\t\tlastCpuUsage = cpuUsage;\n\n\t\t\tif (this.enableExemplars) {\n\t\t\t\tlet exemplarLabels = {};\n\t\t\t\tconst currentSpan = OtelApi.trace.getSpan(OtelApi.context.active());\n\t\t\t\tif (currentSpan) {\n\t\t\t\t\texemplarLabels = {\n\t\t\t\t\t\ttraceId: currentSpan.spanContext().traceId,\n\t\t\t\t\t\tspanId: currentSpan.spanContext().spanId,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcpuUserUsageCounter.inc({\n\t\t\t\t\tlabels,\n\t\t\t\t\tvalue: userUsageMicros / 1e6,\n\t\t\t\t\texemplarLabels,\n\t\t\t\t});\n\t\t\t\tcpuSystemUsageCounter.inc({\n\t\t\t\t\tlabels,\n\t\t\t\t\tvalue: systemUsageMicros / 1e6,\n\t\t\t\t\texemplarLabels,\n\t\t\t\t});\n\t\t\t\tcpuUsageCounter.inc({\n\t\t\t\t\tlabels,\n\t\t\t\t\tvalue: (userUsageMicros + systemUsageMicros) / 1e6,\n\t\t\t\t\texemplarLabels,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcpuUserUsageCounter.inc(labels, userUsageMicros / 1e6);\n\t\t\t\tcpuSystemUsageCounter.inc(labels, systemUsageMicros / 1e6);\n\t\t\t\tcpuUsageCounter.inc(\n\t\t\t\t\tlabels,\n\t\t\t\t\t(userUsageMicros + systemUsageMicros) / 1e6,\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t});\n\tconst cpuSystemUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,\n\t\thelp: 'Total system CPU time spent in seconds.',\n\t\tenableExemplars: exemplars,\n\t\tregisters,\n\t\tlabelNames,\n\t});\n\tconst cpuUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_SECONDS,\n\t\thelp: 'Total user and system CPU time spent in seconds.',\n\t\tenableExemplars: exemplars,\n\t\tregisters,\n\t\tlabelNames,\n\t});\n};\n\nmodule.exports.metricNames = [\n\tPROCESS_CPU_USER_SECONDS,\n\tPROCESS_CPU_SYSTEM_SECONDS,\n\tPROCESS_CPU_SECONDS,\n];\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,MAAM,2BAA2B;AACjC,MAAM,6BAA6B;AACnC,MAAM,sBAAsB;AAE5B,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,MAAM,YAAY,WAAW;QAAC;KAAS,GAAG;IAC1C,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,YAAY,OAAO,eAAe,GAAG,OAAO,eAAe,GAAG;IACpE,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,IAAI,eAAe,QAAQ,QAAQ;IAEnC,MAAM,sBAAsB,IAAI,QAAQ;QACvC,MAAM,aAAa;QACnB,MAAM;QACN,iBAAiB;QACjB;QACA;QACA,8DAA8D;QAC9D;YACC,MAAM,WAAW,QAAQ,QAAQ;YAEjC,MAAM,kBAAkB,SAAS,IAAI,GAAG,aAAa,IAAI;YACzD,MAAM,oBAAoB,SAAS,MAAM,GAAG,aAAa,MAAM;YAE/D,eAAe;YAEf,IAAI,IAAI,CAAC,eAAe,EAAE;gBACzB,IAAI,iBAAiB,CAAC;gBACtB,MAAM,cAAc,QAAQ,KAAK,CAAC,OAAO,CAAC,QAAQ,OAAO,CAAC,MAAM;gBAChE,IAAI,aAAa;oBAChB,iBAAiB;wBAChB,SAAS,YAAY,WAAW,GAAG,OAAO;wBAC1C,QAAQ,YAAY,WAAW,GAAG,MAAM;oBACzC;gBACD;gBACA,oBAAoB,GAAG,CAAC;oBACvB;oBACA,OAAO,kBAAkB;oBACzB;gBACD;gBACA,sBAAsB,GAAG,CAAC;oBACzB;oBACA,OAAO,oBAAoB;oBAC3B;gBACD;gBACA,gBAAgB,GAAG,CAAC;oBACnB;oBACA,OAAO,CAAC,kBAAkB,iBAAiB,IAAI;oBAC/C;gBACD;YACD,OAAO;gBACN,oBAAoB,GAAG,CAAC,QAAQ,kBAAkB;gBAClD,sBAAsB,GAAG,CAAC,QAAQ,oBAAoB;gBACtD,gBAAgB,GAAG,CAClB,QACA,CAAC,kBAAkB,iBAAiB,IAAI;YAE1C;QACD;IACD;IACA,MAAM,wBAAwB,IAAI,QAAQ;QACzC,MAAM,aAAa;QACnB,MAAM;QACN,iBAAiB;QACjB;QACA;IACD;IACA,MAAM,kBAAkB,IAAI,QAAQ;QACnC,MAAM,aAAa;QACnB,MAAM;QACN,iBAAiB;QACjB;QACA;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAC5B;IACA;IACA;CACA","ignoreList":[0]}},
    {"offset": {"line": 1802, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/processStartTime.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\nconst startInSeconds = Math.round(Date.now() / 1000 - process.uptime());\n\nconst PROCESS_START_TIME = 'process_start_time_seconds';\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tnew Gauge({\n\t\tname: namePrefix + PROCESS_START_TIME,\n\t\thelp: 'Start time of the process since unix epoch in seconds.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\tlabelNames,\n\t\taggregator: 'omit',\n\t\tcollect() {\n\t\t\tthis.set(labels, startInSeconds);\n\t\t},\n\t});\n};\n\nmodule.exports.metricNames = [PROCESS_START_TIME];\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM,iBAAiB,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,OAAO,QAAQ,MAAM;AAEpE,MAAM,qBAAqB;AAE3B,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,WAAW,WAAW;YAAC;SAAS,GAAG;QACnC;QACA,YAAY;QACZ;YACC,IAAI,CAAC,GAAG,CAAC,QAAQ;QAClB;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAAC;CAAmB","ignoreList":[0]}},
    {"offset": {"line": 1829, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\n\nconst values = ['VmSize', 'VmRSS', 'VmData'];\n\nconst PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';\nconst PROCESS_VIRTUAL_MEMORY = 'process_virtual_memory_bytes';\nconst PROCESS_HEAP = 'process_heap_bytes';\n\nfunction structureOutput(input) {\n\treturn input.split('\\n').reduce((acc, string) => {\n\t\tif (!values.some(value => string.startsWith(value))) {\n\t\t\treturn acc;\n\t\t}\n\n\t\tconst split = string.split(':');\n\n\t\t// Get the value\n\t\tlet value = split[1].trim();\n\t\t// Remove trailing ` kb`\n\t\tvalue = value.substr(0, value.length - 3);\n\t\t// Make it into a number in bytes bytes\n\t\tvalue = Number(value) * 1024;\n\n\t\tacc[split[0]] = value;\n\n\t\treturn acc;\n\t}, {});\n}\n\nmodule.exports = (registry, config = {}) => {\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tconst residentMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_RESIDENT_MEMORY,\n\t\thelp: 'Resident memory size in bytes.',\n\t\tregisters,\n\t\tlabelNames,\n\t\t// Use this one metric's `collect` to set all metrics' values.\n\t\tcollect() {\n\t\t\ttry {\n\t\t\t\t// Sync I/O is often problematic, but /proc isn't really I/O, it\n\t\t\t\t// a virtual filesystem that maps directly to in-kernel data\n\t\t\t\t// structures and never blocks.\n\t\t\t\t//\n\t\t\t\t// Node.js/libuv do this already for process.memoryUsage(), see:\n\t\t\t\t// - https://github.com/libuv/libuv/blob/a629688008694ed8022269e66826d4d6ec688b83/src/unix/linux-core.c#L506-L523\n\t\t\t\tconst stat = fs.readFileSync('/proc/self/status', 'utf8');\n\t\t\t\tconst structuredOutput = structureOutput(stat);\n\n\t\t\t\tresidentMemGauge.set(labels, structuredOutput.VmRSS);\n\t\t\t\tvirtualMemGauge.set(labels, structuredOutput.VmSize);\n\t\t\t\theapSizeMemGauge.set(labels, structuredOutput.VmData);\n\t\t\t} catch {\n\t\t\t\t// noop\n\t\t\t}\n\t\t},\n\t});\n\tconst virtualMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_VIRTUAL_MEMORY,\n\t\thelp: 'Virtual memory size in bytes.',\n\t\tregisters,\n\t\tlabelNames,\n\t});\n\tconst heapSizeMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_HEAP,\n\t\thelp: 'Process heap size in bytes.',\n\t\tregisters,\n\t\tlabelNames,\n\t});\n};\n\nmodule.exports.metricNames = [\n\tPROCESS_RESIDENT_MEMORY,\n\tPROCESS_VIRTUAL_MEMORY,\n\tPROCESS_HEAP,\n];\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,MAAM,SAAS;IAAC;IAAU;IAAS;CAAS;AAE5C,MAAM,0BAA0B;AAChC,MAAM,yBAAyB;AAC/B,MAAM,eAAe;AAErB,SAAS,gBAAgB,KAAK;IAC7B,OAAO,MAAM,KAAK,CAAC,MAAM,MAAM,CAAC,CAAC,KAAK;QACrC,IAAI,CAAC,OAAO,IAAI,CAAC,CAAA,QAAS,OAAO,UAAU,CAAC,SAAS;YACpD,OAAO;QACR;QAEA,MAAM,QAAQ,OAAO,KAAK,CAAC;QAE3B,gBAAgB;QAChB,IAAI,QAAQ,KAAK,CAAC,EAAE,CAAC,IAAI;QACzB,wBAAwB;QACxB,QAAQ,MAAM,MAAM,CAAC,GAAG,MAAM,MAAM,GAAG;QACvC,uCAAuC;QACvC,QAAQ,OAAO,SAAS;QAExB,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG;QAEhB,OAAO;IACR,GAAG,CAAC;AACL;AAEA,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,MAAM,YAAY,WAAW;QAAC;KAAS,GAAG;IAC1C,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,MAAM,mBAAmB,IAAI,MAAM;QAClC,MAAM,aAAa;QACnB,MAAM;QACN;QACA;QACA,8DAA8D;QAC9D;YACC,IAAI;gBACH,gEAAgE;gBAChE,4DAA4D;gBAC5D,+BAA+B;gBAC/B,EAAE;gBACF,gEAAgE;gBAChE,iHAAiH;gBACjH,MAAM,OAAO,GAAG,YAAY,CAAC,qBAAqB;gBAClD,MAAM,mBAAmB,gBAAgB;gBAEzC,iBAAiB,GAAG,CAAC,QAAQ,iBAAiB,KAAK;gBACnD,gBAAgB,GAAG,CAAC,QAAQ,iBAAiB,MAAM;gBACnD,iBAAiB,GAAG,CAAC,QAAQ,iBAAiB,MAAM;YACrD,EAAE,OAAM;YACP,OAAO;YACR;QACD;IACD;IACA,MAAM,kBAAkB,IAAI,MAAM;QACjC,MAAM,aAAa;QACnB,MAAM;QACN;QACA;IACD;IACA,MAAM,mBAAmB,IAAI,MAAM;QAClC,MAAM,aAAa;QACnB,MAAM;QACN;QACA;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAC5B;IACA;IACA;CACA","ignoreList":[0]}},
    {"offset": {"line": 1908, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js"],"sourcesContent":["'use strict';\n\n// process.memoryUsage() can throw on some platforms, see #67\nfunction safeMemoryUsage() {\n\ttry {\n\t\treturn process.memoryUsage();\n\t} catch {\n\t\treturn;\n\t}\n}\n\nmodule.exports = safeMemoryUsage;\n"],"names":[],"mappings":"AAEA,6DAA6D;AAC7D,SAAS;IACR,IAAI;QACH,OAAO,QAAQ,WAAW;IAC3B,EAAE,OAAM;QACP;IACD;AACD;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 1921, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/osMemoryHeap.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\nconst linuxVariant = require('./osMemoryHeapLinux');\nconst safeMemoryUsage = require('./helpers/safeMemoryUsage');\n\nconst PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';\n\nfunction notLinuxVariant(registry, config = {}) {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tnew Gauge({\n\t\tname: namePrefix + PROCESS_RESIDENT_MEMORY,\n\t\thelp: 'Resident memory size in bytes.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\tlabelNames,\n\t\tcollect() {\n\t\t\tconst memUsage = safeMemoryUsage();\n\n\t\t\t// I don't think the other things returned from `process.memoryUsage()` is relevant to a standard export\n\t\t\tif (memUsage) {\n\t\t\t\tthis.set(labels, memUsage.rss);\n\t\t\t}\n\t\t},\n\t});\n}\n\nmodule.exports = (registry, config) =>\n\tprocess.platform === 'linux'\n\t\t? linuxVariant(registry, config)\n\t\t: notLinuxVariant(registry, config);\n\nmodule.exports.metricNames =\n\tprocess.platform === 'linux'\n\t\t? linuxVariant.metricNames\n\t\t: [PROCESS_RESIDENT_MEMORY];\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AAEN,MAAM,0BAA0B;AAEhC,SAAS,gBAAgB,QAAQ,EAAE,SAAS,CAAC,CAAC;IAC7C,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,WAAW,WAAW;YAAC;SAAS,GAAG;QACnC;QACA;YACC,MAAM,WAAW;YAEjB,wGAAwG;YACxG,IAAI,UAAU;gBACb,IAAI,CAAC,GAAG,CAAC,QAAQ,SAAS,GAAG;YAC9B;QACD;IACD;AACD;AAEA,OAAO,OAAO,GAAG,CAAC,UAAU,SAC3B,sCACG,0BACA,gBAAgB,UAAU;AAE9B,OAAO,OAAO,CAAC,WAAW,GACzB,sCACG,0BACA;IAAC;CAAwB","ignoreList":[0]}},
    {"offset": {"line": 1953, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\nconst process = require('process');\n\nconst PROCESS_OPEN_FDS = 'process_open_fds';\n\nmodule.exports = (registry, config = {}) => {\n\tif (process.platform !== 'linux') {\n\t\treturn;\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tnew Gauge({\n\t\tname: namePrefix + PROCESS_OPEN_FDS,\n\t\thelp: 'Number of open file descriptors.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\tlabelNames,\n\t\tcollect() {\n\t\t\ttry {\n\t\t\t\tconst fds = fs.readdirSync('/proc/self/fd');\n\t\t\t\t// Minus 1 to not count the fd that was used by readdirSync(),\n\t\t\t\t// it's now closed.\n\t\t\t\tthis.set(labels, fds.length - 1);\n\t\t\t} catch {\n\t\t\t\t// noop\n\t\t\t}\n\t\t},\n\t});\n};\n\nmodule.exports.metricNames = [PROCESS_OPEN_FDS];\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AAEN,MAAM,mBAAmB;AAEzB,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,wCAAkC;QACjC;IACD;;;IAEA,MAAM;IACN,MAAM;IACN,MAAM;AAkBP;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAAC;CAAiB","ignoreList":[0]}},
    {"offset": {"line": 1974, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\n\nconst PROCESS_MAX_FDS = 'process_max_fds';\n\nlet maxFds;\n\nmodule.exports = (registry, config = {}) => {\n\tif (maxFds === undefined) {\n\t\t// This will fail if a linux-like procfs is not available.\n\t\ttry {\n\t\t\tconst limits = fs.readFileSync('/proc/self/limits', 'utf8');\n\t\t\tconst lines = limits.split('\\n');\n\t\t\tfor (const line of lines) {\n\t\t\t\tif (line.startsWith('Max open files')) {\n\t\t\t\t\tconst parts = line.split(/  +/);\n\t\t\t\t\tmaxFds = Number(parts[1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (maxFds === undefined) return;\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tnew Gauge({\n\t\tname: namePrefix + PROCESS_MAX_FDS,\n\t\thelp: 'Maximum number of open file descriptors.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\tlabelNames,\n\t\tcollect() {\n\t\t\tif (maxFds !== undefined) this.set(labels, maxFds);\n\t\t},\n\t});\n};\n\nmodule.exports.metricNames = [PROCESS_MAX_FDS];\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,MAAM,kBAAkB;AAExB,IAAI;AAEJ,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,IAAI,WAAW,WAAW;QACzB,0DAA0D;QAC1D,IAAI;YACH,MAAM,SAAS,GAAG,YAAY,CAAC,qBAAqB;YACpD,MAAM,QAAQ,OAAO,KAAK,CAAC;YAC3B,KAAK,MAAM,QAAQ,MAAO;gBACzB,IAAI,KAAK,UAAU,CAAC,mBAAmB;oBACtC,MAAM,QAAQ,KAAK,KAAK,CAAC;oBACzB,SAAS,OAAO,KAAK,CAAC,EAAE;oBACxB;gBACD;YACD;QACD,EAAE,OAAM;YACP;QACD;IACD;IAEA,IAAI,WAAW,WAAW;IAE1B,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,WAAW,WAAW;YAAC;SAAS,GAAG;QACnC;QACA;YACC,IAAI,WAAW,WAAW,IAAI,CAAC,GAAG,CAAC,QAAQ;QAC5C;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAAC;CAAgB","ignoreList":[0]}},
    {"offset": {"line": 2018, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/eventLoopLag.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\n\n// Check if perf_hooks module is available\nlet perf_hooks;\ntry {\n\tperf_hooks = require('perf_hooks');\n} catch {\n\t// node version is too old\n}\n\n// Reported always.\nconst NODEJS_EVENTLOOP_LAG = 'nodejs_eventloop_lag_seconds';\n\n// Reported only when perf_hooks is available.\nconst NODEJS_EVENTLOOP_LAG_MIN = 'nodejs_eventloop_lag_min_seconds';\nconst NODEJS_EVENTLOOP_LAG_MAX = 'nodejs_eventloop_lag_max_seconds';\nconst NODEJS_EVENTLOOP_LAG_MEAN = 'nodejs_eventloop_lag_mean_seconds';\nconst NODEJS_EVENTLOOP_LAG_STDDEV = 'nodejs_eventloop_lag_stddev_seconds';\nconst NODEJS_EVENTLOOP_LAG_P50 = 'nodejs_eventloop_lag_p50_seconds';\nconst NODEJS_EVENTLOOP_LAG_P90 = 'nodejs_eventloop_lag_p90_seconds';\nconst NODEJS_EVENTLOOP_LAG_P99 = 'nodejs_eventloop_lag_p99_seconds';\n\nfunction reportEventloopLag(start, gauge, labels) {\n\tconst delta = process.hrtime(start);\n\tconst nanosec = delta[0] * 1e9 + delta[1];\n\tconst seconds = nanosec / 1e9;\n\n\tgauge.set(labels, seconds);\n}\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\tconst registers = registry ? [registry] : undefined;\n\n\tlet collect = () => {\n\t\tconst start = process.hrtime();\n\t\tsetImmediate(reportEventloopLag, start, lag, labels);\n\t};\n\n\tif (perf_hooks && perf_hooks.monitorEventLoopDelay) {\n\t\ttry {\n\t\t\tconst histogram = perf_hooks.monitorEventLoopDelay({\n\t\t\t\tresolution: config.eventLoopMonitoringPrecision,\n\t\t\t});\n\t\t\thistogram.enable();\n\n\t\t\tcollect = () => {\n\t\t\t\tconst start = process.hrtime();\n\t\t\t\tsetImmediate(reportEventloopLag, start, lag, labels);\n\n\t\t\t\tlagMin.set(labels, histogram.min / 1e9);\n\t\t\t\tlagMax.set(labels, histogram.max / 1e9);\n\t\t\t\tlagMean.set(labels, histogram.mean / 1e9);\n\t\t\t\tlagStddev.set(labels, histogram.stddev / 1e9);\n\t\t\t\tlagP50.set(labels, histogram.percentile(50) / 1e9);\n\t\t\t\tlagP90.set(labels, histogram.percentile(90) / 1e9);\n\t\t\t\tlagP99.set(labels, histogram.percentile(99) / 1e9);\n\n\t\t\t\thistogram.reset();\n\t\t\t};\n\t\t} catch (e) {\n\t\t\tif (e.code === 'ERR_NOT_IMPLEMENTED') {\n\t\t\t\treturn; // Bun\n\t\t\t}\n\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tconst lag = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG,\n\t\thelp: 'Lag of event loop in seconds.',\n\t\tregisters,\n\t\tlabelNames,\n\t\taggregator: 'average',\n\t\t// Use this one metric's `collect` to set all metrics' values.\n\t\tcollect,\n\t});\n\tconst lagMin = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG_MIN,\n\t\thelp: 'The minimum recorded event loop delay.',\n\t\tregisters,\n\t\tlabelNames,\n\t\taggregator: 'min',\n\t});\n\tconst lagMax = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG_MAX,\n\t\thelp: 'The maximum recorded event loop delay.',\n\t\tregisters,\n\t\tlabelNames,\n\t\taggregator: 'max',\n\t});\n\tconst lagMean = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG_MEAN,\n\t\thelp: 'The mean of the recorded event loop delays.',\n\t\tregisters,\n\t\tlabelNames,\n\t\taggregator: 'average',\n\t});\n\tconst lagStddev = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG_STDDEV,\n\t\thelp: 'The standard deviation of the recorded event loop delays.',\n\t\tregisters,\n\t\tlabelNames,\n\t\taggregator: 'average',\n\t});\n\tconst lagP50 = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG_P50,\n\t\thelp: 'The 50th percentile of the recorded event loop delays.',\n\t\tregisters,\n\t\tlabelNames,\n\t\taggregator: 'average',\n\t});\n\tconst lagP90 = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG_P90,\n\t\thelp: 'The 90th percentile of the recorded event loop delays.',\n\t\tregisters,\n\t\tlabelNames,\n\t\taggregator: 'average',\n\t});\n\tconst lagP99 = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG_P99,\n\t\thelp: 'The 99th percentile of the recorded event loop delays.',\n\t\tregisters,\n\t\tlabelNames,\n\t\taggregator: 'average',\n\t});\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_EVENTLOOP_LAG,\n\tNODEJS_EVENTLOOP_LAG_MIN,\n\tNODEJS_EVENTLOOP_LAG_MAX,\n\tNODEJS_EVENTLOOP_LAG_MEAN,\n\tNODEJS_EVENTLOOP_LAG_STDDEV,\n\tNODEJS_EVENTLOOP_LAG_P50,\n\tNODEJS_EVENTLOOP_LAG_P90,\n\tNODEJS_EVENTLOOP_LAG_P99,\n];\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2151, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js"],"sourcesContent":["'use strict';\n\nfunction aggregateByObjectName(list) {\n\tconst data = {};\n\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst listElement = list[i];\n\n\t\tif (!listElement || typeof listElement.constructor === 'undefined') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (Object.hasOwnProperty.call(data, listElement.constructor.name)) {\n\t\t\tdata[listElement.constructor.name] += 1;\n\t\t} else {\n\t\t\tdata[listElement.constructor.name] = 1;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction updateMetrics(gauge, data, labels) {\n\tgauge.reset();\n\tfor (const key in data) {\n\t\tgauge.set(Object.assign({ type: key }, labels || {}), data[key]);\n\t}\n}\n\nmodule.exports = {\n\taggregateByObjectName,\n\tupdateMetrics,\n};\n"],"names":[],"mappings":"AAEA,SAAS,sBAAsB,IAAI;IAClC,MAAM,OAAO,CAAC;IAEd,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;QACrC,MAAM,cAAc,IAAI,CAAC,EAAE;QAE3B,IAAI,CAAC,eAAe,OAAO,YAAY,WAAW,KAAK,aAAa;YACnE;QACD;QAEA,IAAI,OAAO,cAAc,CAAC,IAAI,CAAC,MAAM,YAAY,WAAW,CAAC,IAAI,GAAG;YACnE,IAAI,CAAC,YAAY,WAAW,CAAC,IAAI,CAAC,IAAI;QACvC,OAAO;YACN,IAAI,CAAC,YAAY,WAAW,CAAC,IAAI,CAAC,GAAG;QACtC;IACD;IACA,OAAO;AACR;AAEA,SAAS,cAAc,KAAK,EAAE,IAAI,EAAE,MAAM;IACzC,MAAM,KAAK;IACX,IAAK,MAAM,OAAO,KAAM;QACvB,MAAM,GAAG,CAAC,OAAO,MAAM,CAAC;YAAE,MAAM;QAAI,GAAG,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI;IAChE;AACD;AAEA,OAAO,OAAO,GAAG;IAChB;IACA;AACD","ignoreList":[0]}},
    {"offset": {"line": 2182, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/processHandles.js"],"sourcesContent":["'use strict';\n\nconst { aggregateByObjectName } = require('./helpers/processMetricsHelpers');\nconst { updateMetrics } = require('./helpers/processMetricsHelpers');\nconst Gauge = require('../gauge');\n\nconst NODEJS_ACTIVE_HANDLES = 'nodejs_active_handles';\nconst NODEJS_ACTIVE_HANDLES_TOTAL = 'nodejs_active_handles_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function is removed in later nodes (exists in node@6-12...)\n\tif (typeof process._getActiveHandles !== 'function') {\n\t\treturn;\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tnew Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_HANDLES,\n\t\thelp: 'Number of active libuv handles grouped by handle type. Every handle type is C++ class name.',\n\t\tlabelNames: ['type', ...labelNames],\n\t\tregisters,\n\t\tcollect() {\n\t\t\tconst handles = process._getActiveHandles();\n\t\t\tupdateMetrics(this, aggregateByObjectName(handles), labels);\n\t\t},\n\t});\n\tnew Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_HANDLES_TOTAL,\n\t\thelp: 'Total number of active handles.',\n\t\tregisters,\n\t\tlabelNames,\n\t\tcollect() {\n\t\t\tconst handles = process._getActiveHandles();\n\t\t\tthis.set(labels, handles.length);\n\t\t},\n\t});\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_ACTIVE_HANDLES,\n\tNODEJS_ACTIVE_HANDLES_TOTAL,\n];\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,qBAAqB,EAAE;AAC/B,MAAM,EAAE,aAAa,EAAE;AACvB,MAAM;AAEN,MAAM,wBAAwB;AAC9B,MAAM,8BAA8B;AAEpC,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,uFAAuF;IACvF,IAAI,OAAO,QAAQ,iBAAiB,KAAK,YAAY;QACpD;IACD;IAEA,MAAM,YAAY,WAAW;QAAC;KAAS,GAAG;IAC1C,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,YAAY;YAAC;eAAW;SAAW;QACnC;QACA;YACC,MAAM,UAAU,QAAQ,iBAAiB;YACzC,cAAc,IAAI,EAAE,sBAAsB,UAAU;QACrD;IACD;IACA,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN;QACA;QACA;YACC,MAAM,UAAU,QAAQ,iBAAiB;YACzC,IAAI,CAAC,GAAG,CAAC,QAAQ,QAAQ,MAAM;QAChC;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAC5B;IACA;CACA","ignoreList":[0]}},
    {"offset": {"line": 2230, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/processRequests.js"],"sourcesContent":["'use strict';\nconst Gauge = require('../gauge');\nconst { aggregateByObjectName } = require('./helpers/processMetricsHelpers');\nconst { updateMetrics } = require('./helpers/processMetricsHelpers');\n\nconst NODEJS_ACTIVE_REQUESTS = 'nodejs_active_requests';\nconst NODEJS_ACTIVE_REQUESTS_TOTAL = 'nodejs_active_requests_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function is removed in later nodes (exists in node@6)\n\tif (typeof process._getActiveRequests !== 'function') {\n\t\treturn;\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tnew Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_REQUESTS,\n\t\thelp: 'Number of active libuv requests grouped by request type. Every request type is C++ class name.',\n\t\tlabelNames: ['type', ...labelNames],\n\t\tregisters: registry ? [registry] : undefined,\n\t\tcollect() {\n\t\t\tconst requests = process._getActiveRequests();\n\t\t\tupdateMetrics(this, aggregateByObjectName(requests), labels);\n\t\t},\n\t});\n\n\tnew Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_REQUESTS_TOTAL,\n\t\thelp: 'Total number of active requests.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\tlabelNames,\n\t\tcollect() {\n\t\t\tconst requests = process._getActiveRequests();\n\t\t\tthis.set(labels, requests.length);\n\t\t},\n\t});\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_ACTIVE_REQUESTS,\n\tNODEJS_ACTIVE_REQUESTS_TOTAL,\n];\n"],"names":[],"mappings":"AACA,MAAM;AACN,MAAM,EAAE,qBAAqB,EAAE;AAC/B,MAAM,EAAE,aAAa,EAAE;AAEvB,MAAM,yBAAyB;AAC/B,MAAM,+BAA+B;AAErC,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,iFAAiF;IACjF,IAAI,OAAO,QAAQ,kBAAkB,KAAK,YAAY;QACrD;IACD;IAEA,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,YAAY;YAAC;eAAW;SAAW;QACnC,WAAW,WAAW;YAAC;SAAS,GAAG;QACnC;YACC,MAAM,WAAW,QAAQ,kBAAkB;YAC3C,cAAc,IAAI,EAAE,sBAAsB,WAAW;QACtD;IACD;IAEA,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,WAAW,WAAW;YAAC;SAAS,GAAG;QACnC;QACA;YACC,MAAM,WAAW,QAAQ,kBAAkB;YAC3C,IAAI,CAAC,GAAG,CAAC,QAAQ,SAAS,MAAM;QACjC;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAC5B;IACA;CACA","ignoreList":[0]}},
    {"offset": {"line": 2279, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/processResources.js"],"sourcesContent":["'use strict';\nconst Gauge = require('../gauge');\nconst { updateMetrics } = require('./helpers/processMetricsHelpers');\n\nconst NODEJS_ACTIVE_RESOURCES = 'nodejs_active_resources';\nconst NODEJS_ACTIVE_RESOURCES_TOTAL = 'nodejs_active_resources_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function does not exist in previous nodes (exists in node@17.3.0)\n\tif (typeof process.getActiveResourcesInfo !== 'function') {\n\t\treturn;\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tnew Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_RESOURCES,\n\t\thelp: 'Number of active resources that are currently keeping the event loop alive, grouped by async resource type.',\n\t\tlabelNames: ['type', ...labelNames],\n\t\tregisters: registry ? [registry] : undefined,\n\t\tcollect() {\n\t\t\tconst resources = process.getActiveResourcesInfo();\n\n\t\t\tconst data = {};\n\n\t\t\tfor (let i = 0; i < resources.length; i++) {\n\t\t\t\tconst resource = resources[i];\n\n\t\t\t\tif (Object.hasOwn(data, resource)) {\n\t\t\t\t\tdata[resource] += 1;\n\t\t\t\t} else {\n\t\t\t\t\tdata[resource] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateMetrics(this, data, labels);\n\t\t},\n\t});\n\n\tnew Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_RESOURCES_TOTAL,\n\t\thelp: 'Total number of active resources.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\tlabelNames,\n\t\tcollect() {\n\t\t\tconst resources = process.getActiveResourcesInfo();\n\t\t\tthis.set(labels, resources.length);\n\t\t},\n\t});\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_ACTIVE_RESOURCES,\n\tNODEJS_ACTIVE_RESOURCES_TOTAL,\n];\n"],"names":[],"mappings":"AACA,MAAM;AACN,MAAM,EAAE,aAAa,EAAE;AAEvB,MAAM,0BAA0B;AAChC,MAAM,gCAAgC;AAEtC,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,6FAA6F;IAC7F,IAAI,OAAO,QAAQ,sBAAsB,KAAK,YAAY;QACzD;IACD;IAEA,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,YAAY;YAAC;eAAW;SAAW;QACnC,WAAW,WAAW;YAAC;SAAS,GAAG;QACnC;YACC,MAAM,YAAY,QAAQ,sBAAsB;YAEhD,MAAM,OAAO,CAAC;YAEd,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;gBAC1C,MAAM,WAAW,SAAS,CAAC,EAAE;gBAE7B,IAAI,OAAO,MAAM,CAAC,MAAM,WAAW;oBAClC,IAAI,CAAC,SAAS,IAAI;gBACnB,OAAO;oBACN,IAAI,CAAC,SAAS,GAAG;gBAClB;YACD;YAEA,cAAc,IAAI,EAAE,MAAM;QAC3B;IACD;IAEA,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,WAAW,WAAW;YAAC;SAAS,GAAG;QACnC;QACA;YACC,MAAM,YAAY,QAAQ,sBAAsB;YAChD,IAAI,CAAC,GAAG,CAAC,QAAQ,UAAU,MAAM;QAClC;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAC5B;IACA;CACA","ignoreList":[0]}},
    {"offset": {"line": 2336, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/heapSizeAndUsed.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\nconst safeMemoryUsage = require('./helpers/safeMemoryUsage');\n\nconst NODEJS_HEAP_SIZE_TOTAL = 'nodejs_heap_size_total_bytes';\nconst NODEJS_HEAP_SIZE_USED = 'nodejs_heap_size_used_bytes';\nconst NODEJS_EXTERNAL_MEMORY = 'nodejs_external_memory_bytes';\n\nmodule.exports = (registry, config = {}) => {\n\tif (typeof process.memoryUsage !== 'function') {\n\t\treturn;\n\t}\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst collect = () => {\n\t\tconst memUsage = safeMemoryUsage();\n\t\tif (memUsage) {\n\t\t\theapSizeTotal.set(labels, memUsage.heapTotal);\n\t\t\theapSizeUsed.set(labels, memUsage.heapUsed);\n\t\t\tif (memUsage.external !== undefined) {\n\t\t\t\texternalMemUsed.set(labels, memUsage.external);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst heapSizeTotal = new Gauge({\n\t\tname: namePrefix + NODEJS_HEAP_SIZE_TOTAL,\n\t\thelp: 'Process heap size from Node.js in bytes.',\n\t\tregisters,\n\t\tlabelNames,\n\t\t// Use this one metric's `collect` to set all metrics' values.\n\t\tcollect,\n\t});\n\tconst heapSizeUsed = new Gauge({\n\t\tname: namePrefix + NODEJS_HEAP_SIZE_USED,\n\t\thelp: 'Process heap size used from Node.js in bytes.',\n\t\tregisters,\n\t\tlabelNames,\n\t});\n\tconst externalMemUsed = new Gauge({\n\t\tname: namePrefix + NODEJS_EXTERNAL_MEMORY,\n\t\thelp: 'Node.js external memory size in bytes.',\n\t\tregisters,\n\t\tlabelNames,\n\t});\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_HEAP_SIZE_TOTAL,\n\tNODEJS_HEAP_SIZE_USED,\n\tNODEJS_EXTERNAL_MEMORY,\n];\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,MAAM,yBAAyB;AAC/B,MAAM,wBAAwB;AAC9B,MAAM,yBAAyB;AAE/B,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,IAAI,OAAO,QAAQ,WAAW,KAAK,YAAY;QAC9C;IACD;IACA,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,MAAM,YAAY,WAAW;QAAC;KAAS,GAAG;IAC1C,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,UAAU;QACf,MAAM,WAAW;QACjB,IAAI,UAAU;YACb,cAAc,GAAG,CAAC,QAAQ,SAAS,SAAS;YAC5C,aAAa,GAAG,CAAC,QAAQ,SAAS,QAAQ;YAC1C,IAAI,SAAS,QAAQ,KAAK,WAAW;gBACpC,gBAAgB,GAAG,CAAC,QAAQ,SAAS,QAAQ;YAC9C;QACD;IACD;IAEA,MAAM,gBAAgB,IAAI,MAAM;QAC/B,MAAM,aAAa;QACnB,MAAM;QACN;QACA;QACA,8DAA8D;QAC9D;IACD;IACA,MAAM,eAAe,IAAI,MAAM;QAC9B,MAAM,aAAa;QACnB,MAAM;QACN;QACA;IACD;IACA,MAAM,kBAAkB,IAAI,MAAM;QACjC,MAAM,aAAa;QACnB,MAAM;QACN;QACA;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAC5B;IACA;IACA;CACA","ignoreList":[0]}},
    {"offset": {"line": 2391, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\nconst v8 = require('v8');\n\nconst METRICS = ['total', 'used', 'available'];\nconst NODEJS_HEAP_SIZE = {};\n\nMETRICS.forEach(metricType => {\n\tNODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;\n});\n\nmodule.exports = (registry, config = {}) => {\n\ttry {\n\t\tv8.getHeapSpaceStatistics();\n\t} catch (e) {\n\t\tif (e.code === 'ERR_NOT_IMPLEMENTED') {\n\t\t\treturn; // Bun\n\t\t}\n\t\tthrow e;\n\t}\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = ['space', ...Object.keys(labels)];\n\n\tconst gauges = {};\n\n\tMETRICS.forEach(metricType => {\n\t\tgauges[metricType] = new Gauge({\n\t\t\tname: namePrefix + NODEJS_HEAP_SIZE[metricType],\n\t\t\thelp: `Process heap space size ${metricType} from Node.js in bytes.`,\n\t\t\tlabelNames,\n\t\t\tregisters,\n\t\t});\n\t});\n\n\t// Use this one metric's `collect` to set all metrics' values.\n\tgauges.total.collect = () => {\n\t\tfor (const space of v8.getHeapSpaceStatistics()) {\n\t\t\tconst spaceName = space.space_name.substr(\n\t\t\t\t0,\n\t\t\t\tspace.space_name.indexOf('_space'),\n\t\t\t);\n\n\t\t\tgauges.total.set({ space: spaceName, ...labels }, space.space_size);\n\t\t\tgauges.used.set({ space: spaceName, ...labels }, space.space_used_size);\n\t\t\tgauges.available.set(\n\t\t\t\t{ space: spaceName, ...labels },\n\t\t\t\tspace.space_available_size,\n\t\t\t);\n\t\t}\n\t};\n};\n\nmodule.exports.metricNames = Object.values(NODEJS_HEAP_SIZE);\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,MAAM,UAAU;IAAC;IAAS;IAAQ;CAAY;AAC9C,MAAM,mBAAmB,CAAC;AAE1B,QAAQ,OAAO,CAAC,CAAA;IACf,gBAAgB,CAAC,WAAW,GAAG,CAAC,uBAAuB,EAAE,WAAW,MAAM,CAAC;AAC5E;AAEA,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,IAAI;QACH,GAAG,sBAAsB;IAC1B,EAAE,OAAO,GAAG;QACX,IAAI,EAAE,IAAI,KAAK,uBAAuB;YACrC,QAAQ,MAAM;QACf;QACA,MAAM;IACP;IACA,MAAM,YAAY,WAAW;QAAC;KAAS,GAAG;IAC1C,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IAEnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa;QAAC;WAAY,OAAO,IAAI,CAAC;KAAQ;IAEpD,MAAM,SAAS,CAAC;IAEhB,QAAQ,OAAO,CAAC,CAAA;QACf,MAAM,CAAC,WAAW,GAAG,IAAI,MAAM;YAC9B,MAAM,aAAa,gBAAgB,CAAC,WAAW;YAC/C,MAAM,CAAC,wBAAwB,EAAE,WAAW,uBAAuB,CAAC;YACpE;YACA;QACD;IACD;IAEA,8DAA8D;IAC9D,OAAO,KAAK,CAAC,OAAO,GAAG;QACtB,KAAK,MAAM,SAAS,GAAG,sBAAsB,GAAI;YAChD,MAAM,YAAY,MAAM,UAAU,CAAC,MAAM,CACxC,GACA,MAAM,UAAU,CAAC,OAAO,CAAC;YAG1B,OAAO,KAAK,CAAC,GAAG,CAAC;gBAAE,OAAO;gBAAW,GAAG,MAAM;YAAC,GAAG,MAAM,UAAU;YAClE,OAAO,IAAI,CAAC,GAAG,CAAC;gBAAE,OAAO;gBAAW,GAAG,MAAM;YAAC,GAAG,MAAM,eAAe;YACtE,OAAO,SAAS,CAAC,GAAG,CACnB;gBAAE,OAAO;gBAAW,GAAG,MAAM;YAAC,GAC9B,MAAM,oBAAoB;QAE5B;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG,OAAO,MAAM,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2453, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/version.js"],"sourcesContent":["'use strict';\n\nconst Gauge = require('../gauge');\nconst version = process.version;\nconst versionSegments = version.slice(1).split('.').map(Number);\n\nconst NODE_VERSION_INFO = 'nodejs_version_info';\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\n\tnew Gauge({\n\t\tname: namePrefix + NODE_VERSION_INFO,\n\t\thelp: 'Node.js version info.',\n\t\tlabelNames: ['version', 'major', 'minor', 'patch', ...labelNames],\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'first',\n\t\tcollect() {\n\t\t\t// Needs to be in collect() so value is present even if reg is reset\n\t\t\tthis.labels(\n\t\t\t\tversion,\n\t\t\t\tversionSegments[0],\n\t\t\t\tversionSegments[1],\n\t\t\t\tversionSegments[2],\n\t\t\t\t...Object.values(labels),\n\t\t\t).set(1);\n\t\t},\n\t});\n};\n\nmodule.exports.metricNames = [NODE_VERSION_INFO];\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM,UAAU,QAAQ,OAAO;AAC/B,MAAM,kBAAkB,QAAQ,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC;AAExD,MAAM,oBAAoB;AAE1B,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAE/B,IAAI,MAAM;QACT,MAAM,aAAa;QACnB,MAAM;QACN,YAAY;YAAC;YAAW;YAAS;YAAS;eAAY;SAAW;QACjE,WAAW,WAAW;YAAC;SAAS,GAAG;QACnC,YAAY;QACZ;YACC,oEAAoE;YACpE,IAAI,CAAC,MAAM,CACV,SACA,eAAe,CAAC,EAAE,EAClB,eAAe,CAAC,EAAE,EAClB,eAAe,CAAC,EAAE,KACf,OAAO,MAAM,CAAC,SAChB,GAAG,CAAC;QACP;IACD;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAAC;CAAkB","ignoreList":[0]}},
    {"offset": {"line": 2488, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metrics/gc.js"],"sourcesContent":["'use strict';\nconst Histogram = require('../histogram');\n\nlet perf_hooks;\n\ntry {\n\t// eslint-disable-next-line\n\tperf_hooks = require('perf_hooks');\n} catch {\n\t// node version is too old\n}\n\nconst NODEJS_GC_DURATION_SECONDS = 'nodejs_gc_duration_seconds';\nconst DEFAULT_GC_DURATION_BUCKETS = [0.001, 0.01, 0.1, 1, 2, 5];\n\nconst kinds = [];\n\nif (perf_hooks && perf_hooks.constants) {\n\tkinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MAJOR] = 'major';\n\tkinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MINOR] = 'minor';\n\tkinds[perf_hooks.constants.NODE_PERFORMANCE_GC_INCREMENTAL] = 'incremental';\n\tkinds[perf_hooks.constants.NODE_PERFORMANCE_GC_WEAKCB] = 'weakcb';\n}\n\nmodule.exports = (registry, config = {}) => {\n\tif (!perf_hooks) {\n\t\treturn;\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\tconst labels = config.labels ? config.labels : {};\n\tconst labelNames = Object.keys(labels);\n\tconst buckets = config.gcDurationBuckets\n\t\t? config.gcDurationBuckets\n\t\t: DEFAULT_GC_DURATION_BUCKETS;\n\tconst gcHistogram = new Histogram({\n\t\tname: namePrefix + NODEJS_GC_DURATION_SECONDS,\n\t\thelp: 'Garbage collection duration by kind, one of major, minor, incremental or weakcb.',\n\t\tlabelNames: ['kind', ...labelNames],\n\t\tenableExemplars: false,\n\t\tbuckets,\n\t\tregisters: registry ? [registry] : undefined,\n\t});\n\n\tconst obs = new perf_hooks.PerformanceObserver(list => {\n\t\tconst entry = list.getEntries()[0];\n\t\t// Node < 16 uses entry.kind\n\t\t// Node >= 16 uses entry.detail.kind\n\t\t// See: https://nodejs.org/docs/latest-v16.x/api/deprecations.html#deprecations_dep0152_extension_performanceentry_properties\n\t\tconst kind = entry.detail ? kinds[entry.detail.kind] : kinds[entry.kind];\n\t\t// Convert duration from milliseconds to seconds\n\t\tgcHistogram.observe(Object.assign({ kind }, labels), entry.duration / 1000);\n\t});\n\n\tobs.observe({ entryTypes: ['gc'] });\n};\n\nmodule.exports.metricNames = [NODEJS_GC_DURATION_SECONDS];\n"],"names":[],"mappings":"AACA,MAAM;AAEN,IAAI;AAEJ,IAAI;IACH,2BAA2B;IAC3B;AACD,EAAE,OAAM;AACP,0BAA0B;AAC3B;AAEA,MAAM,6BAA6B;AACnC,MAAM,8BAA8B;IAAC;IAAO;IAAM;IAAK;IAAG;IAAG;CAAE;AAE/D,MAAM,QAAQ,EAAE;AAEhB,IAAI,cAAc,WAAW,SAAS,EAAE;IACvC,KAAK,CAAC,WAAW,SAAS,CAAC,yBAAyB,CAAC,GAAG;IACxD,KAAK,CAAC,WAAW,SAAS,CAAC,yBAAyB,CAAC,GAAG;IACxD,KAAK,CAAC,WAAW,SAAS,CAAC,+BAA+B,CAAC,GAAG;IAC9D,KAAK,CAAC,WAAW,SAAS,CAAC,0BAA0B,CAAC,GAAG;AAC1D;AAEA,OAAO,OAAO,GAAG,CAAC,UAAU,SAAS,CAAC,CAAC;IACtC,IAAI,CAAC,YAAY;QAChB;IACD;IAEA,MAAM,aAAa,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG;IACnD,MAAM,SAAS,OAAO,MAAM,GAAG,OAAO,MAAM,GAAG,CAAC;IAChD,MAAM,aAAa,OAAO,IAAI,CAAC;IAC/B,MAAM,UAAU,OAAO,iBAAiB,GACrC,OAAO,iBAAiB,GACxB;IACH,MAAM,cAAc,IAAI,UAAU;QACjC,MAAM,aAAa;QACnB,MAAM;QACN,YAAY;YAAC;eAAW;SAAW;QACnC,iBAAiB;QACjB;QACA,WAAW,WAAW;YAAC;SAAS,GAAG;IACpC;IAEA,MAAM,MAAM,IAAI,WAAW,mBAAmB,CAAC,CAAA;QAC9C,MAAM,QAAQ,KAAK,UAAU,EAAE,CAAC,EAAE;QAClC,4BAA4B;QAC5B,oCAAoC;QACpC,6HAA6H;QAC7H,MAAM,OAAO,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,IAAI,CAAC;QACxE,gDAAgD;QAChD,YAAY,OAAO,CAAC,OAAO,MAAM,CAAC;YAAE;QAAK,GAAG,SAAS,MAAM,QAAQ,GAAG;IACvE;IAEA,IAAI,OAAO,CAAC;QAAE,YAAY;YAAC;SAAK;IAAC;AAClC;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG;IAAC;CAA2B","ignoreList":[0]}},
    {"offset": {"line": 2557, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/defaultMetrics.js"],"sourcesContent":["'use strict';\n\nconst { isObject } = require('./util');\n\n// Default metrics.\nconst processCpuTotal = require('./metrics/processCpuTotal');\nconst processStartTime = require('./metrics/processStartTime');\nconst osMemoryHeap = require('./metrics/osMemoryHeap');\nconst processOpenFileDescriptors = require('./metrics/processOpenFileDescriptors');\nconst processMaxFileDescriptors = require('./metrics/processMaxFileDescriptors');\nconst eventLoopLag = require('./metrics/eventLoopLag');\nconst processHandles = require('./metrics/processHandles');\nconst processRequests = require('./metrics/processRequests');\nconst processResources = require('./metrics/processResources');\nconst heapSizeAndUsed = require('./metrics/heapSizeAndUsed');\nconst heapSpacesSizeAndUsed = require('./metrics/heapSpacesSizeAndUsed');\nconst version = require('./metrics/version');\nconst gc = require('./metrics/gc');\n\nconst metrics = {\n\tprocessCpuTotal,\n\tprocessStartTime,\n\tosMemoryHeap,\n\tprocessOpenFileDescriptors,\n\tprocessMaxFileDescriptors,\n\teventLoopLag,\n\t...(typeof process.getActiveResourcesInfo === 'function'\n\t\t? { processResources }\n\t\t: {}),\n\tprocessHandles,\n\tprocessRequests,\n\theapSizeAndUsed,\n\theapSpacesSizeAndUsed,\n\tversion,\n\tgc,\n};\nconst metricsList = Object.keys(metrics);\n\nmodule.exports = function collectDefaultMetrics(config) {\n\tif (config !== null && config !== undefined && !isObject(config)) {\n\t\tthrow new TypeError('config must be null, undefined, or an object');\n\t}\n\n\tconfig = { eventLoopMonitoringPrecision: 10, ...config };\n\n\tfor (const metric of Object.values(metrics)) {\n\t\tmetric(config.register, config);\n\t}\n};\n\nmodule.exports.metricsList = metricsList;\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,QAAQ,EAAE;AAElB,mBAAmB;AACnB,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN,MAAM,UAAU;IACf;IACA;IACA;IACA;IACA;IACA;IACA,GAAI,OAAO,QAAQ,sBAAsB,KAAK,aAC3C;QAAE;IAAiB,IACnB,CAAC,CAAC;IACL;IACA;IACA;IACA;IACA;IACA;AACD;AACA,MAAM,cAAc,OAAO,IAAI,CAAC;AAEhC,OAAO,OAAO,GAAG,SAAS,sBAAsB,MAAM;IACrD,IAAI,WAAW,QAAQ,WAAW,aAAa,CAAC,SAAS,SAAS;QACjE,MAAM,IAAI,UAAU;IACrB;IAEA,SAAS;QAAE,8BAA8B;QAAI,GAAG,MAAM;IAAC;IAEvD,KAAK,MAAM,UAAU,OAAO,MAAM,CAAC,SAAU;QAC5C,OAAO,OAAO,QAAQ,EAAE;IACzB;AACD;AAEA,OAAO,OAAO,CAAC,WAAW,GAAG","ignoreList":[0]}},
    {"offset": {"line": 2607, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/metricAggregators.js"],"sourcesContent":["'use strict';\n\nconst { Grouper, hashObject } = require('./util');\n\n/**\n * Returns a new function that applies the `aggregatorFn` to the values.\n * @param {Function} aggregatorFn function to apply to values.\n * @return {Function} aggregator function\n */\nfunction AggregatorFactory(aggregatorFn) {\n\treturn metrics => {\n\t\tif (metrics.length === 0) return;\n\t\tconst result = {\n\t\t\thelp: metrics[0].help,\n\t\t\tname: metrics[0].name,\n\t\t\ttype: metrics[0].type,\n\t\t\tvalues: [],\n\t\t\taggregator: metrics[0].aggregator,\n\t\t};\n\t\t// Gather metrics by metricName and labels.\n\t\tconst byLabels = new Grouper();\n\t\tmetrics.forEach(metric => {\n\t\t\tmetric.values.forEach(value => {\n\t\t\t\tconst key = hashObject(value.labels);\n\t\t\t\tbyLabels.add(`${value.metricName}_${key}`, value);\n\t\t\t});\n\t\t});\n\t\t// Apply aggregator function to gathered metrics.\n\t\tbyLabels.forEach(values => {\n\t\t\tif (values.length === 0) return;\n\t\t\tconst valObj = {\n\t\t\t\tvalue: aggregatorFn(values),\n\t\t\t\tlabels: values[0].labels,\n\t\t\t};\n\t\t\tif (values[0].metricName) {\n\t\t\t\tvalObj.metricName = values[0].metricName;\n\t\t\t}\n\t\t\t// NB: Timestamps are omitted.\n\t\t\tresult.values.push(valObj);\n\t\t});\n\t\treturn result;\n\t};\n}\n// Export for users to define their own aggregation methods.\nexports.AggregatorFactory = AggregatorFactory;\n\n/**\n * Functions that can be used to aggregate metrics from multiple registries.\n */\nexports.aggregators = {\n\t/**\n\t * @return The sum of values.\n\t */\n\tsum: AggregatorFactory(v => v.reduce((p, c) => p + c.value, 0)),\n\t/**\n\t * @return The first value.\n\t */\n\tfirst: AggregatorFactory(v => v[0].value),\n\t/**\n\t * @return {undefined} Undefined; omits the metric.\n\t */\n\tomit: () => {},\n\t/**\n\t * @return The arithmetic mean of the values.\n\t */\n\taverage: AggregatorFactory(\n\t\tv => v.reduce((p, c) => p + c.value, 0) / v.length,\n\t),\n\t/**\n\t * @return The minimum of the values.\n\t */\n\tmin: AggregatorFactory(v =>\n\t\tv.reduce((p, c) => Math.min(p, c.value), Infinity),\n\t),\n\t/**\n\t * @return The maximum of the values.\n\t */\n\tmax: AggregatorFactory(v =>\n\t\tv.reduce((p, c) => Math.max(p, c.value), -Infinity),\n\t),\n};\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE;AAE7B;;;;CAIC,GACD,SAAS,kBAAkB,YAAY;IACtC,OAAO,CAAA;QACN,IAAI,QAAQ,MAAM,KAAK,GAAG;QAC1B,MAAM,SAAS;YACd,MAAM,OAAO,CAAC,EAAE,CAAC,IAAI;YACrB,MAAM,OAAO,CAAC,EAAE,CAAC,IAAI;YACrB,MAAM,OAAO,CAAC,EAAE,CAAC,IAAI;YACrB,QAAQ,EAAE;YACV,YAAY,OAAO,CAAC,EAAE,CAAC,UAAU;QAClC;QACA,2CAA2C;QAC3C,MAAM,WAAW,IAAI;QACrB,QAAQ,OAAO,CAAC,CAAA;YACf,OAAO,MAAM,CAAC,OAAO,CAAC,CAAA;gBACrB,MAAM,MAAM,WAAW,MAAM,MAAM;gBACnC,SAAS,GAAG,CAAC,GAAG,MAAM,UAAU,CAAC,CAAC,EAAE,KAAK,EAAE;YAC5C;QACD;QACA,iDAAiD;QACjD,SAAS,OAAO,CAAC,CAAA;YAChB,IAAI,OAAO,MAAM,KAAK,GAAG;YACzB,MAAM,SAAS;gBACd,OAAO,aAAa;gBACpB,QAAQ,MAAM,CAAC,EAAE,CAAC,MAAM;YACzB;YACA,IAAI,MAAM,CAAC,EAAE,CAAC,UAAU,EAAE;gBACzB,OAAO,UAAU,GAAG,MAAM,CAAC,EAAE,CAAC,UAAU;YACzC;YACA,8BAA8B;YAC9B,OAAO,MAAM,CAAC,IAAI,CAAC;QACpB;QACA,OAAO;IACR;AACD;AACA,4DAA4D;AAC5D,QAAQ,iBAAiB,GAAG;AAE5B;;CAEC,GACD,QAAQ,WAAW,GAAG;IACrB;;EAEC,GACD,KAAK,kBAAkB,CAAA,IAAK,EAAE,MAAM,CAAC,CAAC,GAAG,IAAM,IAAI,EAAE,KAAK,EAAE;IAC5D;;EAEC,GACD,OAAO,kBAAkB,CAAA,IAAK,CAAC,CAAC,EAAE,CAAC,KAAK;IACxC;;EAEC,GACD,MAAM,KAAO;IACb;;EAEC,GACD,SAAS,kBACR,CAAA,IAAK,EAAE,MAAM,CAAC,CAAC,GAAG,IAAM,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM;IAEnD;;EAEC,GACD,KAAK,kBAAkB,CAAA,IACtB,EAAE,MAAM,CAAC,CAAC,GAAG,IAAM,KAAK,GAAG,CAAC,GAAG,EAAE,KAAK,GAAG;IAE1C;;EAEC,GACD,KAAK,kBAAkB,CAAA,IACtB,EAAE,MAAM,CAAC,CAAC,GAAG,IAAM,KAAK,GAAG,CAAC,GAAG,EAAE,KAAK,GAAG,CAAC;AAE5C","ignoreList":[0]}},
    {"offset": {"line": 2674, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/lib/cluster.js"],"sourcesContent":["'use strict';\n\n/**\n * Extends the Registry class with a `clusterMetrics` method that returns\n * aggregated metrics for all workers.\n *\n * In cluster workers, listens for and responds to requests for metrics by the\n * cluster master.\n */\n\nconst Registry = require('./registry');\nconst { Grouper } = require('./util');\nconst { aggregators } = require('./metricAggregators');\n// We need to lazy-load the 'cluster' module as some application servers -\n// namely Passenger - crash when it is imported.\nlet cluster = () => {\n\tconst data = require('cluster');\n\tcluster = () => data;\n\treturn data;\n};\n\nconst GET_METRICS_REQ = 'prom-client:getMetricsReq';\nconst GET_METRICS_RES = 'prom-client:getMetricsRes';\n\nlet registries = [Registry.globalRegistry];\nlet requestCtr = 0; // Concurrency control\nlet listenersAdded = false;\nconst requests = new Map(); // Pending requests for workers' local metrics.\n\nclass AggregatorRegistry extends Registry {\n\tconstructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {\n\t\tsuper(regContentType);\n\t\taddListeners();\n\t}\n\n\t/**\n\t * Gets aggregated metrics for all workers. The optional callback and\n\t * returned Promise resolve with the same value; either may be used.\n\t * @return {Promise<string>} Promise that resolves with the aggregated\n\t *   metrics.\n\t */\n\tclusterMetrics() {\n\t\tconst requestId = requestCtr++;\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet settled = false;\n\t\t\tfunction done(err, result) {\n\t\t\t\tif (settled) return;\n\t\t\t\tsettled = true;\n\t\t\t\tif (err) reject(err);\n\t\t\t\telse resolve(result);\n\t\t\t}\n\n\t\t\tconst request = {\n\t\t\t\tresponses: [],\n\t\t\t\tpending: 0,\n\t\t\t\tdone,\n\t\t\t\terrorTimeout: setTimeout(() => {\n\t\t\t\t\tconst err = new Error('Operation timed out.');\n\t\t\t\t\trequest.done(err);\n\t\t\t\t}, 5000),\n\t\t\t};\n\t\t\trequests.set(requestId, request);\n\n\t\t\tconst message = {\n\t\t\t\ttype: GET_METRICS_REQ,\n\t\t\t\trequestId,\n\t\t\t};\n\n\t\t\tfor (const id in cluster().workers) {\n\t\t\t\t// If the worker exits abruptly, it may still be in the workers\n\t\t\t\t// list but not able to communicate.\n\t\t\t\tif (cluster().workers[id].isConnected()) {\n\t\t\t\t\tcluster().workers[id].send(message);\n\t\t\t\t\trequest.pending++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (request.pending === 0) {\n\t\t\t\t// No workers were up\n\t\t\t\tclearTimeout(request.errorTimeout);\n\t\t\t\tprocess.nextTick(() => done(null, ''));\n\t\t\t}\n\t\t});\n\t}\n\n\tget contentType() {\n\t\treturn super.contentType;\n\t}\n\n\t/**\n\t * Creates a new Registry instance from an array of metrics that were\n\t * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using\n\t * the method specified by their `aggregator` property, or by summation if\n\t * `aggregator` is undefined.\n\t * @param {Array} metricsArr Array of metrics, each of which created by\n\t *   `registry.getMetricsAsJSON()`.\n\t * @param {string} registryType content type of the new registry. Defaults\n\t * to PROMETHEUS_CONTENT_TYPE.\n\t * @return {Registry} aggregated registry.\n\t */\n\tstatic aggregate(\n\t\tmetricsArr,\n\t\tregistryType = Registry.PROMETHEUS_CONTENT_TYPE,\n\t) {\n\t\tconst aggregatedRegistry = new Registry();\n\t\tconst metricsByName = new Grouper();\n\n\t\taggregatedRegistry.setContentType(registryType);\n\n\t\t// Gather by name\n\t\tmetricsArr.forEach(metrics => {\n\t\t\tmetrics.forEach(metric => {\n\t\t\t\tmetricsByName.add(metric.name, metric);\n\t\t\t});\n\t\t});\n\n\t\t// Aggregate gathered metrics.\n\t\tmetricsByName.forEach(metrics => {\n\t\t\tconst aggregatorName = metrics[0].aggregator;\n\t\t\tconst aggregatorFn = aggregators[aggregatorName];\n\t\t\tif (typeof aggregatorFn !== 'function') {\n\t\t\t\tthrow new Error(`'${aggregatorName}' is not a defined aggregator.`);\n\t\t\t}\n\t\t\tconst aggregatedMetric = aggregatorFn(metrics);\n\t\t\t// NB: The 'omit' aggregator returns undefined.\n\t\t\tif (aggregatedMetric) {\n\t\t\t\tconst aggregatedMetricWrapper = Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\tget: () => aggregatedMetric,\n\t\t\t\t\t},\n\t\t\t\t\taggregatedMetric,\n\t\t\t\t);\n\t\t\t\taggregatedRegistry.registerMetric(aggregatedMetricWrapper);\n\t\t\t}\n\t\t});\n\n\t\treturn aggregatedRegistry;\n\t}\n\n\t/**\n\t * Sets the registry or registries to be aggregated. Call from workers to\n\t * use a registry/registries other than the default global registry.\n\t * @param {Array<Registry>|Registry} regs Registry or registries to be\n\t *   aggregated.\n\t * @return {void}\n\t */\n\tstatic setRegistries(regs) {\n\t\tif (!Array.isArray(regs)) regs = [regs];\n\t\tregs.forEach(reg => {\n\t\t\tif (!(reg instanceof Registry)) {\n\t\t\t\tthrow new TypeError(`Expected Registry, got ${typeof reg}`);\n\t\t\t}\n\t\t});\n\t\tregistries = regs;\n\t}\n}\n\n/**\n * Adds event listeners for cluster aggregation. Idempotent (safe to call more\n * than once).\n * @return {void}\n */\nfunction addListeners() {\n\tif (listenersAdded) return;\n\tlistenersAdded = true;\n\n\tif (cluster().isMaster) {\n\t\t// Listen for worker responses to requests for local metrics\n\t\tcluster().on('message', (worker, message) => {\n\t\t\tif (message.type === GET_METRICS_RES) {\n\t\t\t\tconst request = requests.get(message.requestId);\n\n\t\t\t\tif (message.error) {\n\t\t\t\t\trequest.done(new Error(message.error));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmessage.metrics.forEach(registry => request.responses.push(registry));\n\t\t\t\trequest.pending--;\n\n\t\t\t\tif (request.pending === 0) {\n\t\t\t\t\t// finalize\n\t\t\t\t\trequests.delete(message.requestId);\n\t\t\t\t\tclearTimeout(request.errorTimeout);\n\n\t\t\t\t\tconst registry = AggregatorRegistry.aggregate(request.responses);\n\t\t\t\t\tconst promString = registry.metrics();\n\t\t\t\t\trequest.done(null, promString);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tif (cluster().isWorker) {\n\t\t// Respond to master's requests for worker's local metrics.\n\t\tprocess.on('message', message => {\n\t\t\tif (message.type === GET_METRICS_REQ) {\n\t\t\t\tPromise.all(registries.map(r => r.getMetricsAsJSON()))\n\t\t\t\t\t.then(metrics => {\n\t\t\t\t\t\tprocess.send({\n\t\t\t\t\t\t\ttype: GET_METRICS_RES,\n\t\t\t\t\t\t\trequestId: message.requestId,\n\t\t\t\t\t\t\tmetrics,\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\tprocess.send({\n\t\t\t\t\t\t\ttype: GET_METRICS_RES,\n\t\t\t\t\t\t\trequestId: message.requestId,\n\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = AggregatorRegistry;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2861, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/prom-client/index.js"],"sourcesContent":["/**\n * Prometheus client\n * @module Prometheus client\n */\n\n'use strict';\n\nexports.register = require('./lib/registry').globalRegistry;\nexports.Registry = require('./lib/registry');\nObject.defineProperty(exports, 'contentType', {\n\tconfigurable: false,\n\tenumerable: true,\n\tget() {\n\t\treturn exports.register.contentType;\n\t},\n\tset(value) {\n\t\texports.register.setContentType(value);\n\t},\n});\nexports.prometheusContentType = exports.Registry.PROMETHEUS_CONTENT_TYPE;\nexports.openMetricsContentType = exports.Registry.OPENMETRICS_CONTENT_TYPE;\nexports.validateMetricName = require('./lib/validation').validateMetricName;\n\nexports.Counter = require('./lib/counter');\nexports.Gauge = require('./lib/gauge');\nexports.Histogram = require('./lib/histogram');\nexports.Summary = require('./lib/summary');\nexports.Pushgateway = require('./lib/pushgateway');\n\nexports.linearBuckets = require('./lib/bucketGenerators').linearBuckets;\nexports.exponentialBuckets =\n\trequire('./lib/bucketGenerators').exponentialBuckets;\n\nexports.collectDefaultMetrics = require('./lib/defaultMetrics');\n\nexports.aggregators = require('./lib/metricAggregators').aggregators;\nexports.AggregatorRegistry = require('./lib/cluster');\n"],"names":[],"mappings":"AAAA;;;CAGC,GAID,QAAQ,QAAQ,GAAG,uGAA0B,cAAc;AAC3D,QAAQ,QAAQ;AAChB,OAAO,cAAc,CAAC,SAAS,eAAe;IAC7C,cAAc;IACd,YAAY;IACZ;QACC,OAAO,QAAQ,QAAQ,CAAC,WAAW;IACpC;IACA,KAAI,KAAK;QACR,QAAQ,QAAQ,CAAC,cAAc,CAAC;IACjC;AACD;AACA,QAAQ,qBAAqB,GAAG,QAAQ,QAAQ,CAAC,uBAAuB;AACxE,QAAQ,sBAAsB,GAAG,QAAQ,QAAQ,CAAC,wBAAwB;AAC1E,QAAQ,kBAAkB,GAAG,yGAA4B,kBAAkB;AAE3E,QAAQ,OAAO;AACf,QAAQ,KAAK;AACb,QAAQ,SAAS;AACjB,QAAQ,OAAO;AACf,QAAQ,WAAW;AAEnB,QAAQ,aAAa,GAAG,+GAAkC,aAAa;AACvE,QAAQ,kBAAkB,GACzB,+GAAkC,kBAAkB;AAErD,QAAQ,qBAAqB;AAE7B,QAAQ,WAAW,GAAG,gHAAmC,WAAW;AACpE,QAAQ,kBAAkB","ignoreList":[0]}},
    {"offset": {"line": 2892, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/bintrees/lib/treebase.js"],"sourcesContent":["\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3089, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/bintrees/lib/rbtree.js"],"sourcesContent":["\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3263, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/bintrees/lib/bintree.js"],"sourcesContent":["\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n"],"names":[],"mappings":"AACA,IAAI;AAEJ,SAAS,KAAK,IAAI;IACd,IAAI,CAAC,IAAI,GAAG;IACZ,IAAI,CAAC,IAAI,GAAG;IACZ,IAAI,CAAC,KAAK,GAAG;AACjB;AAEA,KAAK,SAAS,CAAC,SAAS,GAAG,SAAS,GAAG;IACnC,OAAO,MAAM,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI;AACvC;AAEA,KAAK,SAAS,CAAC,SAAS,GAAG,SAAS,GAAG,EAAE,GAAG;IACxC,IAAG,KAAK;QACJ,IAAI,CAAC,KAAK,GAAG;IACjB,OACK;QACD,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AAEA,SAAS,QAAQ,UAAU;IACvB,IAAI,CAAC,KAAK,GAAG;IACb,IAAI,CAAC,WAAW,GAAG;IACnB,IAAI,CAAC,IAAI,GAAG;AAChB;AAEA,QAAQ,SAAS,GAAG,IAAI;AAExB,+CAA+C;AAC/C,QAAQ,SAAS,CAAC,MAAM,GAAG,SAAS,IAAI;IACpC,IAAG,IAAI,CAAC,KAAK,KAAK,MAAM;QACpB,aAAa;QACb,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK;QACtB,IAAI,CAAC,IAAI;QACT,OAAO;IACX;IAEA,IAAI,MAAM;IAEV,QAAQ;IACR,IAAI,IAAI,MAAM,SAAS;IACvB,IAAI,OAAO,IAAI,CAAC,KAAK;IAErB,cAAc;IACd,MAAM,KAAM;QACR,IAAG,SAAS,MAAM;YACd,gCAAgC;YAChC,OAAO,IAAI,KAAK;YAChB,EAAE,SAAS,CAAC,KAAK;YACjB,MAAM;YACN,IAAI,CAAC,IAAI;YACT,OAAO;QACX;QAEA,gBAAgB;QAChB,IAAG,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI,EAAE,UAAU,GAAG;YACxC,OAAO;QACX;QAEA,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI,EAAE,QAAQ;QAE1C,iBAAiB;QACjB,IAAI;QACJ,OAAO,KAAK,SAAS,CAAC;IAC1B;AACJ;AAEA,8CAA8C;AAC9C,QAAQ,SAAS,CAAC,MAAM,GAAG,SAAS,IAAI;IACpC,IAAG,IAAI,CAAC,KAAK,KAAK,MAAM;QACpB,OAAO;IACX;IAEA,IAAI,OAAO,IAAI,KAAK,YAAY,iBAAiB;IACjD,IAAI,OAAO;IACX,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;IACvB,IAAI,IAAI,MAAM,SAAS;IACvB,IAAI,QAAQ,MAAM,aAAa;IAC/B,IAAI,MAAM;IAEV,MAAM,KAAK,SAAS,CAAC,SAAS,KAAM;QAChC,IAAI;QACJ,OAAO,KAAK,SAAS,CAAC;QACtB,IAAI,MAAM,IAAI,CAAC,WAAW,CAAC,MAAM,KAAK,IAAI;QAC1C,MAAM,MAAM;QAEZ,IAAG,QAAQ,GAAG;YACV,QAAQ;QACZ;IACJ;IAEA,IAAG,UAAU,MAAM;QACf,MAAM,IAAI,GAAG,KAAK,IAAI;QACtB,EAAE,SAAS,CAAC,EAAE,KAAK,KAAK,MAAM,KAAK,SAAS,CAAC,KAAK,IAAI,KAAK;QAE3D,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK;QACvB,IAAI,CAAC,IAAI;QACT,OAAO;IACX,OACK;QACD,OAAO;IACX;AACJ;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 3351, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/bintrees/index.js"],"sourcesContent":["module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n"],"names":[],"mappings":"AAAA,OAAO,OAAO,GAAG;IACb,MAAM;IACN,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 3358, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/node_modules/tdigest/tdigest.js"],"sourcesContent":["//\n// TDigest:\n//\n// approximate distribution percentiles from a stream of reals\n//\nvar RBTree = require('bintrees').RBTree;\n\nfunction TDigest(delta, K, CX) {\n    // allocate a TDigest structure.\n    //\n    // delta is the compression factor, the max fraction of mass that\n    // can be owned by one centroid (bigger, up to 1.0, means more\n    // compression). delta=false switches off TDigest behavior and treats\n    // the distribution as discrete, with no merging and exact values\n    // reported.\n    //\n    // K is a size threshold that triggers recompression as the TDigest\n    // grows during input.  (Set it to 0 to disable automatic recompression)\n    //\n    // CX specifies how often to update cached cumulative totals used\n    // for quantile estimation during ingest (see cumulate()).  Set to\n    // 0 to use exact quantiles for each new point.\n    //\n    this.discrete = (delta === false);\n    this.delta = delta || 0.01;\n    this.K = (K === undefined) ? 25 : K;\n    this.CX = (CX === undefined) ? 1.1 : CX;\n    this.centroids = new RBTree(compare_centroid_means);\n    this.nreset = 0;\n    this.reset();\n}\n\nTDigest.prototype.reset = function() {\n    // prepare to digest new points.\n    //\n    this.centroids.clear();\n    this.n = 0;\n    this.nreset += 1;\n    this.last_cumulate = 0;\n};\n\nTDigest.prototype.size = function() {\n    return this.centroids.size;\n};\n\nTDigest.prototype.toArray = function(everything) {\n    // return {mean,n} of centroids as an array ordered by mean.\n    //\n    var result = [];\n    if (everything) {\n        this._cumulate(true); // be sure cumns are exact\n        this.centroids.each(function(c) { result.push(c); });\n    } else {\n        this.centroids.each(function(c) { result.push({mean:c.mean, n:c.n}); });\n    }\n    return result;\n};\n\nTDigest.prototype.summary = function() {\n    var approx = (this.discrete) ? \"exact \" : \"approximating \";\n    var s = [approx + this.n + \" samples using \" + this.size() + \" centroids\",\n             \"min = \"+this.percentile(0),\n             \"Q1  = \"+this.percentile(0.25),\n             \"Q2  = \"+this.percentile(0.5),\n             \"Q3  = \"+this.percentile(0.75),\n             \"max = \"+this.percentile(1.0)];\n    return s.join('\\n');\n};\n\nfunction compare_centroid_means(a, b) {\n    // order two centroids by mean.\n    //\n    return (a.mean > b.mean) ? 1 : (a.mean < b.mean) ? -1 : 0;\n}\n\nfunction compare_centroid_mean_cumns(a, b) {\n    // order two centroids by mean_cumn.\n    //\n    return (a.mean_cumn - b.mean_cumn);\n}\n\nTDigest.prototype.push = function(x, n) {\n    // incorporate value or array of values x, having count n into the\n    // TDigest. n defaults to 1.\n    //\n    n = n || 1;\n    x = Array.isArray(x) ? x : [x];\n    for (var i = 0 ; i < x.length ; i++) {\n        this._digest(x[i], n);\n    }\n};\n\nTDigest.prototype.push_centroid = function(c) {\n    // incorporate centroid or array of centroids c\n    //\n    c = Array.isArray(c) ? c : [c];\n    for (var i = 0 ; i < c.length ; i++) {\n        this._digest(c[i].mean, c[i].n);\n    }\n};\n\nTDigest.prototype._cumulate = function(exact) {\n    // update cumulative counts for each centroid\n    //\n    // exact: falsey means only cumulate after sufficient\n    // growth. During ingest, these counts are used as quantile\n    // estimates, and they work well even when somewhat out of\n    // date. (this is a departure from the publication, you may set CX\n    // to 0 to disable).\n    //\n    if (this.n === this.last_cumulate ||\n        !exact && this.CX && this.CX > (this.n / this.last_cumulate)) {\n        return;\n    }\n    var cumn = 0;\n    this.centroids.each(function(c) {\n        c.mean_cumn = cumn + c.n / 2; // half of n at the mean\n        cumn = c.cumn = cumn + c.n;\n    });\n    this.n = this.last_cumulate = cumn;\n};\n\nTDigest.prototype.find_nearest = function(x) {\n    // find the centroid closest to x. The assumption of\n    // unique means and a unique nearest centroid departs from the\n    // paper, see _digest() below\n    //\n    if (this.size() === 0) {\n        return null;\n    }\n    var iter = this.centroids.lowerBound({mean:x}); // x <= iter || iter==null\n    var c = (iter.data() === null) ? iter.prev() : iter.data();\n    if (c.mean === x || this.discrete) {\n        return c; // c is either x or a neighbor (discrete: no distance func)\n    }\n    var prev = iter.prev();\n    if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {\n        return prev;\n    } else {\n        return c;\n    }\n};\n\nTDigest.prototype._new_centroid = function(x, n, cumn) {\n    // create and insert a new centroid into the digest (don't update\n    // cumulatives).\n    //\n    var c = {mean:x, n:n, cumn:cumn};\n    this.centroids.insert(c);\n    this.n += n;\n    return c;\n};\n\nTDigest.prototype._addweight = function(nearest, x, n) {\n    // add weight at location x to nearest centroid.  adding x to\n    // nearest will not shift its relative position in the tree and\n    // require reinsertion.\n    //\n    if (x !== nearest.mean) {\n        nearest.mean += n * (x - nearest.mean) / (nearest.n + n);\n    }\n    nearest.cumn += n;\n    nearest.mean_cumn += n / 2;\n    nearest.n += n;\n    this.n += n;\n};\n\nTDigest.prototype._digest = function(x, n) {\n    // incorporate value x, having count n into the TDigest.\n    //\n    var min = this.centroids.min();\n    var max = this.centroids.max();\n    var nearest = this.find_nearest(x);\n    if (nearest && nearest.mean === x) {\n        // accumulate exact matches into the centroid without\n        // limit. this is a departure from the paper, made so\n        // centroids remain unique and code can be simple.\n        this._addweight(nearest, x, n);\n    } else if (nearest === min) {\n        this._new_centroid(x, n, 0); // new point around min boundary\n    } else if (nearest === max ) {\n        this._new_centroid(x, n, this.n); // new point around max boundary\n    } else if (this.discrete) {\n        this._new_centroid(x, n, nearest.cumn); // never merge\n    } else {\n        // conider a merge based on nearest centroid's capacity. if\n        // there's not room for all of n, don't bother merging any of\n        // it into nearest, as we'll have to make a new centroid\n        // anyway for the remainder (departure from the paper).\n        var p = nearest.mean_cumn / this.n;\n        var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));\n        if (max_n - nearest.n >= n) {\n            this._addweight(nearest, x, n);\n        } else {\n            this._new_centroid(x, n, nearest.cumn);\n        }\n    }\n    this._cumulate(false);\n    if (!this.discrete && this.K && this.size() > this.K / this.delta) {\n        // re-process the centroids and hope for some compression.\n        this.compress();\n    }\n};\n\nTDigest.prototype.bound_mean = function(x) {\n    // find centroids lower and upper such that lower.mean < x <\n    // upper.mean or lower.mean === x === upper.mean. Don't call\n    // this for x out of bounds.\n    //\n    var iter = this.centroids.upperBound({mean:x}); // x < iter\n    var lower = iter.prev();      // lower <= x\n    var upper = (lower.mean === x) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.p_rank = function(x_or_xlist) {\n    // return approximate percentile-ranks (0..1) for data value x.\n    // or list of x.  calculated according to\n    // https://en.wikipedia.org/wiki/Percentile_rank\n    //\n    // (Note that in continuous mode, boundary sample values will\n    // report half their centroid weight inward from 0/1 as the\n    // percentile-rank. X values outside the observed range return\n    // 0/1)\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];\n    var ps = xs.map(this._p_rank, this);\n    return Array.isArray(x_or_xlist) ? ps : ps[0];\n};\n\nTDigest.prototype._p_rank = function(x) {\n    if (this.size() === 0) {\n        return undefined;\n    } else if (x < this.centroids.min().mean) {\n        return 0.0;\n    } else if (x > this.centroids.max().mean) {\n        return 1.0;\n    }\n    // find centroids that bracket x and interpolate x's cumn from\n    // their cumn's.\n    this._cumulate(true); // be sure cumns are exact\n    var bound = this.bound_mean(x);\n    var lower = bound[0], upper = bound[1];\n    if (this.discrete) {\n        return lower.cumn / this.n;\n    } else {\n        var cumn = lower.mean_cumn;\n        if (lower !== upper) {\n            cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);\n        }\n        return cumn / this.n;\n    }\n};\n\nTDigest.prototype.bound_mean_cumn = function(cumn) {\n    // find centroids lower and upper such that lower.mean_cumn < x <\n    // upper.mean_cumn or lower.mean_cumn === x === upper.mean_cumn. Don't call\n    // this for cumn out of bounds.\n    //\n    // XXX because mean and mean_cumn give rise to the same sort order\n    // (up to identical means), use the mean rbtree for our search.\n    this.centroids._comparator = compare_centroid_mean_cumns;\n    var iter = this.centroids.upperBound({mean_cumn:cumn}); // cumn < iter\n    this.centroids._comparator = compare_centroid_means;\n    var lower = iter.prev();      // lower <= cumn\n    var upper = (lower && lower.mean_cumn === cumn) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.percentile = function(p_or_plist) {\n    // for percentage p (0..1), or for each p in a list of ps, return\n    // the smallest data value q at which at least p percent of the\n    // observations <= q.\n    //\n    // for discrete distributions, this selects q using the Nearest\n    // Rank Method\n    // (https://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method)\n    // (in scipy, same as percentile(...., interpolation='higher')\n    //\n    // for continuous distributions, interpolates data values between\n    // count-weighted bracketing means.\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];\n    var qs = ps.map(this._percentile, this);\n    return Array.isArray(p_or_plist) ? qs : qs[0];\n};\n\nTDigest.prototype._percentile = function(p) {\n    if (this.size() === 0) {\n        return undefined;\n    }\n    this._cumulate(true); // be sure cumns are exact\n    var h = this.n * p;\n    var bound = this.bound_mean_cumn(h);\n    var lower = bound[0], upper = bound[1];\n\n    if (upper === lower || lower === null || upper === null) {\n        return (lower || upper).mean;\n    } else if (!this.discrete) {\n        return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);\n    } else if (h <= lower.cumn) {\n        return lower.mean;\n    } else {\n        return upper.mean;\n    }\n};\n\nfunction pop_random(choices) {\n    // remove and return an item randomly chosen from the array of choices\n    // (mutates choices)\n    //\n    var idx = Math.floor(Math.random() * choices.length);\n    return choices.splice(idx, 1)[0];\n}\n\nTDigest.prototype.compress = function() {\n    // TDigests experience worst case compression (none) when input\n    // increases monotonically.  Improve on any bad luck by\n    // reconsuming digest centroids as if they were weighted points\n    // while shuffling their order (and hope for the best).\n    //\n    if (this.compressing) {\n        return;\n    }\n    var points = this.toArray();\n    this.reset();\n    this.compressing = true;\n    while (points.length > 0) {\n        this.push_centroid(pop_random(points));\n    }\n    this._cumulate(true);\n    this.compressing = false;\n};\n\nfunction Digest(config) {\n    // allocate a distribution digest structure. This is an extension\n    // of a TDigest structure that starts in exact histogram (discrete)\n    // mode, and automatically switches to TDigest mode for large\n    // samples that appear to be from a continuous distribution.\n    //\n    this.config = config || {};\n    this.mode = this.config.mode || 'auto'; // disc, cont, auto\n    TDigest.call(this, this.mode === 'cont' ? config.delta : false);\n    this.digest_ratio = this.config.ratio || 0.9;\n    this.digest_thresh = this.config.thresh || 1000;\n    this.n_unique = 0;\n}\nDigest.prototype = Object.create(TDigest.prototype);\nDigest.prototype.constructor = Digest;\n\nDigest.prototype.push = function(x_or_xlist) {\n    TDigest.prototype.push.call(this, x_or_xlist);\n    this.check_continuous();\n};\n\nDigest.prototype._new_centroid = function(x, n, cumn) {\n    this.n_unique += 1;\n    TDigest.prototype._new_centroid.call(this, x, n, cumn);\n};\n\nDigest.prototype._addweight = function(nearest, x, n) {\n    if (nearest.n === 1) {\n        this.n_unique -= 1;\n    }\n    TDigest.prototype._addweight.call(this, nearest, x, n);\n};\n\nDigest.prototype.check_continuous = function() {\n    // while in 'auto' mode, if there are many unique elements, assume\n    // they are from a continuous distribution and switch to 'cont'\n    // mode (tdigest behavior). Return true on transition from\n    // disctete to continuous.\n    if (this.mode !== 'auto' || this.size() < this.digest_thresh) {\n        return false;\n    }\n    if (this.n_unique / this.size() > this.digest_ratio) {\n        this.mode = 'cont';\n        this.discrete = false;\n        this.delta = this.config.delta || 0.01;\n        this.compress();\n        return true;\n    }\n    return false;\n};\n\nmodule.exports = {\n    'TDigest': TDigest,\n    'Digest': Digest\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}