module.exports = [
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/async_search.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class AsyncSearch {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'async_search.delete': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'async_search.get': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'keep_alive',
                    'typed_keys',
                    'wait_for_completion_timeout'
                ]
            },
            'async_search.status': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'keep_alive'
                ]
            },
            'async_search.submit': {
                path: [
                    'index'
                ],
                body: [
                    'aggregations',
                    'aggs',
                    'collapse',
                    'explain',
                    'ext',
                    'from',
                    'highlight',
                    'track_total_hits',
                    'indices_boost',
                    'docvalue_fields',
                    'knn',
                    'min_score',
                    'post_filter',
                    'profile',
                    'query',
                    'rescore',
                    'script_fields',
                    'search_after',
                    'size',
                    'slice',
                    'sort',
                    '_source',
                    'fields',
                    'suggest',
                    'terminate_after',
                    'timeout',
                    'track_scores',
                    'version',
                    'seq_no_primary_term',
                    'stored_fields',
                    'pit',
                    'runtime_mappings',
                    'stats'
                ],
                query: [
                    'wait_for_completion_timeout',
                    'keep_alive',
                    'keep_on_completion',
                    'allow_no_indices',
                    'allow_partial_search_results',
                    'analyzer',
                    'analyze_wildcard',
                    'batched_reduce_size',
                    'ccs_minimize_roundtrips',
                    'default_operator',
                    'df',
                    'docvalue_fields',
                    'expand_wildcards',
                    'explain',
                    'ignore_throttled',
                    'ignore_unavailable',
                    'lenient',
                    'max_concurrent_shard_requests',
                    'preference',
                    'project_routing',
                    'request_cache',
                    'routing',
                    'search_type',
                    'stats',
                    'stored_fields',
                    'suggest_field',
                    'suggest_mode',
                    'suggest_size',
                    'suggest_text',
                    'terminate_after',
                    'timeout',
                    'track_total_hits',
                    'track_scores',
                    'typed_keys',
                    'rest_total_hits_as_int',
                    'version',
                    '_source',
                    '_source_excludes',
                    '_source_includes',
                    'seq_no_primary_term',
                    'q',
                    'size',
                    'from',
                    'sort'
                ]
            }
        };
    }
    async delete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['async_search.delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_async_search/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'async_search.delete',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async get(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['async_search.get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_async_search/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'async_search.get',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'keep_alive',
                'typed_keys',
                'wait_for_completion_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async status(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['async_search.status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_async_search/status/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'async_search.status',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'keep_alive'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async submit(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['async_search.submit'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                if (key === 'sort' && typeof params[key] === 'string' && params[key].includes(':')) {
                    querystring[key] = params[key];
                } else {
                    // @ts-expect-error
                    body[key] = params[key];
                }
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'POST';
            path = `/${encodeURIComponent(params.index.toString())}/_async_search`;
        } else {
            method = 'POST';
            path = '/_async_search';
        }
        const meta = {
            name: 'async_search.submit',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'aggregations',
                'aggs',
                'collapse',
                'explain',
                'ext',
                'from',
                'highlight',
                'track_total_hits',
                'indices_boost',
                'docvalue_fields',
                'knn',
                'min_score',
                'post_filter',
                'profile',
                'query',
                'rescore',
                'script_fields',
                'search_after',
                'size',
                'slice',
                'sort',
                '_source',
                'fields',
                'suggest',
                'terminate_after',
                'timeout',
                'track_scores',
                'version',
                'seq_no_primary_term',
                'stored_fields',
                'pit',
                'runtime_mappings',
                'stats',
                'wait_for_completion_timeout',
                'keep_alive',
                'keep_on_completion',
                'allow_no_indices',
                'allow_partial_search_results',
                'analyzer',
                'analyze_wildcard',
                'batched_reduce_size',
                'ccs_minimize_roundtrips',
                'default_operator',
                'df',
                'docvalue_fields',
                'expand_wildcards',
                'explain',
                'ignore_throttled',
                'ignore_unavailable',
                'lenient',
                'max_concurrent_shard_requests',
                'preference',
                'project_routing',
                'request_cache',
                'routing',
                'search_type',
                'stats',
                'stored_fields',
                'suggest_field',
                'suggest_mode',
                'suggest_size',
                'suggest_text',
                'terminate_after',
                'timeout',
                'track_total_hits',
                'track_scores',
                'typed_keys',
                'rest_total_hits_as_int',
                'version',
                '_source',
                '_source_excludes',
                '_source_includes',
                'seq_no_primary_term',
                'q',
                'size',
                'from',
                'sort'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = AsyncSearch; //# sourceMappingURL=async_search.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/autoscaling.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Autoscaling {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'autoscaling.delete_autoscaling_policy': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'autoscaling.get_autoscaling_capacity': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'autoscaling.get_autoscaling_policy': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'autoscaling.put_autoscaling_policy': {
                path: [
                    'name'
                ],
                body: [
                    'policy'
                ],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            }
        };
    }
    async deleteAutoscalingPolicy(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['autoscaling.delete_autoscaling_policy'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'autoscaling.delete_autoscaling_policy',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getAutoscalingCapacity(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['autoscaling.get_autoscaling_capacity'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_autoscaling/capacity';
        const meta = {
            name: 'autoscaling.get_autoscaling_capacity',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getAutoscalingPolicy(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['autoscaling.get_autoscaling_policy'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'autoscaling.get_autoscaling_policy',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAutoscalingPolicy(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['autoscaling.put_autoscaling_policy'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'autoscaling.put_autoscaling_policy',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'policy',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Autoscaling; //# sourceMappingURL=autoscaling.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/bulk.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = BulkApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    bulk: {
        path: [
            'index'
        ],
        body: [
            'operations'
        ],
        query: [
            'include_source_on_error',
            'list_executed_pipelines',
            'pipeline',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'timeout',
            'wait_for_active_shards',
            'require_alias',
            'require_data_stream'
        ]
    }
};
async function BulkApi(params, options) {
    var _a;
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.bulk;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;
    for(const key in params){
        if (acceptedBody.includes(key)) {
            // @ts-expect-error
            body = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = 'POST';
        path = `/${encodeURIComponent(params.index.toString())}/_bulk`;
    } else {
        method = 'POST';
        path = '/_bulk';
    }
    const meta = {
        name: 'bulk',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'operations',
            'include_source_on_error',
            'list_executed_pipelines',
            'pipeline',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'timeout',
            'wait_for_active_shards',
            'require_alias',
            'require_data_stream'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        bulkBody: body,
        meta
    }, options);
} //# sourceMappingURL=bulk.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/capabilities.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CapabilitiesApi;
const acceptedParams = {
    capabilities: {
        path: [],
        body: [],
        query: []
    }
};
async function CapabilitiesApi(params, options) {
    const { path: acceptedPath } = acceptedParams.capabilities;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            querystring[key] = params[key];
        }
    }
    const method = 'GET';
    const path = '/_capabilities';
    const meta = {
        name: 'capabilities',
        acceptedParams: []
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=capabilities.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/cat.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Cat {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'cat.aliases': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'h',
                    's',
                    'expand_wildcards',
                    'master_timeout'
                ]
            },
            'cat.allocation': {
                path: [
                    'node_id'
                ],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.component_templates': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.count': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'h',
                    'project_routing',
                    's'
                ]
            },
            'cat.fielddata': {
                path: [
                    'fields'
                ],
                body: [],
                query: [
                    'fields',
                    'h',
                    's'
                ]
            },
            'cat.health': {
                path: [],
                body: [],
                query: [
                    'ts',
                    'h',
                    's'
                ]
            },
            'cat.help': {
                path: [],
                body: [],
                query: []
            },
            'cat.indices': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'expand_wildcards',
                    'health',
                    'include_unloaded_segments',
                    'pri',
                    'master_timeout',
                    'h',
                    's'
                ]
            },
            'cat.master': {
                path: [],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.ml_data_frame_analytics': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'allow_no_match',
                    'h',
                    's'
                ]
            },
            'cat.ml_datafeeds': {
                path: [
                    'datafeed_id'
                ],
                body: [],
                query: [
                    'allow_no_match',
                    'h',
                    's'
                ]
            },
            'cat.ml_jobs': {
                path: [
                    'job_id'
                ],
                body: [],
                query: [
                    'allow_no_match',
                    'h',
                    's'
                ]
            },
            'cat.ml_trained_models': {
                path: [
                    'model_id'
                ],
                body: [],
                query: [
                    'allow_no_match',
                    'h',
                    's',
                    'from',
                    'size'
                ]
            },
            'cat.nodeattrs': {
                path: [],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.nodes': {
                path: [],
                body: [],
                query: [
                    'full_id',
                    'include_unloaded_segments',
                    'h',
                    's',
                    'master_timeout'
                ]
            },
            'cat.pending_tasks': {
                path: [],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.plugins': {
                path: [],
                body: [],
                query: [
                    'h',
                    's',
                    'include_bootstrap',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.recovery': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'active_only',
                    'detailed',
                    'index',
                    'h',
                    's'
                ]
            },
            'cat.repositories': {
                path: [],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.segments': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.shards': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'h',
                    's',
                    'master_timeout'
                ]
            },
            'cat.snapshots': {
                path: [
                    'repository'
                ],
                body: [],
                query: [
                    'ignore_unavailable',
                    'h',
                    's',
                    'master_timeout'
                ]
            },
            'cat.tasks': {
                path: [],
                body: [],
                query: [
                    'actions',
                    'detailed',
                    'nodes',
                    'parent_task_id',
                    'h',
                    's',
                    'timeout',
                    'wait_for_completion'
                ]
            },
            'cat.templates': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.thread_pool': {
                path: [
                    'thread_pool_patterns'
                ],
                body: [],
                query: [
                    'h',
                    's',
                    'local',
                    'master_timeout'
                ]
            },
            'cat.transforms': {
                path: [
                    'transform_id'
                ],
                body: [],
                query: [
                    'allow_no_match',
                    'from',
                    'h',
                    's',
                    'size'
                ]
            }
        };
    }
    async aliases(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.aliases'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_cat/aliases/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/aliases';
        }
        const meta = {
            name: 'cat.aliases',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'h',
                's',
                'expand_wildcards',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async allocation(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.allocation'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null) {
            method = 'GET';
            path = `/_cat/allocation/${encodeURIComponent(params.node_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/allocation';
        }
        const meta = {
            name: 'cat.allocation',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id',
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async componentTemplates(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.component_templates'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_cat/component_templates/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/component_templates';
        }
        const meta = {
            name: 'cat.component_templates',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async count(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.count'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'GET';
            path = `/_cat/count/${encodeURIComponent(params.index.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/count';
        }
        const meta = {
            name: 'cat.count',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'h',
                'project_routing',
                's'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async fielddata(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.fielddata'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.fields != null) {
            method = 'GET';
            path = `/_cat/fielddata/${encodeURIComponent(params.fields.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/fielddata';
        }
        const meta = {
            name: 'cat.fielddata',
            pathParts: {
                fields: params.fields
            },
            acceptedParams: [
                'fields',
                'fields',
                'h',
                's'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async health(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.health'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat/health';
        const meta = {
            name: 'cat.health',
            acceptedParams: [
                'ts',
                'h',
                's'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async help(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.help'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat';
        const meta = {
            name: 'cat.help',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async indices(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.indices'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'GET';
            path = `/_cat/indices/${encodeURIComponent(params.index.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/indices';
        }
        const meta = {
            name: 'cat.indices',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'expand_wildcards',
                'health',
                'include_unloaded_segments',
                'pri',
                'master_timeout',
                'h',
                's'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async master(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.master'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat/master';
        const meta = {
            name: 'cat.master',
            acceptedParams: [
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async mlDataFrameAnalytics(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.ml_data_frame_analytics'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = 'GET';
            path = `/_cat/ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/ml/data_frame/analytics';
        }
        const meta = {
            name: 'cat.ml_data_frame_analytics',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'allow_no_match',
                'h',
                's'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async mlDatafeeds(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.ml_datafeeds'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.datafeed_id != null) {
            method = 'GET';
            path = `/_cat/ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/ml/datafeeds';
        }
        const meta = {
            name: 'cat.ml_datafeeds',
            pathParts: {
                datafeed_id: params.datafeed_id
            },
            acceptedParams: [
                'datafeed_id',
                'allow_no_match',
                'h',
                's'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async mlJobs(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.ml_jobs'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.job_id != null) {
            method = 'GET';
            path = `/_cat/ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/ml/anomaly_detectors';
        }
        const meta = {
            name: 'cat.ml_jobs',
            pathParts: {
                job_id: params.job_id
            },
            acceptedParams: [
                'job_id',
                'allow_no_match',
                'h',
                's'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async mlTrainedModels(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.ml_trained_models'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.model_id != null) {
            method = 'GET';
            path = `/_cat/ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/ml/trained_models';
        }
        const meta = {
            name: 'cat.ml_trained_models',
            pathParts: {
                model_id: params.model_id
            },
            acceptedParams: [
                'model_id',
                'allow_no_match',
                'h',
                's',
                'from',
                'size'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async nodeattrs(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.nodeattrs'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat/nodeattrs';
        const meta = {
            name: 'cat.nodeattrs',
            acceptedParams: [
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async nodes(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.nodes'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat/nodes';
        const meta = {
            name: 'cat.nodes',
            acceptedParams: [
                'full_id',
                'include_unloaded_segments',
                'h',
                's',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async pendingTasks(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.pending_tasks'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat/pending_tasks';
        const meta = {
            name: 'cat.pending_tasks',
            acceptedParams: [
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async plugins(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.plugins'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat/plugins';
        const meta = {
            name: 'cat.plugins',
            acceptedParams: [
                'h',
                's',
                'include_bootstrap',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async recovery(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.recovery'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'GET';
            path = `/_cat/recovery/${encodeURIComponent(params.index.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/recovery';
        }
        const meta = {
            name: 'cat.recovery',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'active_only',
                'detailed',
                'index',
                'h',
                's'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async repositories(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.repositories'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat/repositories';
        const meta = {
            name: 'cat.repositories',
            acceptedParams: [
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async segments(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.segments'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'GET';
            path = `/_cat/segments/${encodeURIComponent(params.index.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/segments';
        }
        const meta = {
            name: 'cat.segments',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async shards(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.shards'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'GET';
            path = `/_cat/shards/${encodeURIComponent(params.index.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/shards';
        }
        const meta = {
            name: 'cat.shards',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'h',
                's',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async snapshots(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.snapshots'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.repository != null) {
            method = 'GET';
            path = `/_cat/snapshots/${encodeURIComponent(params.repository.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/snapshots';
        }
        const meta = {
            name: 'cat.snapshots',
            pathParts: {
                repository: params.repository
            },
            acceptedParams: [
                'repository',
                'ignore_unavailable',
                'h',
                's',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async tasks(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.tasks'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cat/tasks';
        const meta = {
            name: 'cat.tasks',
            acceptedParams: [
                'actions',
                'detailed',
                'nodes',
                'parent_task_id',
                'h',
                's',
                'timeout',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async templates(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.templates'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_cat/templates/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/templates';
        }
        const meta = {
            name: 'cat.templates',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async threadPool(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.thread_pool'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.thread_pool_patterns != null) {
            method = 'GET';
            path = `/_cat/thread_pool/${encodeURIComponent(params.thread_pool_patterns.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/thread_pool';
        }
        const meta = {
            name: 'cat.thread_pool',
            pathParts: {
                thread_pool_patterns: params.thread_pool_patterns
            },
            acceptedParams: [
                'thread_pool_patterns',
                'h',
                's',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async transforms(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cat.transforms'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.transform_id != null) {
            method = 'GET';
            path = `/_cat/transforms/${encodeURIComponent(params.transform_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_cat/transforms';
        }
        const meta = {
            name: 'cat.transforms',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'allow_no_match',
                'from',
                'h',
                's',
                'size'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Cat; //# sourceMappingURL=cat.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/ccr.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Ccr {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'ccr.delete_auto_follow_pattern': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'ccr.follow': {
                path: [
                    'index'
                ],
                body: [
                    'data_stream_name',
                    'leader_index',
                    'max_outstanding_read_requests',
                    'max_outstanding_write_requests',
                    'max_read_request_operation_count',
                    'max_read_request_size',
                    'max_retry_delay',
                    'max_write_buffer_count',
                    'max_write_buffer_size',
                    'max_write_request_operation_count',
                    'max_write_request_size',
                    'read_poll_timeout',
                    'remote_cluster',
                    'settings'
                ],
                query: [
                    'master_timeout',
                    'wait_for_active_shards'
                ]
            },
            'ccr.follow_info': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'ccr.follow_stats': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'timeout'
                ]
            },
            'ccr.forget_follower': {
                path: [
                    'index'
                ],
                body: [
                    'follower_cluster',
                    'follower_index',
                    'follower_index_uuid',
                    'leader_remote_cluster'
                ],
                query: [
                    'timeout'
                ]
            },
            'ccr.get_auto_follow_pattern': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'ccr.pause_auto_follow_pattern': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'ccr.pause_follow': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'ccr.put_auto_follow_pattern': {
                path: [
                    'name'
                ],
                body: [
                    'remote_cluster',
                    'follow_index_pattern',
                    'leader_index_patterns',
                    'leader_index_exclusion_patterns',
                    'max_outstanding_read_requests',
                    'settings',
                    'max_outstanding_write_requests',
                    'read_poll_timeout',
                    'max_read_request_operation_count',
                    'max_read_request_size',
                    'max_retry_delay',
                    'max_write_buffer_count',
                    'max_write_buffer_size',
                    'max_write_request_operation_count',
                    'max_write_request_size'
                ],
                query: [
                    'master_timeout'
                ]
            },
            'ccr.resume_auto_follow_pattern': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'ccr.resume_follow': {
                path: [
                    'index'
                ],
                body: [
                    'max_outstanding_read_requests',
                    'max_outstanding_write_requests',
                    'max_read_request_operation_count',
                    'max_read_request_size',
                    'max_retry_delay',
                    'max_write_buffer_count',
                    'max_write_buffer_size',
                    'max_write_request_operation_count',
                    'max_write_request_size',
                    'read_poll_timeout'
                ],
                query: [
                    'master_timeout'
                ]
            },
            'ccr.stats': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ccr.unfollow': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            }
        };
    }
    async deleteAutoFollowPattern(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.delete_auto_follow_pattern'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'ccr.delete_auto_follow_pattern',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async follow(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ccr.follow'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/follow`;
        const meta = {
            name: 'ccr.follow',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'data_stream_name',
                'leader_index',
                'max_outstanding_read_requests',
                'max_outstanding_write_requests',
                'max_read_request_operation_count',
                'max_read_request_size',
                'max_retry_delay',
                'max_write_buffer_count',
                'max_write_buffer_size',
                'max_write_request_operation_count',
                'max_write_request_size',
                'read_poll_timeout',
                'remote_cluster',
                'settings',
                'master_timeout',
                'wait_for_active_shards'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async followInfo(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.follow_info'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/info`;
        const meta = {
            name: 'ccr.follow_info',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async followStats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.follow_stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/stats`;
        const meta = {
            name: 'ccr.follow_stats',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async forgetFollower(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ccr.forget_follower'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/forget_follower`;
        const meta = {
            name: 'ccr.forget_follower',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'follower_cluster',
                'follower_index',
                'follower_index_uuid',
                'leader_remote_cluster',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getAutoFollowPattern(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.get_auto_follow_pattern'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_ccr/auto_follow';
        }
        const meta = {
            name: 'ccr.get_auto_follow_pattern',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async pauseAutoFollowPattern(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.pause_auto_follow_pattern'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}/pause`;
        const meta = {
            name: 'ccr.pause_auto_follow_pattern',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async pauseFollow(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.pause_follow'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/pause_follow`;
        const meta = {
            name: 'ccr.pause_follow',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAutoFollowPattern(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ccr.put_auto_follow_pattern'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'ccr.put_auto_follow_pattern',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'remote_cluster',
                'follow_index_pattern',
                'leader_index_patterns',
                'leader_index_exclusion_patterns',
                'max_outstanding_read_requests',
                'settings',
                'max_outstanding_write_requests',
                'read_poll_timeout',
                'max_read_request_operation_count',
                'max_read_request_size',
                'max_retry_delay',
                'max_write_buffer_count',
                'max_write_buffer_size',
                'max_write_request_operation_count',
                'max_write_request_size',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async resumeAutoFollowPattern(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.resume_auto_follow_pattern'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}/resume`;
        const meta = {
            name: 'ccr.resume_auto_follow_pattern',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async resumeFollow(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ccr.resume_follow'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/resume_follow`;
        const meta = {
            name: 'ccr.resume_follow',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'max_outstanding_read_requests',
                'max_outstanding_write_requests',
                'max_read_request_operation_count',
                'max_read_request_size',
                'max_retry_delay',
                'max_write_buffer_count',
                'max_write_buffer_size',
                'max_write_request_operation_count',
                'max_write_request_size',
                'read_poll_timeout',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_ccr/stats';
        const meta = {
            name: 'ccr.stats',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async unfollow(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ccr.unfollow'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/unfollow`;
        const meta = {
            name: 'ccr.unfollow',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Ccr; //# sourceMappingURL=ccr.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/clear_scroll.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ClearScrollApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    clear_scroll: {
        path: [],
        body: [
            'scroll_id'
        ],
        query: []
    }
};
async function ClearScrollApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.clear_scroll;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = 'DELETE';
    const path = '/_search/scroll';
    const meta = {
        name: 'clear_scroll',
        pathParts: {
            scroll_id: params.scroll_id
        },
        acceptedParams: [
            'scroll_id',
            'scroll_id'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=clear_scroll.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/close_point_in_time.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ClosePointInTimeApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    close_point_in_time: {
        path: [],
        body: [
            'id'
        ],
        query: []
    }
};
async function ClosePointInTimeApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.close_point_in_time;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = 'DELETE';
    const path = '/_pit';
    const meta = {
        name: 'close_point_in_time',
        acceptedParams: [
            'id'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=close_point_in_time.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/cluster.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Cluster {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'cluster.allocation_explain': {
                path: [],
                body: [
                    'index',
                    'shard',
                    'primary',
                    'current_node'
                ],
                query: [
                    'index',
                    'shard',
                    'primary',
                    'current_node',
                    'include_disk_info',
                    'include_yes_decisions',
                    'master_timeout'
                ]
            },
            'cluster.delete_component_template': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'cluster.delete_voting_config_exclusions': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'wait_for_removal'
                ]
            },
            'cluster.exists_component_template': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'local'
                ]
            },
            'cluster.get_component_template': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'flat_settings',
                    'settings_filter',
                    'include_defaults',
                    'local',
                    'master_timeout'
                ]
            },
            'cluster.get_settings': {
                path: [],
                body: [],
                query: [
                    'flat_settings',
                    'include_defaults',
                    'master_timeout',
                    'timeout'
                ]
            },
            'cluster.health': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'expand_wildcards',
                    'level',
                    'local',
                    'master_timeout',
                    'timeout',
                    'wait_for_active_shards',
                    'wait_for_events',
                    'wait_for_nodes',
                    'wait_for_no_initializing_shards',
                    'wait_for_no_relocating_shards',
                    'wait_for_status'
                ]
            },
            'cluster.info': {
                path: [
                    'target'
                ],
                body: [],
                query: []
            },
            'cluster.pending_tasks': {
                path: [],
                body: [],
                query: [
                    'local',
                    'master_timeout'
                ]
            },
            'cluster.post_voting_config_exclusions': {
                path: [],
                body: [],
                query: [
                    'node_names',
                    'node_ids',
                    'master_timeout',
                    'timeout'
                ]
            },
            'cluster.put_component_template': {
                path: [
                    'name'
                ],
                body: [
                    'template',
                    'version',
                    '_meta',
                    'deprecated'
                ],
                query: [
                    'create',
                    'cause',
                    'master_timeout'
                ]
            },
            'cluster.put_settings': {
                path: [],
                body: [
                    'persistent',
                    'transient'
                ],
                query: [
                    'flat_settings',
                    'master_timeout',
                    'timeout'
                ]
            },
            'cluster.remote_info': {
                path: [],
                body: [],
                query: []
            },
            'cluster.reroute': {
                path: [],
                body: [
                    'commands'
                ],
                query: [
                    'dry_run',
                    'explain',
                    'metric',
                    'retry_failed',
                    'master_timeout',
                    'timeout'
                ]
            },
            'cluster.state': {
                path: [
                    'metric',
                    'index'
                ],
                body: [],
                query: [
                    'allow_no_indices',
                    'expand_wildcards',
                    'flat_settings',
                    'ignore_unavailable',
                    'local',
                    'master_timeout',
                    'wait_for_metadata_version',
                    'wait_for_timeout'
                ]
            },
            'cluster.stats': {
                path: [
                    'node_id'
                ],
                body: [],
                query: [
                    'include_remotes',
                    'timeout'
                ]
            }
        };
    }
    async allocationExplain(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['cluster.allocation_explain'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = '/_cluster/allocation/explain';
        const meta = {
            name: 'cluster.allocation_explain',
            acceptedParams: [
                'index',
                'shard',
                'primary',
                'current_node',
                'index',
                'shard',
                'primary',
                'current_node',
                'include_disk_info',
                'include_yes_decisions',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteComponentTemplate(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.delete_component_template'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'cluster.delete_component_template',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteVotingConfigExclusions(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.delete_voting_config_exclusions'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = '/_cluster/voting_config_exclusions';
        const meta = {
            name: 'cluster.delete_voting_config_exclusions',
            acceptedParams: [
                'master_timeout',
                'wait_for_removal'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async existsComponentTemplate(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.exists_component_template'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'HEAD';
        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'cluster.exists_component_template',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout',
                'local'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getComponentTemplate(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.get_component_template'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_component_template/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_component_template';
        }
        const meta = {
            name: 'cluster.get_component_template',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'flat_settings',
                'settings_filter',
                'include_defaults',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getSettings(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.get_settings'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cluster/settings';
        const meta = {
            name: 'cluster.get_settings',
            acceptedParams: [
                'flat_settings',
                'include_defaults',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async health(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.health'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'GET';
            path = `/_cluster/health/${encodeURIComponent(params.index.toString())}`;
        } else {
            method = 'GET';
            path = '/_cluster/health';
        }
        const meta = {
            name: 'cluster.health',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'expand_wildcards',
                'level',
                'local',
                'master_timeout',
                'timeout',
                'wait_for_active_shards',
                'wait_for_events',
                'wait_for_nodes',
                'wait_for_no_initializing_shards',
                'wait_for_no_relocating_shards',
                'wait_for_status'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async info(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.info'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_info/${encodeURIComponent(params.target.toString())}`;
        const meta = {
            name: 'cluster.info',
            pathParts: {
                target: params.target
            },
            acceptedParams: [
                'target'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async pendingTasks(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.pending_tasks'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_cluster/pending_tasks';
        const meta = {
            name: 'cluster.pending_tasks',
            acceptedParams: [
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async postVotingConfigExclusions(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.post_voting_config_exclusions'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_cluster/voting_config_exclusions';
        const meta = {
            name: 'cluster.post_voting_config_exclusions',
            acceptedParams: [
                'node_names',
                'node_ids',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putComponentTemplate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['cluster.put_component_template'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'cluster.put_component_template',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'template',
                'version',
                '_meta',
                'deprecated',
                'create',
                'cause',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putSettings(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['cluster.put_settings'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = '/_cluster/settings';
        const meta = {
            name: 'cluster.put_settings',
            acceptedParams: [
                'persistent',
                'transient',
                'flat_settings',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async remoteInfo(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.remote_info'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_remote/info';
        const meta = {
            name: 'cluster.remote_info',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async reroute(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['cluster.reroute'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_cluster/reroute';
        const meta = {
            name: 'cluster.reroute',
            acceptedParams: [
                'commands',
                'dry_run',
                'explain',
                'metric',
                'retry_failed',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async state(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.state'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.metric != null && params.index != null) {
            method = 'GET';
            path = `/_cluster/state/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index.toString())}`;
        } else if (params.metric != null) {
            method = 'GET';
            path = `/_cluster/state/${encodeURIComponent(params.metric.toString())}`;
        } else {
            method = 'GET';
            path = '/_cluster/state';
        }
        const meta = {
            name: 'cluster.state',
            pathParts: {
                metric: params.metric,
                index: params.index
            },
            acceptedParams: [
                'metric',
                'index',
                'allow_no_indices',
                'expand_wildcards',
                'flat_settings',
                'ignore_unavailable',
                'local',
                'master_timeout',
                'wait_for_metadata_version',
                'wait_for_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['cluster.stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null) {
            method = 'GET';
            path = `/_cluster/stats/nodes/${encodeURIComponent(params.node_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_cluster/stats';
        }
        const meta = {
            name: 'cluster.stats',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id',
                'include_remotes',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Cluster; //# sourceMappingURL=cluster.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/connector.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Connector {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'connector.check_in': {
                path: [
                    'connector_id'
                ],
                body: [],
                query: []
            },
            'connector.delete': {
                path: [
                    'connector_id'
                ],
                body: [],
                query: [
                    'delete_sync_jobs',
                    'hard'
                ]
            },
            'connector.get': {
                path: [
                    'connector_id'
                ],
                body: [],
                query: [
                    'include_deleted'
                ]
            },
            'connector.last_sync': {
                path: [
                    'connector_id'
                ],
                body: [
                    'last_access_control_sync_error',
                    'last_access_control_sync_scheduled_at',
                    'last_access_control_sync_status',
                    'last_deleted_document_count',
                    'last_incremental_sync_scheduled_at',
                    'last_indexed_document_count',
                    'last_seen',
                    'last_sync_error',
                    'last_sync_scheduled_at',
                    'last_sync_status',
                    'last_synced',
                    'sync_cursor'
                ],
                query: []
            },
            'connector.list': {
                path: [],
                body: [],
                query: [
                    'from',
                    'size',
                    'index_name',
                    'connector_name',
                    'service_type',
                    'include_deleted',
                    'query'
                ]
            },
            'connector.post': {
                path: [],
                body: [
                    'description',
                    'index_name',
                    'is_native',
                    'language',
                    'name',
                    'service_type'
                ],
                query: []
            },
            'connector.put': {
                path: [
                    'connector_id'
                ],
                body: [
                    'description',
                    'index_name',
                    'is_native',
                    'language',
                    'name',
                    'service_type'
                ],
                query: []
            },
            'connector.secret_delete': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'connector.secret_get': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'connector.secret_post': {
                path: [],
                body: [],
                query: []
            },
            'connector.secret_put': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'connector.sync_job_cancel': {
                path: [
                    'connector_sync_job_id'
                ],
                body: [],
                query: []
            },
            'connector.sync_job_check_in': {
                path: [
                    'connector_sync_job_id'
                ],
                body: [],
                query: []
            },
            'connector.sync_job_claim': {
                path: [
                    'connector_sync_job_id'
                ],
                body: [
                    'sync_cursor',
                    'worker_hostname'
                ],
                query: []
            },
            'connector.sync_job_delete': {
                path: [
                    'connector_sync_job_id'
                ],
                body: [],
                query: []
            },
            'connector.sync_job_error': {
                path: [
                    'connector_sync_job_id'
                ],
                body: [
                    'error'
                ],
                query: []
            },
            'connector.sync_job_get': {
                path: [
                    'connector_sync_job_id'
                ],
                body: [],
                query: []
            },
            'connector.sync_job_list': {
                path: [],
                body: [],
                query: [
                    'from',
                    'size',
                    'status',
                    'connector_id',
                    'job_type'
                ]
            },
            'connector.sync_job_post': {
                path: [],
                body: [
                    'id',
                    'job_type',
                    'trigger_method'
                ],
                query: []
            },
            'connector.sync_job_update_stats': {
                path: [
                    'connector_sync_job_id'
                ],
                body: [
                    'deleted_document_count',
                    'indexed_document_count',
                    'indexed_document_volume',
                    'last_seen',
                    'metadata',
                    'total_document_count'
                ],
                query: []
            },
            'connector.update_active_filtering': {
                path: [
                    'connector_id'
                ],
                body: [],
                query: []
            },
            'connector.update_api_key_id': {
                path: [
                    'connector_id'
                ],
                body: [
                    'api_key_id',
                    'api_key_secret_id'
                ],
                query: []
            },
            'connector.update_configuration': {
                path: [
                    'connector_id'
                ],
                body: [
                    'configuration',
                    'values'
                ],
                query: []
            },
            'connector.update_error': {
                path: [
                    'connector_id'
                ],
                body: [
                    'error'
                ],
                query: []
            },
            'connector.update_features': {
                path: [
                    'connector_id'
                ],
                body: [
                    'features'
                ],
                query: []
            },
            'connector.update_filtering': {
                path: [
                    'connector_id'
                ],
                body: [
                    'filtering',
                    'rules',
                    'advanced_snippet'
                ],
                query: []
            },
            'connector.update_filtering_validation': {
                path: [
                    'connector_id'
                ],
                body: [
                    'validation'
                ],
                query: []
            },
            'connector.update_index_name': {
                path: [
                    'connector_id'
                ],
                body: [
                    'index_name'
                ],
                query: []
            },
            'connector.update_name': {
                path: [
                    'connector_id'
                ],
                body: [
                    'name',
                    'description'
                ],
                query: []
            },
            'connector.update_native': {
                path: [
                    'connector_id'
                ],
                body: [
                    'is_native'
                ],
                query: []
            },
            'connector.update_pipeline': {
                path: [
                    'connector_id'
                ],
                body: [
                    'pipeline'
                ],
                query: []
            },
            'connector.update_scheduling': {
                path: [
                    'connector_id'
                ],
                body: [
                    'scheduling'
                ],
                query: []
            },
            'connector.update_service_type': {
                path: [
                    'connector_id'
                ],
                body: [
                    'service_type'
                ],
                query: []
            },
            'connector.update_status': {
                path: [
                    'connector_id'
                ],
                body: [
                    'status'
                ],
                query: []
            }
        };
    }
    async checkIn(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.check_in'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_check_in`;
        const meta = {
            name: 'connector.check_in',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async delete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;
        const meta = {
            name: 'connector.delete',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'delete_sync_jobs',
                'hard'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async get(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;
        const meta = {
            name: 'connector.get',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'include_deleted'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async lastSync(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.last_sync'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_last_sync`;
        const meta = {
            name: 'connector.last_sync',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'last_access_control_sync_error',
                'last_access_control_sync_scheduled_at',
                'last_access_control_sync_status',
                'last_deleted_document_count',
                'last_incremental_sync_scheduled_at',
                'last_indexed_document_count',
                'last_seen',
                'last_sync_error',
                'last_sync_scheduled_at',
                'last_sync_status',
                'last_synced',
                'sync_cursor'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async list(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.list'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_connector';
        const meta = {
            name: 'connector.list',
            acceptedParams: [
                'from',
                'size',
                'index_name',
                'connector_name',
                'service_type',
                'include_deleted',
                'query'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async post(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.post'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_connector';
        const meta = {
            name: 'connector.post',
            acceptedParams: [
                'description',
                'index_name',
                'is_native',
                'language',
                'name',
                'service_type'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async put(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.put'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.connector_id != null) {
            method = 'PUT';
            path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;
        } else {
            method = 'PUT';
            path = '/_connector';
        }
        const meta = {
            name: 'connector.put',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'description',
                'index_name',
                'is_native',
                'language',
                'name',
                'service_type'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async secretDelete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.secret_delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'connector.secret_delete',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async secretGet(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.secret_get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'connector.secret_get',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async secretPost(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.secret_post'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_connector/_secret';
        const meta = {
            name: 'connector.secret_post',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async secretPut(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.secret_put'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'connector.secret_put',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobCancel(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.sync_job_cancel'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_cancel`;
        const meta = {
            name: 'connector.sync_job_cancel',
            pathParts: {
                connector_sync_job_id: params.connector_sync_job_id
            },
            acceptedParams: [
                'connector_sync_job_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobCheckIn(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.sync_job_check_in'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_check_in`;
        const meta = {
            name: 'connector.sync_job_check_in',
            pathParts: {
                connector_sync_job_id: params.connector_sync_job_id
            },
            acceptedParams: [
                'connector_sync_job_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobClaim(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.sync_job_claim'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_claim`;
        const meta = {
            name: 'connector.sync_job_claim',
            pathParts: {
                connector_sync_job_id: params.connector_sync_job_id
            },
            acceptedParams: [
                'connector_sync_job_id',
                'sync_cursor',
                'worker_hostname'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobDelete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.sync_job_delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}`;
        const meta = {
            name: 'connector.sync_job_delete',
            pathParts: {
                connector_sync_job_id: params.connector_sync_job_id
            },
            acceptedParams: [
                'connector_sync_job_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobError(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.sync_job_error'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_error`;
        const meta = {
            name: 'connector.sync_job_error',
            pathParts: {
                connector_sync_job_id: params.connector_sync_job_id
            },
            acceptedParams: [
                'connector_sync_job_id',
                'error'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobGet(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.sync_job_get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}`;
        const meta = {
            name: 'connector.sync_job_get',
            pathParts: {
                connector_sync_job_id: params.connector_sync_job_id
            },
            acceptedParams: [
                'connector_sync_job_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobList(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.sync_job_list'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_connector/_sync_job';
        const meta = {
            name: 'connector.sync_job_list',
            acceptedParams: [
                'from',
                'size',
                'status',
                'connector_id',
                'job_type'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobPost(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.sync_job_post'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_connector/_sync_job';
        const meta = {
            name: 'connector.sync_job_post',
            acceptedParams: [
                'id',
                'job_type',
                'trigger_method'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async syncJobUpdateStats(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.sync_job_update_stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_stats`;
        const meta = {
            name: 'connector.sync_job_update_stats',
            pathParts: {
                connector_sync_job_id: params.connector_sync_job_id
            },
            acceptedParams: [
                'connector_sync_job_id',
                'deleted_document_count',
                'indexed_document_count',
                'indexed_document_volume',
                'last_seen',
                'metadata',
                'total_document_count'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateActiveFiltering(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['connector.update_active_filtering'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering/_activate`;
        const meta = {
            name: 'connector.update_active_filtering',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateApiKeyId(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_api_key_id'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_api_key_id`;
        const meta = {
            name: 'connector.update_api_key_id',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'api_key_id',
                'api_key_secret_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateConfiguration(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_configuration'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_configuration`;
        const meta = {
            name: 'connector.update_configuration',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'configuration',
                'values'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateError(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_error'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_error`;
        const meta = {
            name: 'connector.update_error',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'error'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateFeatures(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_features'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_features`;
        const meta = {
            name: 'connector.update_features',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'features'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateFiltering(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_filtering'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering`;
        const meta = {
            name: 'connector.update_filtering',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'filtering',
                'rules',
                'advanced_snippet'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateFilteringValidation(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_filtering_validation'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering/_validation`;
        const meta = {
            name: 'connector.update_filtering_validation',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'validation'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateIndexName(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_index_name'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_index_name`;
        const meta = {
            name: 'connector.update_index_name',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'index_name'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateName(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_name'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_name`;
        const meta = {
            name: 'connector.update_name',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'name',
                'description'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateNative(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_native'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_native`;
        const meta = {
            name: 'connector.update_native',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'is_native'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updatePipeline(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_pipeline'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_pipeline`;
        const meta = {
            name: 'connector.update_pipeline',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'pipeline'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateScheduling(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_scheduling'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_scheduling`;
        const meta = {
            name: 'connector.update_scheduling',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'scheduling'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateServiceType(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_service_type'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_service_type`;
        const meta = {
            name: 'connector.update_service_type',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'service_type'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateStatus(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['connector.update_status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_status`;
        const meta = {
            name: 'connector.update_status',
            pathParts: {
                connector_id: params.connector_id
            },
            acceptedParams: [
                'connector_id',
                'status'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Connector; //# sourceMappingURL=connector.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/count.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CountApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    count: {
        path: [
            'index'
        ],
        body: [
            'query'
        ],
        query: [
            'allow_no_indices',
            'analyzer',
            'analyze_wildcard',
            'default_operator',
            'df',
            'expand_wildcards',
            'ignore_throttled',
            'ignore_unavailable',
            'lenient',
            'min_score',
            'preference',
            'project_routing',
            'routing',
            'terminate_after',
            'q'
        ]
    }
};
async function CountApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.count;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_count`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_count';
    }
    const meta = {
        name: 'count',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'query',
            'allow_no_indices',
            'analyzer',
            'analyze_wildcard',
            'default_operator',
            'df',
            'expand_wildcards',
            'ignore_throttled',
            'ignore_unavailable',
            'lenient',
            'min_score',
            'preference',
            'project_routing',
            'routing',
            'terminate_after',
            'q'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=count.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/create.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CreateApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    create: {
        path: [
            'id',
            'index'
        ],
        body: [
            'document'
        ],
        query: [
            'include_source_on_error',
            'pipeline',
            'refresh',
            'require_alias',
            'require_data_stream',
            'routing',
            'timeout',
            'version',
            'version_type',
            'wait_for_active_shards'
        ]
    }
};
async function CreateApi(params, options) {
    var _a;
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.create;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;
    for(const key in params){
        if (acceptedBody.includes(key)) {
            // @ts-expect-error
            body = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = 'PUT';
    const path = `/${encodeURIComponent(params.index.toString())}/_create/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'create',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'document',
            'include_source_on_error',
            'pipeline',
            'refresh',
            'require_alias',
            'require_data_stream',
            'routing',
            'timeout',
            'version',
            'version_type',
            'wait_for_active_shards'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=create.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/dangling_indices.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class DanglingIndices {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'dangling_indices.delete_dangling_index': {
                path: [
                    'index_uuid'
                ],
                body: [],
                query: [
                    'accept_data_loss',
                    'master_timeout',
                    'timeout'
                ]
            },
            'dangling_indices.import_dangling_index': {
                path: [
                    'index_uuid'
                ],
                body: [],
                query: [
                    'accept_data_loss',
                    'master_timeout',
                    'timeout'
                ]
            },
            'dangling_indices.list_dangling_indices': {
                path: [],
                body: [],
                query: []
            }
        };
    }
    async deleteDanglingIndex(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['dangling_indices.delete_dangling_index'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_dangling/${encodeURIComponent(params.index_uuid.toString())}`;
        const meta = {
            name: 'dangling_indices.delete_dangling_index',
            pathParts: {
                index_uuid: params.index_uuid
            },
            acceptedParams: [
                'index_uuid',
                'accept_data_loss',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async importDanglingIndex(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['dangling_indices.import_dangling_index'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_dangling/${encodeURIComponent(params.index_uuid.toString())}`;
        const meta = {
            name: 'dangling_indices.import_dangling_index',
            pathParts: {
                index_uuid: params.index_uuid
            },
            acceptedParams: [
                'index_uuid',
                'accept_data_loss',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async listDanglingIndices(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['dangling_indices.list_dangling_indices'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_dangling';
        const meta = {
            name: 'dangling_indices.list_dangling_indices',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = DanglingIndices; //# sourceMappingURL=dangling_indices.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/delete.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = DeleteApi;
const acceptedParams = {
    delete: {
        path: [
            'id',
            'index'
        ],
        body: [],
        query: [
            'if_primary_term',
            'if_seq_no',
            'refresh',
            'routing',
            'timeout',
            'version',
            'version_type',
            'wait_for_active_shards'
        ]
    }
};
async function DeleteApi(params, options) {
    const { path: acceptedPath } = acceptedParams.delete;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'DELETE';
    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'delete',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'if_primary_term',
            'if_seq_no',
            'refresh',
            'routing',
            'timeout',
            'version',
            'version_type',
            'wait_for_active_shards'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=delete.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = DeleteByQueryApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    delete_by_query: {
        path: [
            'index'
        ],
        body: [
            'max_docs',
            'query',
            'slice',
            'sort'
        ],
        query: [
            'allow_no_indices',
            'analyzer',
            'analyze_wildcard',
            'conflicts',
            'default_operator',
            'df',
            'expand_wildcards',
            'from',
            'ignore_unavailable',
            'lenient',
            'max_docs',
            'preference',
            'refresh',
            'request_cache',
            'requests_per_second',
            'routing',
            'q',
            'scroll',
            'scroll_size',
            'search_timeout',
            'search_type',
            'slices',
            'sort',
            'stats',
            'terminate_after',
            'timeout',
            'version',
            'wait_for_active_shards',
            'wait_for_completion'
        ]
    }
};
async function DeleteByQueryApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.delete_by_query;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = 'POST';
    const path = `/${encodeURIComponent(params.index.toString())}/_delete_by_query`;
    const meta = {
        name: 'delete_by_query',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'max_docs',
            'query',
            'slice',
            'sort',
            'allow_no_indices',
            'analyzer',
            'analyze_wildcard',
            'conflicts',
            'default_operator',
            'df',
            'expand_wildcards',
            'from',
            'ignore_unavailable',
            'lenient',
            'max_docs',
            'preference',
            'refresh',
            'request_cache',
            'requests_per_second',
            'routing',
            'q',
            'scroll',
            'scroll_size',
            'search_timeout',
            'search_type',
            'slices',
            'sort',
            'stats',
            'terminate_after',
            'timeout',
            'version',
            'wait_for_active_shards',
            'wait_for_completion'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=delete_by_query.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query_rethrottle.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = DeleteByQueryRethrottleApi;
const acceptedParams = {
    delete_by_query_rethrottle: {
        path: [
            'task_id'
        ],
        body: [],
        query: [
            'requests_per_second'
        ]
    }
};
async function DeleteByQueryRethrottleApi(params, options) {
    const { path: acceptedPath } = acceptedParams.delete_by_query_rethrottle;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'POST';
    const path = `/_delete_by_query/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;
    const meta = {
        name: 'delete_by_query_rethrottle',
        pathParts: {
            task_id: params.task_id
        },
        acceptedParams: [
            'task_id',
            'requests_per_second'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=delete_by_query_rethrottle.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/delete_script.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = DeleteScriptApi;
const acceptedParams = {
    delete_script: {
        path: [
            'id'
        ],
        body: [],
        query: [
            'master_timeout',
            'timeout'
        ]
    }
};
async function DeleteScriptApi(params, options) {
    const { path: acceptedPath } = acceptedParams.delete_script;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'DELETE';
    const path = `/_scripts/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'delete_script',
        pathParts: {
            id: params.id
        },
        acceptedParams: [
            'id',
            'master_timeout',
            'timeout'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=delete_script.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/enrich.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Enrich {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'enrich.delete_policy': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'enrich.execute_policy': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'wait_for_completion'
                ]
            },
            'enrich.get_policy': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'enrich.put_policy': {
                path: [
                    'name'
                ],
                body: [
                    'geo_match',
                    'match',
                    'range'
                ],
                query: [
                    'master_timeout'
                ]
            },
            'enrich.stats': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            }
        };
    }
    async deletePolicy(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['enrich.delete_policy'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'enrich.delete_policy',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async executePolicy(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['enrich.execute_policy'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}/_execute`;
        const meta = {
            name: 'enrich.execute_policy',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getPolicy(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['enrich.get_policy'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_enrich/policy';
        }
        const meta = {
            name: 'enrich.get_policy',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putPolicy(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['enrich.put_policy'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'enrich.put_policy',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'geo_match',
                'match',
                'range',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['enrich.stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_enrich/_stats';
        const meta = {
            name: 'enrich.stats',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Enrich; //# sourceMappingURL=enrich.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/eql.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Eql {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'eql.delete': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'eql.get': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'keep_alive',
                    'wait_for_completion_timeout'
                ]
            },
            'eql.get_status': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'eql.search': {
                path: [
                    'index'
                ],
                body: [
                    'query',
                    'case_sensitive',
                    'event_category_field',
                    'tiebreaker_field',
                    'timestamp_field',
                    'fetch_size',
                    'filter',
                    'keep_alive',
                    'keep_on_completion',
                    'wait_for_completion_timeout',
                    'allow_partial_search_results',
                    'allow_partial_sequence_results',
                    'size',
                    'fields',
                    'result_position',
                    'runtime_mappings',
                    'max_samples_per_key'
                ],
                query: [
                    'allow_no_indices',
                    'allow_partial_search_results',
                    'allow_partial_sequence_results',
                    'expand_wildcards',
                    'ccs_minimize_roundtrips',
                    'ignore_unavailable',
                    'keep_alive',
                    'keep_on_completion',
                    'project_routing',
                    'wait_for_completion_timeout'
                ]
            }
        };
    }
    async delete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['eql.delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_eql/search/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'eql.delete',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async get(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['eql.get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_eql/search/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'eql.get',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'keep_alive',
                'wait_for_completion_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getStatus(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['eql.get_status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_eql/search/status/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'eql.get_status',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async search(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['eql.search'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_eql/search`;
        const meta = {
            name: 'eql.search',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'query',
                'case_sensitive',
                'event_category_field',
                'tiebreaker_field',
                'timestamp_field',
                'fetch_size',
                'filter',
                'keep_alive',
                'keep_on_completion',
                'wait_for_completion_timeout',
                'allow_partial_search_results',
                'allow_partial_sequence_results',
                'size',
                'fields',
                'result_position',
                'runtime_mappings',
                'max_samples_per_key',
                'allow_no_indices',
                'allow_partial_search_results',
                'allow_partial_sequence_results',
                'expand_wildcards',
                'ccs_minimize_roundtrips',
                'ignore_unavailable',
                'keep_alive',
                'keep_on_completion',
                'project_routing',
                'wait_for_completion_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Eql; //# sourceMappingURL=eql.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/esql.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Esql {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'esql.async_query': {
                path: [],
                body: [
                    'columnar',
                    'filter',
                    'locale',
                    'params',
                    'profile',
                    'query',
                    'tables',
                    'include_ccs_metadata',
                    'include_execution_metadata',
                    'wait_for_completion_timeout',
                    'keep_alive',
                    'keep_on_completion'
                ],
                query: [
                    'allow_partial_results',
                    'delimiter',
                    'drop_null_columns',
                    'format'
                ]
            },
            'esql.async_query_delete': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'esql.async_query_get': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'drop_null_columns',
                    'format',
                    'keep_alive',
                    'wait_for_completion_timeout'
                ]
            },
            'esql.async_query_stop': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'drop_null_columns'
                ]
            },
            'esql.get_query': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'esql.list_queries': {
                path: [],
                body: [],
                query: []
            },
            'esql.query': {
                path: [],
                body: [
                    'columnar',
                    'filter',
                    'locale',
                    'params',
                    'profile',
                    'query',
                    'tables',
                    'include_ccs_metadata',
                    'include_execution_metadata'
                ],
                query: [
                    'format',
                    'delimiter',
                    'drop_null_columns',
                    'allow_partial_results'
                ]
            }
        };
    }
    async asyncQuery(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['esql.async_query'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_query/async';
        const meta = {
            name: 'esql.async_query',
            acceptedParams: [
                'columnar',
                'filter',
                'locale',
                'params',
                'profile',
                'query',
                'tables',
                'include_ccs_metadata',
                'include_execution_metadata',
                'wait_for_completion_timeout',
                'keep_alive',
                'keep_on_completion',
                'allow_partial_results',
                'delimiter',
                'drop_null_columns',
                'format'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async asyncQueryDelete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['esql.async_query_delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_query/async/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'esql.async_query_delete',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async asyncQueryGet(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['esql.async_query_get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_query/async/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'esql.async_query_get',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'drop_null_columns',
                'format',
                'keep_alive',
                'wait_for_completion_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async asyncQueryStop(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['esql.async_query_stop'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_query/async/${encodeURIComponent(params.id.toString())}/stop`;
        const meta = {
            name: 'esql.async_query_stop',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'drop_null_columns'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getQuery(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['esql.get_query'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_query/queries/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'esql.get_query',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async listQueries(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['esql.list_queries'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_query/queries';
        const meta = {
            name: 'esql.list_queries',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async query(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['esql.query'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_query';
        const meta = {
            name: 'esql.query',
            acceptedParams: [
                'columnar',
                'filter',
                'locale',
                'params',
                'profile',
                'query',
                'tables',
                'include_ccs_metadata',
                'include_execution_metadata',
                'format',
                'delimiter',
                'drop_null_columns',
                'allow_partial_results'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Esql; //# sourceMappingURL=esql.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/exists.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ExistsApi;
const acceptedParams = {
    exists: {
        path: [
            'id',
            'index'
        ],
        body: [],
        query: [
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'stored_fields',
            'version',
            'version_type'
        ]
    }
};
async function ExistsApi(params, options) {
    const { path: acceptedPath } = acceptedParams.exists;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'HEAD';
    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'exists',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'stored_fields',
            'version',
            'version_type'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=exists.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/exists_source.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ExistsSourceApi;
const acceptedParams = {
    exists_source: {
        path: [
            'id',
            'index'
        ],
        body: [],
        query: [
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'version',
            'version_type'
        ]
    }
};
async function ExistsSourceApi(params, options) {
    const { path: acceptedPath } = acceptedParams.exists_source;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'HEAD';
    const path = `/${encodeURIComponent(params.index.toString())}/_source/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'exists_source',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'version',
            'version_type'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=exists_source.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/explain.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ExplainApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    explain: {
        path: [
            'id',
            'index'
        ],
        body: [
            'query'
        ],
        query: [
            'analyzer',
            'analyze_wildcard',
            'default_operator',
            'df',
            'lenient',
            'preference',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'stored_fields',
            'q'
        ]
    }
};
async function ExplainApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.explain;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = body != null ? 'POST' : 'GET';
    const path = `/${encodeURIComponent(params.index.toString())}/_explain/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'explain',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'query',
            'analyzer',
            'analyze_wildcard',
            'default_operator',
            'df',
            'lenient',
            'preference',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'stored_fields',
            'q'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=explain.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/features.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Features {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'features.get_features': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'features.reset_features': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            }
        };
    }
    async getFeatures(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['features.get_features'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_features';
        const meta = {
            name: 'features.get_features',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async resetFeatures(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['features.reset_features'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_features/_reset';
        const meta = {
            name: 'features.reset_features',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Features; //# sourceMappingURL=features.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/field_caps.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = FieldCapsApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    field_caps: {
        path: [
            'index'
        ],
        body: [
            'fields',
            'index_filter',
            'runtime_mappings'
        ],
        query: [
            'allow_no_indices',
            'expand_wildcards',
            'fields',
            'ignore_unavailable',
            'include_unmapped',
            'filters',
            'types',
            'include_empty_fields',
            'project_routing'
        ]
    }
};
async function FieldCapsApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.field_caps;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_field_caps`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_field_caps';
    }
    const meta = {
        name: 'field_caps',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'fields',
            'index_filter',
            'runtime_mappings',
            'allow_no_indices',
            'expand_wildcards',
            'fields',
            'ignore_unavailable',
            'include_unmapped',
            'filters',
            'types',
            'include_empty_fields',
            'project_routing'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=field_caps.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/fleet.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Fleet {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'fleet.delete_secret': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'fleet.get_secret': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'fleet.global_checkpoints': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'wait_for_advance',
                    'wait_for_index',
                    'checkpoints',
                    'timeout'
                ]
            },
            'fleet.msearch': {
                path: [
                    'index'
                ],
                body: [
                    'searches'
                ],
                query: [
                    'allow_no_indices',
                    'ccs_minimize_roundtrips',
                    'expand_wildcards',
                    'ignore_throttled',
                    'ignore_unavailable',
                    'max_concurrent_searches',
                    'max_concurrent_shard_requests',
                    'pre_filter_shard_size',
                    'search_type',
                    'rest_total_hits_as_int',
                    'typed_keys',
                    'wait_for_checkpoints',
                    'allow_partial_search_results'
                ]
            },
            'fleet.post_secret': {
                path: [],
                body: [],
                query: []
            },
            'fleet.search': {
                path: [
                    'index'
                ],
                body: [
                    'aggregations',
                    'aggs',
                    'collapse',
                    'explain',
                    'ext',
                    'from',
                    'highlight',
                    'track_total_hits',
                    'indices_boost',
                    'docvalue_fields',
                    'min_score',
                    'post_filter',
                    'profile',
                    'query',
                    'rescore',
                    'script_fields',
                    'search_after',
                    'size',
                    'slice',
                    'sort',
                    '_source',
                    'fields',
                    'suggest',
                    'terminate_after',
                    'timeout',
                    'track_scores',
                    'version',
                    'seq_no_primary_term',
                    'stored_fields',
                    'pit',
                    'runtime_mappings',
                    'stats'
                ],
                query: [
                    'allow_no_indices',
                    'analyzer',
                    'analyze_wildcard',
                    'batched_reduce_size',
                    'ccs_minimize_roundtrips',
                    'default_operator',
                    'df',
                    'docvalue_fields',
                    'expand_wildcards',
                    'explain',
                    'ignore_throttled',
                    'ignore_unavailable',
                    'lenient',
                    'max_concurrent_shard_requests',
                    'preference',
                    'pre_filter_shard_size',
                    'request_cache',
                    'routing',
                    'scroll',
                    'search_type',
                    'stats',
                    'stored_fields',
                    'suggest_field',
                    'suggest_mode',
                    'suggest_size',
                    'suggest_text',
                    'terminate_after',
                    'timeout',
                    'track_total_hits',
                    'track_scores',
                    'typed_keys',
                    'rest_total_hits_as_int',
                    'version',
                    '_source',
                    '_source_excludes',
                    '_source_includes',
                    'seq_no_primary_term',
                    'q',
                    'size',
                    'from',
                    'sort',
                    'wait_for_checkpoints',
                    'allow_partial_search_results'
                ]
            }
        };
    }
    async deleteSecret(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['fleet.delete_secret'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_fleet/secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'fleet.delete_secret',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getSecret(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['fleet.get_secret'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_fleet/secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'fleet.get_secret',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async globalCheckpoints(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['fleet.global_checkpoints'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_fleet/global_checkpoints`;
        const meta = {
            name: 'fleet.global_checkpoints',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'wait_for_advance',
                'wait_for_index',
                'checkpoints',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async msearch(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['fleet.msearch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = body != null ? 'POST' : 'GET';
            path = `/${encodeURIComponent(params.index.toString())}/_fleet/_fleet_msearch`;
        } else {
            method = body != null ? 'POST' : 'GET';
            path = '/_fleet/_fleet_msearch';
        }
        const meta = {
            name: 'fleet.msearch',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'searches',
                'allow_no_indices',
                'ccs_minimize_roundtrips',
                'expand_wildcards',
                'ignore_throttled',
                'ignore_unavailable',
                'max_concurrent_searches',
                'max_concurrent_shard_requests',
                'pre_filter_shard_size',
                'search_type',
                'rest_total_hits_as_int',
                'typed_keys',
                'wait_for_checkpoints',
                'allow_partial_search_results'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            bulkBody: body,
            meta
        }, options);
    }
    async postSecret(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['fleet.post_secret'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_fleet/secret';
        const meta = {
            name: 'fleet.post_secret',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async search(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['fleet.search'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_fleet/_fleet_search`;
        const meta = {
            name: 'fleet.search',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'aggregations',
                'aggs',
                'collapse',
                'explain',
                'ext',
                'from',
                'highlight',
                'track_total_hits',
                'indices_boost',
                'docvalue_fields',
                'min_score',
                'post_filter',
                'profile',
                'query',
                'rescore',
                'script_fields',
                'search_after',
                'size',
                'slice',
                'sort',
                '_source',
                'fields',
                'suggest',
                'terminate_after',
                'timeout',
                'track_scores',
                'version',
                'seq_no_primary_term',
                'stored_fields',
                'pit',
                'runtime_mappings',
                'stats',
                'allow_no_indices',
                'analyzer',
                'analyze_wildcard',
                'batched_reduce_size',
                'ccs_minimize_roundtrips',
                'default_operator',
                'df',
                'docvalue_fields',
                'expand_wildcards',
                'explain',
                'ignore_throttled',
                'ignore_unavailable',
                'lenient',
                'max_concurrent_shard_requests',
                'preference',
                'pre_filter_shard_size',
                'request_cache',
                'routing',
                'scroll',
                'search_type',
                'stats',
                'stored_fields',
                'suggest_field',
                'suggest_mode',
                'suggest_size',
                'suggest_text',
                'terminate_after',
                'timeout',
                'track_total_hits',
                'track_scores',
                'typed_keys',
                'rest_total_hits_as_int',
                'version',
                '_source',
                '_source_excludes',
                '_source_includes',
                'seq_no_primary_term',
                'q',
                'size',
                'from',
                'sort',
                'wait_for_checkpoints',
                'allow_partial_search_results'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Fleet; //# sourceMappingURL=fleet.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/get.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = GetApi;
const acceptedParams = {
    get: {
        path: [
            'id',
            'index'
        ],
        body: [],
        query: [
            'force_synthetic_source',
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_exclude_vectors',
            '_source_includes',
            'stored_fields',
            'version',
            'version_type'
        ]
    }
};
async function GetApi(params, options) {
    const { path: acceptedPath } = acceptedParams.get;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'GET';
    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'get',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'force_synthetic_source',
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_exclude_vectors',
            '_source_includes',
            'stored_fields',
            'version',
            'version_type'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=get.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/get_script.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = GetScriptApi;
const acceptedParams = {
    get_script: {
        path: [
            'id'
        ],
        body: [],
        query: [
            'master_timeout'
        ]
    }
};
async function GetScriptApi(params, options) {
    const { path: acceptedPath } = acceptedParams.get_script;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'GET';
    const path = `/_scripts/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'get_script',
        pathParts: {
            id: params.id
        },
        acceptedParams: [
            'id',
            'master_timeout'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=get_script.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/get_script_context.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = GetScriptContextApi;
const acceptedParams = {
    get_script_context: {
        path: [],
        body: [],
        query: []
    }
};
async function GetScriptContextApi(params, options) {
    const { path: acceptedPath } = acceptedParams.get_script_context;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'GET';
    const path = '/_script_context';
    const meta = {
        name: 'get_script_context',
        acceptedParams: []
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=get_script_context.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/get_script_languages.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = GetScriptLanguagesApi;
const acceptedParams = {
    get_script_languages: {
        path: [],
        body: [],
        query: []
    }
};
async function GetScriptLanguagesApi(params, options) {
    const { path: acceptedPath } = acceptedParams.get_script_languages;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'GET';
    const path = '/_script_language';
    const meta = {
        name: 'get_script_languages',
        acceptedParams: []
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=get_script_languages.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/get_source.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = GetSourceApi;
const acceptedParams = {
    get_source: {
        path: [
            'id',
            'index'
        ],
        body: [],
        query: [
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'version',
            'version_type'
        ]
    }
};
async function GetSourceApi(params, options) {
    const { path: acceptedPath } = acceptedParams.get_source;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'GET';
    const path = `/${encodeURIComponent(params.index.toString())}/_source/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'get_source',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'version',
            'version_type'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=get_source.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/graph.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Graph {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'graph.explore': {
                path: [
                    'index'
                ],
                body: [
                    'connections',
                    'controls',
                    'query',
                    'vertices'
                ],
                query: [
                    'routing',
                    'timeout'
                ]
            }
        };
    }
    async explore(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['graph.explore'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_graph/explore`;
        const meta = {
            name: 'graph.explore',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'connections',
                'controls',
                'query',
                'vertices',
                'routing',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Graph; //# sourceMappingURL=graph.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/health_report.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = HealthReportApi;
const acceptedParams = {
    health_report: {
        path: [
            'feature'
        ],
        body: [],
        query: [
            'timeout',
            'verbose',
            'size'
        ]
    }
};
async function HealthReportApi(params, options) {
    const { path: acceptedPath } = acceptedParams.health_report;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    let method = '';
    let path = '';
    if (params.feature != null) {
        method = 'GET';
        path = `/_health_report/${encodeURIComponent(params.feature.toString())}`;
    } else {
        method = 'GET';
        path = '/_health_report';
    }
    const meta = {
        name: 'health_report',
        pathParts: {
            feature: params.feature
        },
        acceptedParams: [
            'feature',
            'timeout',
            'verbose',
            'size'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=health_report.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/ilm.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Ilm {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'ilm.delete_lifecycle': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ilm.explain_lifecycle': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'only_errors',
                    'only_managed',
                    'master_timeout'
                ]
            },
            'ilm.get_lifecycle': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ilm.get_status': {
                path: [],
                body: [],
                query: []
            },
            'ilm.migrate_to_data_tiers': {
                path: [],
                body: [
                    'legacy_template_to_delete',
                    'node_attribute'
                ],
                query: [
                    'dry_run',
                    'master_timeout'
                ]
            },
            'ilm.move_to_step': {
                path: [
                    'index'
                ],
                body: [
                    'current_step',
                    'next_step'
                ],
                query: []
            },
            'ilm.put_lifecycle': {
                path: [
                    'name'
                ],
                body: [
                    'policy'
                ],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ilm.remove_policy': {
                path: [
                    'index'
                ],
                body: [],
                query: []
            },
            'ilm.retry': {
                path: [
                    'index'
                ],
                body: [],
                query: []
            },
            'ilm.start': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ilm.stop': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            }
        };
    }
    async deleteLifecycle(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ilm.delete_lifecycle'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'ilm.delete_lifecycle',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'policy',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async explainLifecycle(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ilm.explain_lifecycle'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/explain`;
        const meta = {
            name: 'ilm.explain_lifecycle',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'only_errors',
                'only_managed',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getLifecycle(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ilm.get_lifecycle'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_ilm/policy';
        }
        const meta = {
            name: 'ilm.get_lifecycle',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'policy',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getStatus(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ilm.get_status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_ilm/status';
        const meta = {
            name: 'ilm.get_status',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async migrateToDataTiers(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ilm.migrate_to_data_tiers'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_ilm/migrate_to_data_tiers';
        const meta = {
            name: 'ilm.migrate_to_data_tiers',
            acceptedParams: [
                'legacy_template_to_delete',
                'node_attribute',
                'dry_run',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async moveToStep(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ilm.move_to_step'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_ilm/move/${encodeURIComponent(params.index.toString())}`;
        const meta = {
            name: 'ilm.move_to_step',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'current_step',
                'next_step'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putLifecycle(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ilm.put_lifecycle'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'ilm.put_lifecycle',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'policy',
                'policy',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async removePolicy(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ilm.remove_policy'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/remove`;
        const meta = {
            name: 'ilm.remove_policy',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async retry(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ilm.retry'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/retry`;
        const meta = {
            name: 'ilm.retry',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async start(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ilm.start'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_ilm/start';
        const meta = {
            name: 'ilm.start',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stop(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ilm.stop'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_ilm/stop';
        const meta = {
            name: 'ilm.stop',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Ilm; //# sourceMappingURL=ilm.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = IndexApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    index: {
        path: [
            'id',
            'index'
        ],
        body: [
            'document'
        ],
        query: [
            'if_primary_term',
            'if_seq_no',
            'include_source_on_error',
            'op_type',
            'pipeline',
            'refresh',
            'routing',
            'timeout',
            'version',
            'version_type',
            'wait_for_active_shards',
            'require_alias',
            'require_data_stream'
        ]
    }
};
async function IndexApi(params, options) {
    var _a;
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.index;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;
    for(const key in params){
        if (acceptedBody.includes(key)) {
            // @ts-expect-error
            body = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null && params.id != null) {
        method = 'PUT';
        path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;
    } else {
        method = 'POST';
        path = `/${encodeURIComponent(params.index.toString())}/_doc`;
    }
    const meta = {
        name: 'index',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'document',
            'if_primary_term',
            'if_seq_no',
            'include_source_on_error',
            'op_type',
            'pipeline',
            'refresh',
            'routing',
            'timeout',
            'version',
            'version_type',
            'wait_for_active_shards',
            'require_alias',
            'require_data_stream'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/inference.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Inference {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'inference.chat_completion_unified': {
                path: [
                    'inference_id'
                ],
                body: [
                    'chat_completion_request'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.completion': {
                path: [
                    'inference_id'
                ],
                body: [
                    'input',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.delete': {
                path: [
                    'task_type',
                    'inference_id'
                ],
                body: [],
                query: [
                    'dry_run',
                    'force'
                ]
            },
            'inference.get': {
                path: [
                    'task_type',
                    'inference_id'
                ],
                body: [],
                query: []
            },
            'inference.inference': {
                path: [
                    'task_type',
                    'inference_id'
                ],
                body: [
                    'query',
                    'input',
                    'input_type',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put': {
                path: [
                    'task_type',
                    'inference_id'
                ],
                body: [
                    'inference_config'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_ai21': {
                path: [
                    'task_type',
                    'ai21_inference_id'
                ],
                body: [
                    'service',
                    'service_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_alibabacloud': {
                path: [
                    'task_type',
                    'alibabacloud_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_amazonbedrock': {
                path: [
                    'task_type',
                    'amazonbedrock_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_amazonsagemaker': {
                path: [
                    'task_type',
                    'amazonsagemaker_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_anthropic': {
                path: [
                    'task_type',
                    'anthropic_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_azureaistudio': {
                path: [
                    'task_type',
                    'azureaistudio_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_azureopenai': {
                path: [
                    'task_type',
                    'azureopenai_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_cohere': {
                path: [
                    'task_type',
                    'cohere_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_custom': {
                path: [
                    'task_type',
                    'custom_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: []
            },
            'inference.put_deepseek': {
                path: [
                    'task_type',
                    'deepseek_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_elasticsearch': {
                path: [
                    'task_type',
                    'elasticsearch_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_elser': {
                path: [
                    'task_type',
                    'elser_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_googleaistudio': {
                path: [
                    'task_type',
                    'googleaistudio_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_googlevertexai': {
                path: [
                    'task_type',
                    'googlevertexai_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_hugging_face': {
                path: [
                    'task_type',
                    'huggingface_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_jinaai': {
                path: [
                    'task_type',
                    'jinaai_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_llama': {
                path: [
                    'task_type',
                    'llama_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_mistral': {
                path: [
                    'task_type',
                    'mistral_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_openai': {
                path: [
                    'task_type',
                    'openai_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_voyageai': {
                path: [
                    'task_type',
                    'voyageai_inference_id'
                ],
                body: [
                    'chunking_settings',
                    'service',
                    'service_settings',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.put_watsonx': {
                path: [
                    'task_type',
                    'watsonx_inference_id'
                ],
                body: [
                    'service',
                    'service_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.rerank': {
                path: [
                    'inference_id'
                ],
                body: [
                    'query',
                    'input',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.sparse_embedding': {
                path: [
                    'inference_id'
                ],
                body: [
                    'input',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.stream_completion': {
                path: [
                    'inference_id'
                ],
                body: [
                    'input',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.text_embedding': {
                path: [
                    'inference_id'
                ],
                body: [
                    'input',
                    'input_type',
                    'task_settings'
                ],
                query: [
                    'timeout'
                ]
            },
            'inference.update': {
                path: [
                    'inference_id',
                    'task_type'
                ],
                body: [
                    'inference_config'
                ],
                query: []
            }
        };
    }
    async chatCompletionUnified(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.chat_completion_unified'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_inference/chat_completion/${encodeURIComponent(params.inference_id.toString())}/_stream`;
        const meta = {
            name: 'inference.chat_completion_unified',
            pathParts: {
                inference_id: params.inference_id
            },
            acceptedParams: [
                'inference_id',
                'chat_completion_request',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async completion(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.completion'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_inference/completion/${encodeURIComponent(params.inference_id.toString())}`;
        const meta = {
            name: 'inference.completion',
            pathParts: {
                inference_id: params.inference_id
            },
            acceptedParams: [
                'inference_id',
                'input',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async delete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['inference.delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.task_type != null && params.inference_id != null) {
            method = 'DELETE';
            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;
        } else {
            method = 'DELETE';
            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;
        }
        const meta = {
            name: 'inference.delete',
            pathParts: {
                task_type: params.task_type,
                inference_id: params.inference_id
            },
            acceptedParams: [
                'task_type',
                'inference_id',
                'dry_run',
                'force'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async get(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['inference.get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.task_type != null && params.inference_id != null) {
            method = 'GET';
            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;
        } else if (params.inference_id != null) {
            method = 'GET';
            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_inference';
        }
        const meta = {
            name: 'inference.get',
            pathParts: {
                task_type: params.task_type,
                inference_id: params.inference_id
            },
            acceptedParams: [
                'task_type',
                'inference_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async inference(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.inference'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.task_type != null && params.inference_id != null) {
            method = 'POST';
            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;
        } else {
            method = 'POST';
            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;
        }
        const meta = {
            name: 'inference.inference',
            pathParts: {
                task_type: params.task_type,
                inference_id: params.inference_id
            },
            acceptedParams: [
                'task_type',
                'inference_id',
                'query',
                'input',
                'input_type',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async put(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.task_type != null && params.inference_id != null) {
            method = 'PUT';
            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;
        } else {
            method = 'PUT';
            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;
        }
        const meta = {
            name: 'inference.put',
            pathParts: {
                task_type: params.task_type,
                inference_id: params.inference_id
            },
            acceptedParams: [
                'task_type',
                'inference_id',
                'inference_config',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAi21(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_ai21'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.ai21_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_ai21',
            pathParts: {
                task_type: params.task_type,
                ai21_inference_id: params.ai21_inference_id
            },
            acceptedParams: [
                'task_type',
                'ai21_inference_id',
                'service',
                'service_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAlibabacloud(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_alibabacloud'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.alibabacloud_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_alibabacloud',
            pathParts: {
                task_type: params.task_type,
                alibabacloud_inference_id: params.alibabacloud_inference_id
            },
            acceptedParams: [
                'task_type',
                'alibabacloud_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAmazonbedrock(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_amazonbedrock'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.amazonbedrock_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_amazonbedrock',
            pathParts: {
                task_type: params.task_type,
                amazonbedrock_inference_id: params.amazonbedrock_inference_id
            },
            acceptedParams: [
                'task_type',
                'amazonbedrock_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAmazonsagemaker(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_amazonsagemaker'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.amazonsagemaker_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_amazonsagemaker',
            pathParts: {
                task_type: params.task_type,
                amazonsagemaker_inference_id: params.amazonsagemaker_inference_id
            },
            acceptedParams: [
                'task_type',
                'amazonsagemaker_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAnthropic(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_anthropic'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.anthropic_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_anthropic',
            pathParts: {
                task_type: params.task_type,
                anthropic_inference_id: params.anthropic_inference_id
            },
            acceptedParams: [
                'task_type',
                'anthropic_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAzureaistudio(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_azureaistudio'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.azureaistudio_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_azureaistudio',
            pathParts: {
                task_type: params.task_type,
                azureaistudio_inference_id: params.azureaistudio_inference_id
            },
            acceptedParams: [
                'task_type',
                'azureaistudio_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putAzureopenai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_azureopenai'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.azureopenai_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_azureopenai',
            pathParts: {
                task_type: params.task_type,
                azureopenai_inference_id: params.azureopenai_inference_id
            },
            acceptedParams: [
                'task_type',
                'azureopenai_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putCohere(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_cohere'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.cohere_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_cohere',
            pathParts: {
                task_type: params.task_type,
                cohere_inference_id: params.cohere_inference_id
            },
            acceptedParams: [
                'task_type',
                'cohere_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putCustom(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_custom'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.custom_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_custom',
            pathParts: {
                task_type: params.task_type,
                custom_inference_id: params.custom_inference_id
            },
            acceptedParams: [
                'task_type',
                'custom_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putDeepseek(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_deepseek'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.deepseek_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_deepseek',
            pathParts: {
                task_type: params.task_type,
                deepseek_inference_id: params.deepseek_inference_id
            },
            acceptedParams: [
                'task_type',
                'deepseek_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putElasticsearch(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_elasticsearch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.elasticsearch_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_elasticsearch',
            pathParts: {
                task_type: params.task_type,
                elasticsearch_inference_id: params.elasticsearch_inference_id
            },
            acceptedParams: [
                'task_type',
                'elasticsearch_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putElser(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_elser'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.elser_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_elser',
            pathParts: {
                task_type: params.task_type,
                elser_inference_id: params.elser_inference_id
            },
            acceptedParams: [
                'task_type',
                'elser_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putGoogleaistudio(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_googleaistudio'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.googleaistudio_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_googleaistudio',
            pathParts: {
                task_type: params.task_type,
                googleaistudio_inference_id: params.googleaistudio_inference_id
            },
            acceptedParams: [
                'task_type',
                'googleaistudio_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putGooglevertexai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_googlevertexai'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.googlevertexai_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_googlevertexai',
            pathParts: {
                task_type: params.task_type,
                googlevertexai_inference_id: params.googlevertexai_inference_id
            },
            acceptedParams: [
                'task_type',
                'googlevertexai_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putHuggingFace(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_hugging_face'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.huggingface_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_hugging_face',
            pathParts: {
                task_type: params.task_type,
                huggingface_inference_id: params.huggingface_inference_id
            },
            acceptedParams: [
                'task_type',
                'huggingface_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putJinaai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_jinaai'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.jinaai_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_jinaai',
            pathParts: {
                task_type: params.task_type,
                jinaai_inference_id: params.jinaai_inference_id
            },
            acceptedParams: [
                'task_type',
                'jinaai_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putLlama(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_llama'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.llama_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_llama',
            pathParts: {
                task_type: params.task_type,
                llama_inference_id: params.llama_inference_id
            },
            acceptedParams: [
                'task_type',
                'llama_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putMistral(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_mistral'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.mistral_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_mistral',
            pathParts: {
                task_type: params.task_type,
                mistral_inference_id: params.mistral_inference_id
            },
            acceptedParams: [
                'task_type',
                'mistral_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putOpenai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_openai'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.openai_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_openai',
            pathParts: {
                task_type: params.task_type,
                openai_inference_id: params.openai_inference_id
            },
            acceptedParams: [
                'task_type',
                'openai_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putVoyageai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_voyageai'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.voyageai_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_voyageai',
            pathParts: {
                task_type: params.task_type,
                voyageai_inference_id: params.voyageai_inference_id
            },
            acceptedParams: [
                'task_type',
                'voyageai_inference_id',
                'chunking_settings',
                'service',
                'service_settings',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putWatsonx(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.put_watsonx'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.watsonx_inference_id.toString())}`;
        const meta = {
            name: 'inference.put_watsonx',
            pathParts: {
                task_type: params.task_type,
                watsonx_inference_id: params.watsonx_inference_id
            },
            acceptedParams: [
                'task_type',
                'watsonx_inference_id',
                'service',
                'service_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async rerank(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.rerank'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_inference/rerank/${encodeURIComponent(params.inference_id.toString())}`;
        const meta = {
            name: 'inference.rerank',
            pathParts: {
                inference_id: params.inference_id
            },
            acceptedParams: [
                'inference_id',
                'query',
                'input',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async sparseEmbedding(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.sparse_embedding'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_inference/sparse_embedding/${encodeURIComponent(params.inference_id.toString())}`;
        const meta = {
            name: 'inference.sparse_embedding',
            pathParts: {
                inference_id: params.inference_id
            },
            acceptedParams: [
                'inference_id',
                'input',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async streamCompletion(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.stream_completion'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_inference/completion/${encodeURIComponent(params.inference_id.toString())}/_stream`;
        const meta = {
            name: 'inference.stream_completion',
            pathParts: {
                inference_id: params.inference_id
            },
            acceptedParams: [
                'inference_id',
                'input',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async textEmbedding(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.text_embedding'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_inference/text_embedding/${encodeURIComponent(params.inference_id.toString())}`;
        const meta = {
            name: 'inference.text_embedding',
            pathParts: {
                inference_id: params.inference_id
            },
            acceptedParams: [
                'inference_id',
                'input',
                'input_type',
                'task_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async update(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['inference.update'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.task_type != null && params.inference_id != null) {
            method = 'PUT';
            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}/_update`;
        } else {
            method = 'PUT';
            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}/_update`;
        }
        const meta = {
            name: 'inference.update',
            pathParts: {
                inference_id: params.inference_id,
                task_type: params.task_type
            },
            acceptedParams: [
                'inference_id',
                'task_type',
                'inference_config'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Inference; //# sourceMappingURL=inference.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/info.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = InfoApi;
const acceptedParams = {
    info: {
        path: [],
        body: [],
        query: []
    }
};
async function InfoApi(params, options) {
    const { path: acceptedPath } = acceptedParams.info;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'GET';
    const path = '/';
    const meta = {
        name: 'info',
        acceptedParams: []
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=info.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/ingest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Ingest {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'ingest.delete_geoip_database': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ingest.delete_ip_location_database': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ingest.delete_pipeline': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ingest.geo_ip_stats': {
                path: [],
                body: [],
                query: []
            },
            'ingest.get_geoip_database': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'ingest.get_ip_location_database': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'ingest.get_pipeline': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'summary'
                ]
            },
            'ingest.processor_grok': {
                path: [],
                body: [],
                query: []
            },
            'ingest.put_geoip_database': {
                path: [
                    'id'
                ],
                body: [
                    'name',
                    'maxmind'
                ],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ingest.put_ip_location_database': {
                path: [
                    'id'
                ],
                body: [
                    'configuration'
                ],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'ingest.put_pipeline': {
                path: [
                    'id'
                ],
                body: [
                    '_meta',
                    'description',
                    'on_failure',
                    'processors',
                    'version',
                    'deprecated',
                    'field_access_pattern'
                ],
                query: [
                    'master_timeout',
                    'timeout',
                    'if_version'
                ]
            },
            'ingest.simulate': {
                path: [
                    'id'
                ],
                body: [
                    'docs',
                    'pipeline'
                ],
                query: [
                    'verbose'
                ]
            }
        };
    }
    async deleteGeoipDatabase(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ingest.delete_geoip_database'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'ingest.delete_geoip_database',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteIpLocationDatabase(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ingest.delete_ip_location_database'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'ingest.delete_ip_location_database',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deletePipeline(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ingest.delete_pipeline'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'ingest.delete_pipeline',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async geoIpStats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ingest.geo_ip_stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_ingest/geoip/stats';
        const meta = {
            name: 'ingest.geo_ip_stats',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getGeoipDatabase(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ingest.get_geoip_database'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = 'GET';
            path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;
        } else {
            method = 'GET';
            path = '/_ingest/geoip/database';
        }
        const meta = {
            name: 'ingest.get_geoip_database',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getIpLocationDatabase(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ingest.get_ip_location_database'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = 'GET';
            path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;
        } else {
            method = 'GET';
            path = '/_ingest/ip_location/database';
        }
        const meta = {
            name: 'ingest.get_ip_location_database',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getPipeline(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ingest.get_pipeline'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = 'GET';
            path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;
        } else {
            method = 'GET';
            path = '/_ingest/pipeline';
        }
        const meta = {
            name: 'ingest.get_pipeline',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'master_timeout',
                'summary'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async processorGrok(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ingest.processor_grok'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_ingest/processor/grok';
        const meta = {
            name: 'ingest.processor_grok',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putGeoipDatabase(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ingest.put_geoip_database'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'ingest.put_geoip_database',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'name',
                'maxmind',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putIpLocationDatabase(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ingest.put_ip_location_database'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'ingest.put_ip_location_database',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'configuration',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putPipeline(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ingest.put_pipeline'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'ingest.put_pipeline',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                '_meta',
                'description',
                'on_failure',
                'processors',
                'version',
                'deprecated',
                'field_access_pattern',
                'master_timeout',
                'timeout',
                'if_version'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async simulate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['ingest.simulate'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = body != null ? 'POST' : 'GET';
            path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}/_simulate`;
        } else {
            method = body != null ? 'POST' : 'GET';
            path = '/_ingest/pipeline/_simulate';
        }
        const meta = {
            name: 'ingest.simulate',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'docs',
                'pipeline',
                'verbose'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Ingest; //# sourceMappingURL=ingest.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/knn_search.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = KnnSearchApi;
const acceptedParams = {
    knn_search: {
        path: [
            'index'
        ],
        body: [],
        query: []
    }
};
async function KnnSearchApi(params, options) {
    const { path: acceptedPath } = acceptedParams.knn_search;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            querystring[key] = params[key];
        }
    }
    const method = body != null ? 'POST' : 'GET';
    const path = `/${encodeURIComponent(params.index.toString())}/_knn_search`;
    const meta = {
        name: 'knn_search',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=knn_search.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/license.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class License {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'license.delete': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'license.get': {
                path: [],
                body: [],
                query: [
                    'accept_enterprise',
                    'local'
                ]
            },
            'license.get_basic_status': {
                path: [],
                body: [],
                query: []
            },
            'license.get_trial_status': {
                path: [],
                body: [],
                query: []
            },
            'license.post': {
                path: [],
                body: [
                    'license',
                    'licenses'
                ],
                query: [
                    'acknowledge',
                    'master_timeout',
                    'timeout'
                ]
            },
            'license.post_start_basic': {
                path: [],
                body: [],
                query: [
                    'acknowledge',
                    'master_timeout',
                    'timeout'
                ]
            },
            'license.post_start_trial': {
                path: [],
                body: [],
                query: [
                    'acknowledge',
                    'type',
                    'master_timeout'
                ]
            }
        };
    }
    async delete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['license.delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = '/_license';
        const meta = {
            name: 'license.delete',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async get(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['license.get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_license';
        const meta = {
            name: 'license.get',
            acceptedParams: [
                'accept_enterprise',
                'local'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getBasicStatus(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['license.get_basic_status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_license/basic_status';
        const meta = {
            name: 'license.get_basic_status',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getTrialStatus(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['license.get_trial_status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_license/trial_status';
        const meta = {
            name: 'license.get_trial_status',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async post(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['license.post'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = '/_license';
        const meta = {
            name: 'license.post',
            acceptedParams: [
                'license',
                'licenses',
                'acknowledge',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async postStartBasic(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['license.post_start_basic'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_license/start_basic';
        const meta = {
            name: 'license.post_start_basic',
            acceptedParams: [
                'acknowledge',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async postStartTrial(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['license.post_start_trial'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_license/start_trial';
        const meta = {
            name: 'license.post_start_trial',
            acceptedParams: [
                'acknowledge',
                'type',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = License; //# sourceMappingURL=license.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/logstash.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Logstash {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'logstash.delete_pipeline': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'logstash.get_pipeline': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'logstash.put_pipeline': {
                path: [
                    'id'
                ],
                body: [
                    'pipeline'
                ],
                query: []
            }
        };
    }
    async deletePipeline(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['logstash.delete_pipeline'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'logstash.delete_pipeline',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getPipeline(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['logstash.get_pipeline'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = 'GET';
            path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;
        } else {
            method = 'GET';
            path = '/_logstash/pipeline';
        }
        const meta = {
            name: 'logstash.get_pipeline',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putPipeline(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['logstash.put_pipeline'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'logstash.put_pipeline',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'pipeline'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Logstash; //# sourceMappingURL=logstash.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/mget.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = MgetApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    mget: {
        path: [
            'index'
        ],
        body: [
            'docs',
            'ids'
        ],
        query: [
            'force_synthetic_source',
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'stored_fields'
        ]
    }
};
async function MgetApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.mget;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_mget`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_mget';
    }
    const meta = {
        name: 'mget',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'docs',
            'ids',
            'force_synthetic_source',
            'preference',
            'realtime',
            'refresh',
            'routing',
            '_source',
            '_source_excludes',
            '_source_includes',
            'stored_fields'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=mget.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/migration.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Migration {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'migration.deprecations': {
                path: [
                    'index'
                ],
                body: [],
                query: []
            },
            'migration.get_feature_upgrade_status': {
                path: [],
                body: [],
                query: []
            },
            'migration.post_feature_upgrade': {
                path: [],
                body: [],
                query: []
            }
        };
    }
    async deprecations(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['migration.deprecations'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'GET';
            path = `/${encodeURIComponent(params.index.toString())}/_migration/deprecations`;
        } else {
            method = 'GET';
            path = '/_migration/deprecations';
        }
        const meta = {
            name: 'migration.deprecations',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getFeatureUpgradeStatus(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['migration.get_feature_upgrade_status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_migration/system_features';
        const meta = {
            name: 'migration.get_feature_upgrade_status',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async postFeatureUpgrade(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['migration.post_feature_upgrade'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_migration/system_features';
        const meta = {
            name: 'migration.post_feature_upgrade',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Migration; //# sourceMappingURL=migration.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/monitoring.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Monitoring {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'monitoring.bulk': {
                path: [
                    'type'
                ],
                body: [
                    'operations'
                ],
                query: [
                    'system_id',
                    'system_api_version',
                    'interval'
                ]
            }
        };
    }
    async bulk(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['monitoring.bulk'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_monitoring/bulk';
        const meta = {
            name: 'monitoring.bulk',
            pathParts: {
                type: params.type
            },
            acceptedParams: [
                'type',
                'operations',
                'system_id',
                'system_api_version',
                'interval'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            bulkBody: body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Monitoring; //# sourceMappingURL=monitoring.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/msearch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = MsearchApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    msearch: {
        path: [
            'index'
        ],
        body: [
            'searches'
        ],
        query: [
            'allow_no_indices',
            'ccs_minimize_roundtrips',
            'expand_wildcards',
            'ignore_throttled',
            'ignore_unavailable',
            'include_named_queries_score',
            'index',
            'max_concurrent_searches',
            'max_concurrent_shard_requests',
            'pre_filter_shard_size',
            'project_routing',
            'rest_total_hits_as_int',
            'routing',
            'search_type',
            'typed_keys'
        ]
    }
};
async function MsearchApi(params, options) {
    var _a;
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.msearch;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;
    for(const key in params){
        if (acceptedBody.includes(key)) {
            // @ts-expect-error
            body = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_msearch`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_msearch';
    }
    const meta = {
        name: 'msearch',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'searches',
            'allow_no_indices',
            'ccs_minimize_roundtrips',
            'expand_wildcards',
            'ignore_throttled',
            'ignore_unavailable',
            'include_named_queries_score',
            'index',
            'max_concurrent_searches',
            'max_concurrent_shard_requests',
            'pre_filter_shard_size',
            'project_routing',
            'rest_total_hits_as_int',
            'routing',
            'search_type',
            'typed_keys'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        bulkBody: body,
        meta
    }, options);
} //# sourceMappingURL=msearch.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/msearch_template.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = MsearchTemplateApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    msearch_template: {
        path: [
            'index'
        ],
        body: [
            'search_templates'
        ],
        query: [
            'ccs_minimize_roundtrips',
            'max_concurrent_searches',
            'project_routing',
            'search_type',
            'rest_total_hits_as_int',
            'typed_keys'
        ]
    }
};
async function MsearchTemplateApi(params, options) {
    var _a;
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.msearch_template;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;
    for(const key in params){
        if (acceptedBody.includes(key)) {
            // @ts-expect-error
            body = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_msearch/template`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_msearch/template';
    }
    const meta = {
        name: 'msearch_template',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'search_templates',
            'ccs_minimize_roundtrips',
            'max_concurrent_searches',
            'project_routing',
            'search_type',
            'rest_total_hits_as_int',
            'typed_keys'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        bulkBody: body,
        meta
    }, options);
} //# sourceMappingURL=msearch_template.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/mtermvectors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = MtermvectorsApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    mtermvectors: {
        path: [
            'index'
        ],
        body: [
            'docs',
            'ids'
        ],
        query: [
            'ids',
            'fields',
            'field_statistics',
            'offsets',
            'payloads',
            'positions',
            'preference',
            'realtime',
            'routing',
            'term_statistics',
            'version',
            'version_type'
        ]
    }
};
async function MtermvectorsApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.mtermvectors;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_mtermvectors`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_mtermvectors';
    }
    const meta = {
        name: 'mtermvectors',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'docs',
            'ids',
            'ids',
            'fields',
            'field_statistics',
            'offsets',
            'payloads',
            'positions',
            'preference',
            'realtime',
            'routing',
            'term_statistics',
            'version',
            'version_type'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=mtermvectors.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/nodes.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Nodes {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'nodes.clear_repositories_metering_archive': {
                path: [
                    'node_id',
                    'max_archive_version'
                ],
                body: [],
                query: []
            },
            'nodes.get_repositories_metering_info': {
                path: [
                    'node_id'
                ],
                body: [],
                query: []
            },
            'nodes.hot_threads': {
                path: [
                    'node_id'
                ],
                body: [],
                query: [
                    'ignore_idle_threads',
                    'interval',
                    'snapshots',
                    'threads',
                    'timeout',
                    'type',
                    'sort'
                ]
            },
            'nodes.info': {
                path: [
                    'node_id',
                    'metric'
                ],
                body: [],
                query: [
                    'flat_settings',
                    'timeout'
                ]
            },
            'nodes.reload_secure_settings': {
                path: [
                    'node_id'
                ],
                body: [
                    'secure_settings_password'
                ],
                query: [
                    'timeout'
                ]
            },
            'nodes.stats': {
                path: [
                    'node_id',
                    'metric',
                    'index_metric'
                ],
                body: [],
                query: [
                    'completion_fields',
                    'fielddata_fields',
                    'fields',
                    'groups',
                    'include_segment_file_sizes',
                    'level',
                    'timeout',
                    'types',
                    'include_unloaded_segments'
                ]
            },
            'nodes.usage': {
                path: [
                    'node_id',
                    'metric'
                ],
                body: [],
                query: [
                    'timeout'
                ]
            }
        };
    }
    async clearRepositoriesMeteringArchive(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['nodes.clear_repositories_metering_archive'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/_repositories_metering/${encodeURIComponent(params.max_archive_version.toString())}`;
        const meta = {
            name: 'nodes.clear_repositories_metering_archive',
            pathParts: {
                node_id: params.node_id,
                max_archive_version: params.max_archive_version
            },
            acceptedParams: [
                'node_id',
                'max_archive_version'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getRepositoriesMeteringInfo(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['nodes.get_repositories_metering_info'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/_repositories_metering`;
        const meta = {
            name: 'nodes.get_repositories_metering_info',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async hotThreads(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['nodes.hot_threads'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/hot_threads`;
        } else {
            method = 'GET';
            path = '/_nodes/hot_threads';
        }
        const meta = {
            name: 'nodes.hot_threads',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id',
                'ignore_idle_threads',
                'interval',
                'snapshots',
                'threads',
                'timeout',
                'type',
                'sort'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async info(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['nodes.info'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null && params.metric != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/${encodeURIComponent(params.metric.toString())}`;
        } else if (params.node_id != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}`;
        } else if (params.metric != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.metric.toString())}`;
        } else {
            method = 'GET';
            path = '/_nodes';
        }
        const meta = {
            name: 'nodes.info',
            pathParts: {
                node_id: params.node_id,
                metric: params.metric
            },
            acceptedParams: [
                'node_id',
                'metric',
                'flat_settings',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async reloadSecureSettings(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['nodes.reload_secure_settings'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null) {
            method = 'POST';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/reload_secure_settings`;
        } else {
            method = 'POST';
            path = '/_nodes/reload_secure_settings';
        }
        const meta = {
            name: 'nodes.reload_secure_settings',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id',
                'secure_settings_password',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['nodes.stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null && params.metric != null && params.index_metric != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index_metric.toString())}`;
        } else if (params.node_id != null && params.metric != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats/${encodeURIComponent(params.metric.toString())}`;
        } else if (params.metric != null && params.index_metric != null) {
            method = 'GET';
            path = `/_nodes/stats/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index_metric.toString())}`;
        } else if (params.node_id != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats`;
        } else if (params.metric != null) {
            method = 'GET';
            path = `/_nodes/stats/${encodeURIComponent(params.metric.toString())}`;
        } else {
            method = 'GET';
            path = '/_nodes/stats';
        }
        const meta = {
            name: 'nodes.stats',
            pathParts: {
                node_id: params.node_id,
                metric: params.metric,
                index_metric: params.index_metric
            },
            acceptedParams: [
                'node_id',
                'metric',
                'index_metric',
                'completion_fields',
                'fielddata_fields',
                'fields',
                'groups',
                'include_segment_file_sizes',
                'level',
                'timeout',
                'types',
                'include_unloaded_segments'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async usage(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['nodes.usage'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null && params.metric != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/usage/${encodeURIComponent(params.metric.toString())}`;
        } else if (params.node_id != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/usage`;
        } else if (params.metric != null) {
            method = 'GET';
            path = `/_nodes/usage/${encodeURIComponent(params.metric.toString())}`;
        } else {
            method = 'GET';
            path = '/_nodes/usage';
        }
        const meta = {
            name: 'nodes.usage',
            pathParts: {
                node_id: params.node_id,
                metric: params.metric
            },
            acceptedParams: [
                'node_id',
                'metric',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Nodes; //# sourceMappingURL=nodes.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/open_point_in_time.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = OpenPointInTimeApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    open_point_in_time: {
        path: [
            'index'
        ],
        body: [
            'index_filter'
        ],
        query: [
            'keep_alive',
            'ignore_unavailable',
            'preference',
            'project_routing',
            'routing',
            'expand_wildcards',
            'allow_partial_search_results',
            'max_concurrent_shard_requests'
        ]
    }
};
async function OpenPointInTimeApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.open_point_in_time;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = 'POST';
    const path = `/${encodeURIComponent(params.index.toString())}/_pit`;
    const meta = {
        name: 'open_point_in_time',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'index_filter',
            'keep_alive',
            'ignore_unavailable',
            'preference',
            'project_routing',
            'routing',
            'expand_wildcards',
            'allow_partial_search_results',
            'max_concurrent_shard_requests'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=open_point_in_time.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/ping.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = PingApi;
const acceptedParams = {
    ping: {
        path: [],
        body: [],
        query: []
    }
};
async function PingApi(params, options) {
    const { path: acceptedPath } = acceptedParams.ping;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'HEAD';
    const path = '/';
    const meta = {
        name: 'ping',
        acceptedParams: []
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=ping.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/profiling.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Profiling {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'profiling.flamegraph': {
                path: [],
                body: [],
                query: []
            },
            'profiling.stacktraces': {
                path: [],
                body: [],
                query: []
            },
            'profiling.status': {
                path: [],
                body: [],
                query: []
            },
            'profiling.topn_functions': {
                path: [],
                body: [],
                query: []
            }
        };
    }
    async flamegraph(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['profiling.flamegraph'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_profiling/flamegraph';
        const meta = {
            name: 'profiling.flamegraph',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stacktraces(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['profiling.stacktraces'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_profiling/stacktraces';
        const meta = {
            name: 'profiling.stacktraces',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async status(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['profiling.status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_profiling/status';
        const meta = {
            name: 'profiling.status',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async topnFunctions(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['profiling.topn_functions'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_profiling/topn/functions';
        const meta = {
            name: 'profiling.topn_functions',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Profiling; //# sourceMappingURL=profiling.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/project.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Project {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'project.tags': {
                path: [],
                body: [],
                query: []
            }
        };
    }
    async tags(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['project.tags'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_project/tags';
        const meta = {
            name: 'project.tags',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Project; //# sourceMappingURL=project.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/put_script.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = PutScriptApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    put_script: {
        path: [
            'id',
            'context'
        ],
        body: [
            'script'
        ],
        query: [
            'context',
            'master_timeout',
            'timeout'
        ]
    }
};
async function PutScriptApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.put_script;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.id != null && params.context != null) {
        method = 'PUT';
        path = `/_scripts/${encodeURIComponent(params.id.toString())}/${encodeURIComponent(params.context.toString())}`;
    } else {
        method = 'PUT';
        path = `/_scripts/${encodeURIComponent(params.id.toString())}`;
    }
    const meta = {
        name: 'put_script',
        pathParts: {
            id: params.id,
            context: params.context
        },
        acceptedParams: [
            'id',
            'context',
            'script',
            'context',
            'master_timeout',
            'timeout'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=put_script.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/query_rules.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class QueryRules {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'query_rules.delete_rule': {
                path: [
                    'ruleset_id',
                    'rule_id'
                ],
                body: [],
                query: []
            },
            'query_rules.delete_ruleset': {
                path: [
                    'ruleset_id'
                ],
                body: [],
                query: []
            },
            'query_rules.get_rule': {
                path: [
                    'ruleset_id',
                    'rule_id'
                ],
                body: [],
                query: []
            },
            'query_rules.get_ruleset': {
                path: [
                    'ruleset_id'
                ],
                body: [],
                query: []
            },
            'query_rules.list_rulesets': {
                path: [],
                body: [],
                query: [
                    'from',
                    'size'
                ]
            },
            'query_rules.put_rule': {
                path: [
                    'ruleset_id',
                    'rule_id'
                ],
                body: [
                    'type',
                    'criteria',
                    'actions',
                    'priority'
                ],
                query: []
            },
            'query_rules.put_ruleset': {
                path: [
                    'ruleset_id'
                ],
                body: [
                    'rules'
                ],
                query: []
            },
            'query_rules.test': {
                path: [
                    'ruleset_id'
                ],
                body: [
                    'match_criteria'
                ],
                query: []
            }
        };
    }
    async deleteRule(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['query_rules.delete_rule'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
            name: 'query_rules.delete_rule',
            pathParts: {
                ruleset_id: params.ruleset_id,
                rule_id: params.rule_id
            },
            acceptedParams: [
                'ruleset_id',
                'rule_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteRuleset(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['query_rules.delete_ruleset'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;
        const meta = {
            name: 'query_rules.delete_ruleset',
            pathParts: {
                ruleset_id: params.ruleset_id
            },
            acceptedParams: [
                'ruleset_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getRule(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['query_rules.get_rule'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
            name: 'query_rules.get_rule',
            pathParts: {
                ruleset_id: params.ruleset_id,
                rule_id: params.rule_id
            },
            acceptedParams: [
                'ruleset_id',
                'rule_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getRuleset(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['query_rules.get_ruleset'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;
        const meta = {
            name: 'query_rules.get_ruleset',
            pathParts: {
                ruleset_id: params.ruleset_id
            },
            acceptedParams: [
                'ruleset_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async listRulesets(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['query_rules.list_rulesets'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_query_rules';
        const meta = {
            name: 'query_rules.list_rulesets',
            acceptedParams: [
                'from',
                'size'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putRule(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['query_rules.put_rule'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
            name: 'query_rules.put_rule',
            pathParts: {
                ruleset_id: params.ruleset_id,
                rule_id: params.rule_id
            },
            acceptedParams: [
                'ruleset_id',
                'rule_id',
                'type',
                'criteria',
                'actions',
                'priority'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putRuleset(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['query_rules.put_ruleset'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;
        const meta = {
            name: 'query_rules.put_ruleset',
            pathParts: {
                ruleset_id: params.ruleset_id
            },
            acceptedParams: [
                'ruleset_id',
                'rules'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async test(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['query_rules.test'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_test`;
        const meta = {
            name: 'query_rules.test',
            pathParts: {
                ruleset_id: params.ruleset_id
            },
            acceptedParams: [
                'ruleset_id',
                'match_criteria'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = QueryRules; //# sourceMappingURL=query_rules.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/rank_eval.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = RankEvalApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    rank_eval: {
        path: [
            'index'
        ],
        body: [
            'requests',
            'metric'
        ],
        query: [
            'allow_no_indices',
            'expand_wildcards',
            'ignore_unavailable',
            'search_type'
        ]
    }
};
async function RankEvalApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.rank_eval;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_rank_eval`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_rank_eval';
    }
    const meta = {
        name: 'rank_eval',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'requests',
            'metric',
            'allow_no_indices',
            'expand_wildcards',
            'ignore_unavailable',
            'search_type'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=rank_eval.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/reindex.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ReindexApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    reindex: {
        path: [],
        body: [
            'conflicts',
            'dest',
            'max_docs',
            'script',
            'size',
            'source'
        ],
        query: [
            'refresh',
            'requests_per_second',
            'scroll',
            'slices',
            'max_docs',
            'timeout',
            'wait_for_active_shards',
            'wait_for_completion',
            'require_alias'
        ]
    }
};
async function ReindexApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.reindex;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = 'POST';
    const path = '/_reindex';
    const meta = {
        name: 'reindex',
        acceptedParams: [
            'conflicts',
            'dest',
            'max_docs',
            'script',
            'size',
            'source',
            'refresh',
            'requests_per_second',
            'scroll',
            'slices',
            'max_docs',
            'timeout',
            'wait_for_active_shards',
            'wait_for_completion',
            'require_alias'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=reindex.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/reindex_rethrottle.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ReindexRethrottleApi;
const acceptedParams = {
    reindex_rethrottle: {
        path: [
            'task_id'
        ],
        body: [],
        query: [
            'requests_per_second'
        ]
    }
};
async function ReindexRethrottleApi(params, options) {
    const { path: acceptedPath } = acceptedParams.reindex_rethrottle;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'POST';
    const path = `/_reindex/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;
    const meta = {
        name: 'reindex_rethrottle',
        pathParts: {
            task_id: params.task_id
        },
        acceptedParams: [
            'task_id',
            'requests_per_second'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=reindex_rethrottle.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/render_search_template.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = RenderSearchTemplateApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    render_search_template: {
        path: [],
        body: [
            'id',
            'file',
            'params',
            'source'
        ],
        query: []
    }
};
async function RenderSearchTemplateApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.render_search_template;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.id != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/_render/template/${encodeURIComponent(params.id.toString())}`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_render/template';
    }
    const meta = {
        name: 'render_search_template',
        pathParts: {
            id: params.id
        },
        acceptedParams: [
            'id',
            'id',
            'file',
            'params',
            'source'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=render_search_template.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/rollup.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Rollup {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'rollup.delete_job': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'rollup.get_jobs': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'rollup.get_rollup_caps': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'rollup.get_rollup_index_caps': {
                path: [
                    'index'
                ],
                body: [],
                query: []
            },
            'rollup.put_job': {
                path: [
                    'id'
                ],
                body: [
                    'cron',
                    'groups',
                    'index_pattern',
                    'metrics',
                    'page_size',
                    'rollup_index',
                    'timeout',
                    'headers'
                ],
                query: []
            },
            'rollup.rollup_search': {
                path: [
                    'index'
                ],
                body: [
                    'aggregations',
                    'aggs',
                    'query',
                    'size'
                ],
                query: [
                    'rest_total_hits_as_int',
                    'typed_keys'
                ]
            },
            'rollup.start_job': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'rollup.stop_job': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'timeout',
                    'wait_for_completion'
                ]
            }
        };
    }
    async deleteJob(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['rollup.delete_job'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'rollup.delete_job',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getJobs(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['rollup.get_jobs'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = 'GET';
            path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;
        } else {
            method = 'GET';
            path = '/_rollup/job';
        }
        const meta = {
            name: 'rollup.get_jobs',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getRollupCaps(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['rollup.get_rollup_caps'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = 'GET';
            path = `/_rollup/data/${encodeURIComponent(params.id.toString())}`;
        } else {
            method = 'GET';
            path = '/_rollup/data';
        }
        const meta = {
            name: 'rollup.get_rollup_caps',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getRollupIndexCaps(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['rollup.get_rollup_index_caps'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_rollup/data`;
        const meta = {
            name: 'rollup.get_rollup_index_caps',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putJob(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['rollup.put_job'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'rollup.put_job',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'cron',
                'groups',
                'index_pattern',
                'metrics',
                'page_size',
                'rollup_index',
                'timeout',
                'headers'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async rollupSearch(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['rollup.rollup_search'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = `/${encodeURIComponent(params.index.toString())}/_rollup_search`;
        const meta = {
            name: 'rollup.rollup_search',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'aggregations',
                'aggs',
                'query',
                'size',
                'rest_total_hits_as_int',
                'typed_keys'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async startJob(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['rollup.start_job'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}/_start`;
        const meta = {
            name: 'rollup.start_job',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stopJob(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['rollup.stop_job'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}/_stop`;
        const meta = {
            name: 'rollup.stop_job',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'timeout',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Rollup; //# sourceMappingURL=rollup.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/scripts_painless_execute.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ScriptsPainlessExecuteApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    scripts_painless_execute: {
        path: [],
        body: [
            'context',
            'context_setup',
            'script'
        ],
        query: []
    }
};
async function ScriptsPainlessExecuteApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.scripts_painless_execute;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = body != null ? 'POST' : 'GET';
    const path = '/_scripts/painless/_execute';
    const meta = {
        name: 'scripts_painless_execute',
        acceptedParams: [
            'context',
            'context_setup',
            'script'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=scripts_painless_execute.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/scroll.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ScrollApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    scroll: {
        path: [],
        body: [
            'scroll',
            'scroll_id'
        ],
        query: [
            'scroll',
            'scroll_id',
            'rest_total_hits_as_int'
        ]
    }
};
async function ScrollApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.scroll;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = body != null ? 'POST' : 'GET';
    const path = '/_search/scroll';
    const meta = {
        name: 'scroll',
        pathParts: {
            scroll_id: params.scroll_id
        },
        acceptedParams: [
            'scroll_id',
            'scroll',
            'scroll_id',
            'scroll',
            'scroll_id',
            'rest_total_hits_as_int'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=scroll.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/search.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = SearchApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    search: {
        path: [
            'index'
        ],
        body: [
            'aggregations',
            'aggs',
            'collapse',
            'explain',
            'ext',
            'from',
            'highlight',
            'track_total_hits',
            'indices_boost',
            'docvalue_fields',
            'knn',
            'rank',
            'min_score',
            'post_filter',
            'profile',
            'query',
            'rescore',
            'retriever',
            'script_fields',
            'search_after',
            'size',
            'slice',
            'sort',
            '_source',
            'fields',
            'suggest',
            'terminate_after',
            'timeout',
            'track_scores',
            'version',
            'seq_no_primary_term',
            'stored_fields',
            'pit',
            'runtime_mappings',
            'stats'
        ],
        query: [
            'allow_no_indices',
            'allow_partial_search_results',
            'analyzer',
            'analyze_wildcard',
            'batched_reduce_size',
            'ccs_minimize_roundtrips',
            'default_operator',
            'df',
            'docvalue_fields',
            'expand_wildcards',
            'explain',
            'ignore_throttled',
            'ignore_unavailable',
            'include_named_queries_score',
            'lenient',
            'max_concurrent_shard_requests',
            'preference',
            'pre_filter_shard_size',
            'project_routing',
            'request_cache',
            'routing',
            'scroll',
            'search_type',
            'stats',
            'stored_fields',
            'suggest_field',
            'suggest_mode',
            'suggest_size',
            'suggest_text',
            'terminate_after',
            'timeout',
            'track_total_hits',
            'track_scores',
            'typed_keys',
            'rest_total_hits_as_int',
            'version',
            '_source',
            '_source_excludes',
            '_source_exclude_vectors',
            '_source_includes',
            'seq_no_primary_term',
            'q',
            'size',
            'from',
            'sort',
            'force_synthetic_source'
        ]
    }
};
async function SearchApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.search;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            if (key === 'sort' && typeof params[key] === 'string' && params[key].includes(':')) {
                querystring[key] = params[key];
            } else {
                // @ts-expect-error
                body[key] = params[key];
            }
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_search`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_search';
    }
    const meta = {
        name: 'search',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'aggregations',
            'aggs',
            'collapse',
            'explain',
            'ext',
            'from',
            'highlight',
            'track_total_hits',
            'indices_boost',
            'docvalue_fields',
            'knn',
            'rank',
            'min_score',
            'post_filter',
            'profile',
            'query',
            'rescore',
            'retriever',
            'script_fields',
            'search_after',
            'size',
            'slice',
            'sort',
            '_source',
            'fields',
            'suggest',
            'terminate_after',
            'timeout',
            'track_scores',
            'version',
            'seq_no_primary_term',
            'stored_fields',
            'pit',
            'runtime_mappings',
            'stats',
            'allow_no_indices',
            'allow_partial_search_results',
            'analyzer',
            'analyze_wildcard',
            'batched_reduce_size',
            'ccs_minimize_roundtrips',
            'default_operator',
            'df',
            'docvalue_fields',
            'expand_wildcards',
            'explain',
            'ignore_throttled',
            'ignore_unavailable',
            'include_named_queries_score',
            'lenient',
            'max_concurrent_shard_requests',
            'preference',
            'pre_filter_shard_size',
            'project_routing',
            'request_cache',
            'routing',
            'scroll',
            'search_type',
            'stats',
            'stored_fields',
            'suggest_field',
            'suggest_mode',
            'suggest_size',
            'suggest_text',
            'terminate_after',
            'timeout',
            'track_total_hits',
            'track_scores',
            'typed_keys',
            'rest_total_hits_as_int',
            'version',
            '_source',
            '_source_excludes',
            '_source_exclude_vectors',
            '_source_includes',
            'seq_no_primary_term',
            'q',
            'size',
            'from',
            'sort',
            'force_synthetic_source'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=search.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/search_application.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class SearchApplication {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'search_application.delete': {
                path: [
                    'name'
                ],
                body: [],
                query: []
            },
            'search_application.delete_behavioral_analytics': {
                path: [
                    'name'
                ],
                body: [],
                query: []
            },
            'search_application.get': {
                path: [
                    'name'
                ],
                body: [],
                query: []
            },
            'search_application.get_behavioral_analytics': {
                path: [
                    'name'
                ],
                body: [],
                query: []
            },
            'search_application.list': {
                path: [],
                body: [],
                query: [
                    'q',
                    'from',
                    'size'
                ]
            },
            'search_application.post_behavioral_analytics_event': {
                path: [
                    'collection_name',
                    'event_type'
                ],
                body: [
                    'payload'
                ],
                query: [
                    'debug'
                ]
            },
            'search_application.put': {
                path: [
                    'name'
                ],
                body: [
                    'search_application'
                ],
                query: [
                    'create'
                ]
            },
            'search_application.put_behavioral_analytics': {
                path: [
                    'name'
                ],
                body: [],
                query: []
            },
            'search_application.render_query': {
                path: [
                    'name'
                ],
                body: [
                    'params'
                ],
                query: []
            },
            'search_application.search': {
                path: [
                    'name'
                ],
                body: [
                    'params'
                ],
                query: [
                    'typed_keys'
                ]
            }
        };
    }
    async delete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['search_application.delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'search_application.delete',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteBehavioralAnalytics(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['search_application.delete_behavioral_analytics'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'search_application.delete_behavioral_analytics',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async get(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['search_application.get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'search_application.get',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getBehavioralAnalytics(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['search_application.get_behavioral_analytics'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_application/analytics';
        }
        const meta = {
            name: 'search_application.get_behavioral_analytics',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async list(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['search_application.list'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_application/search_application';
        const meta = {
            name: 'search_application.list',
            acceptedParams: [
                'q',
                'from',
                'size'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async postBehavioralAnalyticsEvent(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['search_application.post_behavioral_analytics_event'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_application/analytics/${encodeURIComponent(params.collection_name.toString())}/event/${encodeURIComponent(params.event_type.toString())}`;
        const meta = {
            name: 'search_application.post_behavioral_analytics_event',
            pathParts: {
                collection_name: params.collection_name,
                event_type: params.event_type
            },
            acceptedParams: [
                'collection_name',
                'event_type',
                'payload',
                'debug'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async put(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['search_application.put'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'search_application.put',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'search_application',
                'create'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putBehavioralAnalytics(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['search_application.put_behavioral_analytics'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'search_application.put_behavioral_analytics',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async renderQuery(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['search_application.render_query'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}/_render_query`;
        const meta = {
            name: 'search_application.render_query',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'params'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async search(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['search_application.search'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}/_search`;
        const meta = {
            name: 'search_application.search',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'name',
                'params',
                'typed_keys'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = SearchApplication; //# sourceMappingURL=search_application.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/search_mvt.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = SearchMvtApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    search_mvt: {
        path: [
            'index',
            'field',
            'zoom',
            'x',
            'y'
        ],
        body: [
            'aggs',
            'buffer',
            'exact_bounds',
            'extent',
            'fields',
            'grid_agg',
            'grid_precision',
            'grid_type',
            'query',
            'runtime_mappings',
            'size',
            'sort',
            'track_total_hits',
            'with_labels'
        ],
        query: [
            'exact_bounds',
            'extent',
            'grid_agg',
            'grid_precision',
            'grid_type',
            'project_routing',
            'size',
            'track_total_hits',
            'with_labels'
        ]
    }
};
async function SearchMvtApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.search_mvt;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = body != null ? 'POST' : 'GET';
    const path = `/${encodeURIComponent(params.index.toString())}/_mvt/${encodeURIComponent(params.field.toString())}/${encodeURIComponent(params.zoom.toString())}/${encodeURIComponent(params.x.toString())}/${encodeURIComponent(params.y.toString())}`;
    const meta = {
        name: 'search_mvt',
        pathParts: {
            index: params.index,
            field: params.field,
            zoom: params.zoom,
            x: params.x,
            y: params.y
        },
        acceptedParams: [
            'index',
            'field',
            'zoom',
            'x',
            'y',
            'aggs',
            'buffer',
            'exact_bounds',
            'extent',
            'fields',
            'grid_agg',
            'grid_precision',
            'grid_type',
            'query',
            'runtime_mappings',
            'size',
            'sort',
            'track_total_hits',
            'with_labels',
            'exact_bounds',
            'extent',
            'grid_agg',
            'grid_precision',
            'grid_type',
            'project_routing',
            'size',
            'track_total_hits',
            'with_labels'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=search_mvt.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/search_shards.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = SearchShardsApi;
const acceptedParams = {
    search_shards: {
        path: [
            'index'
        ],
        body: [],
        query: [
            'allow_no_indices',
            'expand_wildcards',
            'ignore_unavailable',
            'local',
            'master_timeout',
            'preference',
            'routing'
        ]
    }
};
async function SearchShardsApi(params, options) {
    const { path: acceptedPath } = acceptedParams.search_shards;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_search_shards`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_search_shards';
    }
    const meta = {
        name: 'search_shards',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'allow_no_indices',
            'expand_wildcards',
            'ignore_unavailable',
            'local',
            'master_timeout',
            'preference',
            'routing'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=search_shards.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/search_template.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = SearchTemplateApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    search_template: {
        path: [
            'index'
        ],
        body: [
            'explain',
            'id',
            'params',
            'profile',
            'source'
        ],
        query: [
            'allow_no_indices',
            'ccs_minimize_roundtrips',
            'expand_wildcards',
            'explain',
            'ignore_throttled',
            'ignore_unavailable',
            'preference',
            'profile',
            'project_routing',
            'routing',
            'scroll',
            'search_type',
            'rest_total_hits_as_int',
            'typed_keys'
        ]
    }
};
async function SearchTemplateApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.search_template;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    params = params !== null && params !== void 0 ? params : {};
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_search/template`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = '/_search/template';
    }
    const meta = {
        name: 'search_template',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'explain',
            'id',
            'params',
            'profile',
            'source',
            'allow_no_indices',
            'ccs_minimize_roundtrips',
            'expand_wildcards',
            'explain',
            'ignore_throttled',
            'ignore_unavailable',
            'preference',
            'profile',
            'project_routing',
            'routing',
            'scroll',
            'search_type',
            'rest_total_hits_as_int',
            'typed_keys'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=search_template.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/searchable_snapshots.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class SearchableSnapshots {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'searchable_snapshots.cache_stats': {
                path: [
                    'node_id'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'searchable_snapshots.clear_cache': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'expand_wildcards',
                    'allow_no_indices',
                    'ignore_unavailable'
                ]
            },
            'searchable_snapshots.mount': {
                path: [
                    'repository',
                    'snapshot'
                ],
                body: [
                    'index',
                    'renamed_index',
                    'index_settings',
                    'ignore_index_settings'
                ],
                query: [
                    'master_timeout',
                    'wait_for_completion',
                    'storage'
                ]
            },
            'searchable_snapshots.stats': {
                path: [
                    'index'
                ],
                body: [],
                query: [
                    'level'
                ]
            }
        };
    }
    async cacheStats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['searchable_snapshots.cache_stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null) {
            method = 'GET';
            path = `/_searchable_snapshots/${encodeURIComponent(params.node_id.toString())}/cache/stats`;
        } else {
            method = 'GET';
            path = '/_searchable_snapshots/cache/stats';
        }
        const meta = {
            name: 'searchable_snapshots.cache_stats',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async clearCache(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['searchable_snapshots.clear_cache'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'POST';
            path = `/${encodeURIComponent(params.index.toString())}/_searchable_snapshots/cache/clear`;
        } else {
            method = 'POST';
            path = '/_searchable_snapshots/cache/clear';
        }
        const meta = {
            name: 'searchable_snapshots.clear_cache',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'expand_wildcards',
                'allow_no_indices',
                'ignore_unavailable'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async mount(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['searchable_snapshots.mount'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_mount`;
        const meta = {
            name: 'searchable_snapshots.mount',
            pathParts: {
                repository: params.repository,
                snapshot: params.snapshot
            },
            acceptedParams: [
                'repository',
                'snapshot',
                'index',
                'renamed_index',
                'index_settings',
                'ignore_index_settings',
                'master_timeout',
                'wait_for_completion',
                'storage'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['searchable_snapshots.stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = 'GET';
            path = `/${encodeURIComponent(params.index.toString())}/_searchable_snapshots/stats`;
        } else {
            method = 'GET';
            path = '/_searchable_snapshots/stats';
        }
        const meta = {
            name: 'searchable_snapshots.stats',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'level'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = SearchableSnapshots; //# sourceMappingURL=searchable_snapshots.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/shutdown.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Shutdown {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'shutdown.delete_node': {
                path: [
                    'node_id'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'shutdown.get_node': {
                path: [
                    'node_id'
                ],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'shutdown.put_node': {
                path: [
                    'node_id'
                ],
                body: [
                    'type',
                    'reason',
                    'allocation_delay',
                    'target_node_name'
                ],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            }
        };
    }
    async deleteNode(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['shutdown.delete_node'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;
        const meta = {
            name: 'shutdown.delete_node',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getNode(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['shutdown.get_node'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.node_id != null) {
            method = 'GET';
            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;
        } else {
            method = 'GET';
            path = '/_nodes/shutdown';
        }
        const meta = {
            name: 'shutdown.get_node',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putNode(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['shutdown.put_node'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;
        const meta = {
            name: 'shutdown.put_node',
            pathParts: {
                node_id: params.node_id
            },
            acceptedParams: [
                'node_id',
                'type',
                'reason',
                'allocation_delay',
                'target_node_name',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Shutdown; //# sourceMappingURL=shutdown.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/simulate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Simulate {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'simulate.ingest': {
                path: [
                    'index'
                ],
                body: [
                    'docs',
                    'component_template_substitutions',
                    'index_template_substitutions',
                    'mapping_addition',
                    'pipeline_substitutions'
                ],
                query: [
                    'pipeline',
                    'merge_type'
                ]
            }
        };
    }
    async ingest(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['simulate.ingest'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.index != null) {
            method = body != null ? 'POST' : 'GET';
            path = `/_ingest/${encodeURIComponent(params.index.toString())}/_simulate`;
        } else {
            method = body != null ? 'POST' : 'GET';
            path = '/_ingest/_simulate';
        }
        const meta = {
            name: 'simulate.ingest',
            pathParts: {
                index: params.index
            },
            acceptedParams: [
                'index',
                'docs',
                'component_template_substitutions',
                'index_template_substitutions',
                'mapping_addition',
                'pipeline_substitutions',
                'pipeline',
                'merge_type'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Simulate; //# sourceMappingURL=simulate.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/slm.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Slm {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'slm.delete_lifecycle': {
                path: [
                    'policy_id'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'slm.execute_lifecycle': {
                path: [
                    'policy_id'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'slm.execute_retention': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'slm.get_lifecycle': {
                path: [
                    'policy_id'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'slm.get_stats': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'slm.get_status': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'slm.put_lifecycle': {
                path: [
                    'policy_id'
                ],
                body: [
                    'config',
                    'name',
                    'repository',
                    'retention',
                    'schedule'
                ],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'slm.start': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'slm.stop': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            }
        };
    }
    async deleteLifecycle(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['slm.delete_lifecycle'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;
        const meta = {
            name: 'slm.delete_lifecycle',
            pathParts: {
                policy_id: params.policy_id
            },
            acceptedParams: [
                'policy_id',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async executeLifecycle(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['slm.execute_lifecycle'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}/_execute`;
        const meta = {
            name: 'slm.execute_lifecycle',
            pathParts: {
                policy_id: params.policy_id
            },
            acceptedParams: [
                'policy_id',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async executeRetention(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['slm.execute_retention'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_slm/_execute_retention';
        const meta = {
            name: 'slm.execute_retention',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getLifecycle(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['slm.get_lifecycle'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.policy_id != null) {
            method = 'GET';
            path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_slm/policy';
        }
        const meta = {
            name: 'slm.get_lifecycle',
            pathParts: {
                policy_id: params.policy_id
            },
            acceptedParams: [
                'policy_id',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getStats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['slm.get_stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_slm/stats';
        const meta = {
            name: 'slm.get_stats',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getStatus(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['slm.get_status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_slm/status';
        const meta = {
            name: 'slm.get_status',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putLifecycle(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['slm.put_lifecycle'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;
        const meta = {
            name: 'slm.put_lifecycle',
            pathParts: {
                policy_id: params.policy_id
            },
            acceptedParams: [
                'policy_id',
                'config',
                'name',
                'repository',
                'retention',
                'schedule',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async start(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['slm.start'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_slm/start';
        const meta = {
            name: 'slm.start',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stop(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['slm.stop'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_slm/stop';
        const meta = {
            name: 'slm.stop',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Slm; //# sourceMappingURL=slm.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/snapshot.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Snapshot {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'snapshot.cleanup_repository': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'snapshot.clone': {
                path: [
                    'repository',
                    'snapshot',
                    'target_snapshot'
                ],
                body: [
                    'indices'
                ],
                query: [
                    'master_timeout'
                ]
            },
            'snapshot.create': {
                path: [
                    'repository',
                    'snapshot'
                ],
                body: [
                    'expand_wildcards',
                    'feature_states',
                    'ignore_unavailable',
                    'include_global_state',
                    'indices',
                    'metadata',
                    'partial'
                ],
                query: [
                    'master_timeout',
                    'wait_for_completion'
                ]
            },
            'snapshot.create_repository': {
                path: [
                    'name'
                ],
                body: [
                    'repository'
                ],
                query: [
                    'master_timeout',
                    'timeout',
                    'verify'
                ]
            },
            'snapshot.delete': {
                path: [
                    'repository',
                    'snapshot'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'wait_for_completion'
                ]
            },
            'snapshot.delete_repository': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'snapshot.get': {
                path: [
                    'repository',
                    'snapshot'
                ],
                body: [],
                query: [
                    'after',
                    'from_sort_value',
                    'ignore_unavailable',
                    'index_details',
                    'index_names',
                    'include_repository',
                    'master_timeout',
                    'order',
                    'offset',
                    'size',
                    'slm_policy_filter',
                    'sort',
                    'state',
                    'verbose'
                ]
            },
            'snapshot.get_repository': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'local',
                    'master_timeout'
                ]
            },
            'snapshot.repository_analyze': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'blob_count',
                    'concurrency',
                    'detailed',
                    'early_read_node_count',
                    'max_blob_size',
                    'max_total_data_size',
                    'rare_action_probability',
                    'rarely_abort_writes',
                    'read_node_count',
                    'register_operation_count',
                    'seed',
                    'timeout'
                ]
            },
            'snapshot.repository_verify_integrity': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'blob_thread_pool_concurrency',
                    'index_snapshot_verification_concurrency',
                    'index_verification_concurrency',
                    'max_bytes_per_sec',
                    'max_failed_shard_snapshots',
                    'meta_thread_pool_concurrency',
                    'snapshot_verification_concurrency',
                    'verify_blob_contents'
                ]
            },
            'snapshot.restore': {
                path: [
                    'repository',
                    'snapshot'
                ],
                body: [
                    'feature_states',
                    'ignore_index_settings',
                    'ignore_unavailable',
                    'include_aliases',
                    'include_global_state',
                    'index_settings',
                    'indices',
                    'partial',
                    'rename_pattern',
                    'rename_replacement'
                ],
                query: [
                    'master_timeout',
                    'wait_for_completion'
                ]
            },
            'snapshot.status': {
                path: [
                    'repository',
                    'snapshot'
                ],
                body: [],
                query: [
                    'ignore_unavailable',
                    'master_timeout'
                ]
            },
            'snapshot.verify_repository': {
                path: [
                    'name'
                ],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            }
        };
    }
    async cleanupRepository(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.cleanup_repository'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_cleanup`;
        const meta = {
            name: 'snapshot.cleanup_repository',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'repository',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async clone(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['snapshot.clone'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_clone/${encodeURIComponent(params.target_snapshot.toString())}`;
        const meta = {
            name: 'snapshot.clone',
            pathParts: {
                repository: params.repository,
                snapshot: params.snapshot,
                target_snapshot: params.target_snapshot
            },
            acceptedParams: [
                'repository',
                'snapshot',
                'target_snapshot',
                'indices',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async create(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['snapshot.create'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;
        const meta = {
            name: 'snapshot.create',
            pathParts: {
                repository: params.repository,
                snapshot: params.snapshot
            },
            acceptedParams: [
                'repository',
                'snapshot',
                'expand_wildcards',
                'feature_states',
                'ignore_unavailable',
                'include_global_state',
                'indices',
                'metadata',
                'partial',
                'master_timeout',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async createRepository(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['snapshot.create_repository'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'snapshot.create_repository',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'repository',
                'repository',
                'master_timeout',
                'timeout',
                'verify'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async delete(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.delete'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;
        const meta = {
            name: 'snapshot.delete',
            pathParts: {
                repository: params.repository,
                snapshot: params.snapshot
            },
            acceptedParams: [
                'repository',
                'snapshot',
                'master_timeout',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteRepository(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.delete_repository'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;
        const meta = {
            name: 'snapshot.delete_repository',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'repository',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async get(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;
        const meta = {
            name: 'snapshot.get',
            pathParts: {
                repository: params.repository,
                snapshot: params.snapshot
            },
            acceptedParams: [
                'repository',
                'snapshot',
                'after',
                'from_sort_value',
                'ignore_unavailable',
                'index_details',
                'index_names',
                'include_repository',
                'master_timeout',
                'order',
                'offset',
                'size',
                'slm_policy_filter',
                'sort',
                'state',
                'verbose'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getRepository(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.get_repository'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.name != null) {
            method = 'GET';
            path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;
        } else {
            method = 'GET';
            path = '/_snapshot';
        }
        const meta = {
            name: 'snapshot.get_repository',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'repository',
                'local',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async repositoryAnalyze(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.repository_analyze'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_analyze`;
        const meta = {
            name: 'snapshot.repository_analyze',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'repository',
                'blob_count',
                'concurrency',
                'detailed',
                'early_read_node_count',
                'max_blob_size',
                'max_total_data_size',
                'rare_action_probability',
                'rarely_abort_writes',
                'read_node_count',
                'register_operation_count',
                'seed',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async repositoryVerifyIntegrity(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.repository_verify_integrity'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_verify_integrity`;
        const meta = {
            name: 'snapshot.repository_verify_integrity',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'repository',
                'blob_thread_pool_concurrency',
                'index_snapshot_verification_concurrency',
                'index_verification_concurrency',
                'max_bytes_per_sec',
                'max_failed_shard_snapshots',
                'meta_thread_pool_concurrency',
                'snapshot_verification_concurrency',
                'verify_blob_contents'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async restore(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['snapshot.restore'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_restore`;
        const meta = {
            name: 'snapshot.restore',
            pathParts: {
                repository: params.repository,
                snapshot: params.snapshot
            },
            acceptedParams: [
                'repository',
                'snapshot',
                'feature_states',
                'ignore_index_settings',
                'ignore_unavailable',
                'include_aliases',
                'include_global_state',
                'index_settings',
                'indices',
                'partial',
                'rename_pattern',
                'rename_replacement',
                'master_timeout',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async status(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.repository != null && params.snapshot != null) {
            method = 'GET';
            path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_status`;
        } else if (params.repository != null) {
            method = 'GET';
            path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/_status`;
        } else {
            method = 'GET';
            path = '/_snapshot/_status';
        }
        const meta = {
            name: 'snapshot.status',
            pathParts: {
                repository: params.repository,
                snapshot: params.snapshot
            },
            acceptedParams: [
                'repository',
                'snapshot',
                'ignore_unavailable',
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async verifyRepository(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['snapshot.verify_repository'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_verify`;
        const meta = {
            name: 'snapshot.verify_repository',
            pathParts: {
                name: params.name
            },
            acceptedParams: [
                'repository',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Snapshot; //# sourceMappingURL=snapshot.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/sql.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Sql {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'sql.clear_cursor': {
                path: [],
                body: [
                    'cursor'
                ],
                query: []
            },
            'sql.delete_async': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'sql.get_async': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'delimiter',
                    'format',
                    'keep_alive',
                    'wait_for_completion_timeout'
                ]
            },
            'sql.get_async_status': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'sql.query': {
                path: [],
                body: [
                    'allow_partial_search_results',
                    'catalog',
                    'columnar',
                    'cursor',
                    'fetch_size',
                    'field_multi_value_leniency',
                    'filter',
                    'index_using_frozen',
                    'keep_alive',
                    'keep_on_completion',
                    'page_timeout',
                    'params',
                    'query',
                    'request_timeout',
                    'runtime_mappings',
                    'time_zone',
                    'wait_for_completion_timeout'
                ],
                query: [
                    'format',
                    'project_routing'
                ]
            },
            'sql.translate': {
                path: [],
                body: [
                    'fetch_size',
                    'filter',
                    'query',
                    'time_zone'
                ],
                query: []
            }
        };
    }
    async clearCursor(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['sql.clear_cursor'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_sql/close';
        const meta = {
            name: 'sql.clear_cursor',
            acceptedParams: [
                'cursor'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteAsync(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['sql.delete_async'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_sql/async/delete/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'sql.delete_async',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getAsync(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['sql.get_async'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_sql/async/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'sql.get_async',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'delimiter',
                'format',
                'keep_alive',
                'wait_for_completion_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getAsyncStatus(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['sql.get_async_status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_sql/async/status/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'sql.get_async_status',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async query(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['sql.query'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = '/_sql';
        const meta = {
            name: 'sql.query',
            acceptedParams: [
                'allow_partial_search_results',
                'catalog',
                'columnar',
                'cursor',
                'fetch_size',
                'field_multi_value_leniency',
                'filter',
                'index_using_frozen',
                'keep_alive',
                'keep_on_completion',
                'page_timeout',
                'params',
                'query',
                'request_timeout',
                'runtime_mappings',
                'time_zone',
                'wait_for_completion_timeout',
                'format',
                'project_routing'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async translate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['sql.translate'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = '/_sql/translate';
        const meta = {
            name: 'sql.translate',
            acceptedParams: [
                'fetch_size',
                'filter',
                'query',
                'time_zone'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Sql; //# sourceMappingURL=sql.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/ssl.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Ssl {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'ssl.certificates': {
                path: [],
                body: [],
                query: []
            }
        };
    }
    async certificates(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['ssl.certificates'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_ssl/certificates';
        const meta = {
            name: 'ssl.certificates',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Ssl; //# sourceMappingURL=ssl.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/streams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Streams {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'streams.logs_disable': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'streams.logs_enable': {
                path: [],
                body: [],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            },
            'streams.status': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            }
        };
    }
    async logsDisable(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['streams.logs_disable'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_streams/logs/_disable';
        const meta = {
            name: 'streams.logs_disable',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async logsEnable(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['streams.logs_enable'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_streams/logs/_enable';
        const meta = {
            name: 'streams.logs_enable',
            acceptedParams: [
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async status(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['streams.status'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_streams/status';
        const meta = {
            name: 'streams.status',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Streams; //# sourceMappingURL=streams.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/synonyms.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Synonyms {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'synonyms.delete_synonym': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'synonyms.delete_synonym_rule': {
                path: [
                    'set_id',
                    'rule_id'
                ],
                body: [],
                query: [
                    'refresh'
                ]
            },
            'synonyms.get_synonym': {
                path: [
                    'id'
                ],
                body: [],
                query: [
                    'from',
                    'size'
                ]
            },
            'synonyms.get_synonym_rule': {
                path: [
                    'set_id',
                    'rule_id'
                ],
                body: [],
                query: []
            },
            'synonyms.get_synonyms_sets': {
                path: [],
                body: [],
                query: [
                    'from',
                    'size'
                ]
            },
            'synonyms.put_synonym': {
                path: [
                    'id'
                ],
                body: [
                    'synonyms_set'
                ],
                query: [
                    'refresh'
                ]
            },
            'synonyms.put_synonym_rule': {
                path: [
                    'set_id',
                    'rule_id'
                ],
                body: [
                    'synonyms'
                ],
                query: [
                    'refresh'
                ]
            }
        };
    }
    async deleteSynonym(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['synonyms.delete_synonym'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'synonyms.delete_synonym',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteSynonymRule(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['synonyms.delete_synonym_rule'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
            name: 'synonyms.delete_synonym_rule',
            pathParts: {
                set_id: params.set_id,
                rule_id: params.rule_id
            },
            acceptedParams: [
                'set_id',
                'rule_id',
                'refresh'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getSynonym(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['synonyms.get_synonym'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'synonyms.get_synonym',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'from',
                'size'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getSynonymRule(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['synonyms.get_synonym_rule'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
            name: 'synonyms.get_synonym_rule',
            pathParts: {
                set_id: params.set_id,
                rule_id: params.rule_id
            },
            acceptedParams: [
                'set_id',
                'rule_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getSynonymsSets(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['synonyms.get_synonyms_sets'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_synonyms';
        const meta = {
            name: 'synonyms.get_synonyms_sets',
            acceptedParams: [
                'from',
                'size'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putSynonym(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['synonyms.put_synonym'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'synonyms.put_synonym',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'synonyms_set',
                'refresh'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putSynonymRule(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['synonyms.put_synonym_rule'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
            name: 'synonyms.put_synonym_rule',
            pathParts: {
                set_id: params.set_id,
                rule_id: params.rule_id
            },
            acceptedParams: [
                'set_id',
                'rule_id',
                'synonyms',
                'refresh'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Synonyms; //# sourceMappingURL=synonyms.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/tasks.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Tasks {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'tasks.cancel': {
                path: [
                    'task_id'
                ],
                body: [],
                query: [
                    'actions',
                    'nodes',
                    'parent_task_id',
                    'wait_for_completion'
                ]
            },
            'tasks.get': {
                path: [
                    'task_id'
                ],
                body: [],
                query: [
                    'timeout',
                    'wait_for_completion'
                ]
            },
            'tasks.list': {
                path: [],
                body: [],
                query: [
                    'actions',
                    'detailed',
                    'group_by',
                    'nodes',
                    'parent_task_id',
                    'timeout',
                    'wait_for_completion'
                ]
            }
        };
    }
    async cancel(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['tasks.cancel'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.task_id != null) {
            method = 'POST';
            path = `/_tasks/${encodeURIComponent(params.task_id.toString())}/_cancel`;
        } else {
            method = 'POST';
            path = '/_tasks/_cancel';
        }
        const meta = {
            name: 'tasks.cancel',
            pathParts: {
                task_id: params.task_id
            },
            acceptedParams: [
                'task_id',
                'actions',
                'nodes',
                'parent_task_id',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async get(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['tasks.get'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_tasks/${encodeURIComponent(params.task_id.toString())}`;
        const meta = {
            name: 'tasks.get',
            pathParts: {
                task_id: params.task_id
            },
            acceptedParams: [
                'task_id',
                'timeout',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async list(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['tasks.list'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_tasks';
        const meta = {
            name: 'tasks.list',
            acceptedParams: [
                'actions',
                'detailed',
                'group_by',
                'nodes',
                'parent_task_id',
                'timeout',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Tasks; //# sourceMappingURL=tasks.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/terms_enum.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = TermsEnumApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    terms_enum: {
        path: [
            'index'
        ],
        body: [
            'field',
            'size',
            'timeout',
            'case_insensitive',
            'index_filter',
            'string',
            'search_after'
        ],
        query: []
    }
};
async function TermsEnumApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.terms_enum;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = body != null ? 'POST' : 'GET';
    const path = `/${encodeURIComponent(params.index.toString())}/_terms_enum`;
    const meta = {
        name: 'terms_enum',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'field',
            'size',
            'timeout',
            'case_insensitive',
            'index_filter',
            'string',
            'search_after'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=terms_enum.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/termvectors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = TermvectorsApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    termvectors: {
        path: [
            'index',
            'id'
        ],
        body: [
            'doc',
            'filter',
            'per_field_analyzer',
            'fields',
            'field_statistics',
            'offsets',
            'payloads',
            'positions',
            'term_statistics',
            'routing',
            'version',
            'version_type'
        ],
        query: [
            'fields',
            'field_statistics',
            'offsets',
            'payloads',
            'positions',
            'preference',
            'realtime',
            'routing',
            'term_statistics',
            'version',
            'version_type'
        ]
    }
};
async function TermvectorsApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.termvectors;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    let method = '';
    let path = '';
    if (params.index != null && params.id != null) {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_termvectors/${encodeURIComponent(params.id.toString())}`;
    } else {
        method = body != null ? 'POST' : 'GET';
        path = `/${encodeURIComponent(params.index.toString())}/_termvectors`;
    }
    const meta = {
        name: 'termvectors',
        pathParts: {
            index: params.index,
            id: params.id
        },
        acceptedParams: [
            'index',
            'id',
            'doc',
            'filter',
            'per_field_analyzer',
            'fields',
            'field_statistics',
            'offsets',
            'payloads',
            'positions',
            'term_statistics',
            'routing',
            'version',
            'version_type',
            'fields',
            'field_statistics',
            'offsets',
            'payloads',
            'positions',
            'preference',
            'realtime',
            'routing',
            'term_statistics',
            'version',
            'version_type'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=termvectors.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/text_structure.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class TextStructure {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'text_structure.find_field_structure': {
                path: [],
                body: [],
                query: [
                    'column_names',
                    'delimiter',
                    'documents_to_sample',
                    'ecs_compatibility',
                    'explain',
                    'field',
                    'format',
                    'grok_pattern',
                    'index',
                    'quote',
                    'should_trim_fields',
                    'timeout',
                    'timestamp_field',
                    'timestamp_format'
                ]
            },
            'text_structure.find_message_structure': {
                path: [],
                body: [
                    'messages'
                ],
                query: [
                    'column_names',
                    'delimiter',
                    'ecs_compatibility',
                    'explain',
                    'format',
                    'grok_pattern',
                    'quote',
                    'should_trim_fields',
                    'timeout',
                    'timestamp_field',
                    'timestamp_format'
                ]
            },
            'text_structure.find_structure': {
                path: [],
                body: [
                    'text_files'
                ],
                query: [
                    'charset',
                    'column_names',
                    'delimiter',
                    'ecs_compatibility',
                    'explain',
                    'format',
                    'grok_pattern',
                    'has_header_row',
                    'line_merge_size_limit',
                    'lines_to_sample',
                    'quote',
                    'should_trim_fields',
                    'timeout',
                    'timestamp_field',
                    'timestamp_format'
                ]
            },
            'text_structure.test_grok_pattern': {
                path: [],
                body: [
                    'grok_pattern',
                    'text'
                ],
                query: [
                    'ecs_compatibility'
                ]
            }
        };
    }
    async findFieldStructure(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['text_structure.find_field_structure'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_text_structure/find_field_structure';
        const meta = {
            name: 'text_structure.find_field_structure',
            acceptedParams: [
                'column_names',
                'delimiter',
                'documents_to_sample',
                'ecs_compatibility',
                'explain',
                'field',
                'format',
                'grok_pattern',
                'index',
                'quote',
                'should_trim_fields',
                'timeout',
                'timestamp_field',
                'timestamp_format'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async findMessageStructure(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['text_structure.find_message_structure'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = '/_text_structure/find_message_structure';
        const meta = {
            name: 'text_structure.find_message_structure',
            acceptedParams: [
                'messages',
                'column_names',
                'delimiter',
                'ecs_compatibility',
                'explain',
                'format',
                'grok_pattern',
                'quote',
                'should_trim_fields',
                'timeout',
                'timestamp_field',
                'timestamp_format'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async findStructure(params, options) {
        var _b;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['text_structure.find_structure'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body = (_b = params.body) !== null && _b !== void 0 ? _b : undefined;
        for(const key in params){
            if (acceptedBody.includes(key)) {
                // @ts-expect-error
                body = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = '/_text_structure/find_structure';
        const meta = {
            name: 'text_structure.find_structure',
            acceptedParams: [
                'text_files',
                'charset',
                'column_names',
                'delimiter',
                'ecs_compatibility',
                'explain',
                'format',
                'grok_pattern',
                'has_header_row',
                'line_merge_size_limit',
                'lines_to_sample',
                'quote',
                'should_trim_fields',
                'timeout',
                'timestamp_field',
                'timestamp_format'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            bulkBody: body,
            meta
        }, options);
    }
    async testGrokPattern(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['text_structure.test_grok_pattern'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = '/_text_structure/test_grok_pattern';
        const meta = {
            name: 'text_structure.test_grok_pattern',
            acceptedParams: [
                'grok_pattern',
                'text',
                'ecs_compatibility'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = TextStructure; //# sourceMappingURL=text_structure.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/transform.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Transform {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'transform.delete_transform': {
                path: [
                    'transform_id'
                ],
                body: [],
                query: [
                    'force',
                    'delete_dest_index',
                    'timeout'
                ]
            },
            'transform.get_node_stats': {
                path: [],
                body: [],
                query: []
            },
            'transform.get_transform': {
                path: [
                    'transform_id'
                ],
                body: [],
                query: [
                    'allow_no_match',
                    'from',
                    'size',
                    'exclude_generated'
                ]
            },
            'transform.get_transform_stats': {
                path: [
                    'transform_id'
                ],
                body: [],
                query: [
                    'allow_no_match',
                    'from',
                    'size',
                    'timeout'
                ]
            },
            'transform.preview_transform': {
                path: [
                    'transform_id'
                ],
                body: [
                    'dest',
                    'description',
                    'frequency',
                    'pivot',
                    'source',
                    'settings',
                    'sync',
                    'retention_policy',
                    'latest'
                ],
                query: [
                    'timeout'
                ]
            },
            'transform.put_transform': {
                path: [
                    'transform_id'
                ],
                body: [
                    'dest',
                    'description',
                    'frequency',
                    'latest',
                    '_meta',
                    'pivot',
                    'retention_policy',
                    'settings',
                    'source',
                    'sync'
                ],
                query: [
                    'defer_validation',
                    'timeout'
                ]
            },
            'transform.reset_transform': {
                path: [
                    'transform_id'
                ],
                body: [],
                query: [
                    'force',
                    'timeout'
                ]
            },
            'transform.schedule_now_transform': {
                path: [
                    'transform_id'
                ],
                body: [],
                query: [
                    'timeout'
                ]
            },
            'transform.set_upgrade_mode': {
                path: [],
                body: [],
                query: [
                    'enabled',
                    'timeout'
                ]
            },
            'transform.start_transform': {
                path: [
                    'transform_id'
                ],
                body: [],
                query: [
                    'timeout',
                    'from'
                ]
            },
            'transform.stop_transform': {
                path: [
                    'transform_id'
                ],
                body: [],
                query: [
                    'allow_no_match',
                    'force',
                    'timeout',
                    'wait_for_checkpoint',
                    'wait_for_completion'
                ]
            },
            'transform.update_transform': {
                path: [
                    'transform_id'
                ],
                body: [
                    'dest',
                    'description',
                    'frequency',
                    '_meta',
                    'source',
                    'settings',
                    'sync',
                    'retention_policy'
                ],
                query: [
                    'defer_validation',
                    'timeout'
                ]
            },
            'transform.upgrade_transforms': {
                path: [],
                body: [],
                query: [
                    'dry_run',
                    'timeout'
                ]
            }
        };
    }
    async deleteTransform(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.delete_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;
        const meta = {
            name: 'transform.delete_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'force',
                'delete_dest_index',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getNodeStats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.get_node_stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_transform/_node_stats';
        const meta = {
            name: 'transform.get_node_stats',
            acceptedParams: []
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getTransform(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.get_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.transform_id != null) {
            method = 'GET';
            path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;
        } else {
            method = 'GET';
            path = '/_transform';
        }
        const meta = {
            name: 'transform.get_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'allow_no_match',
                'from',
                'size',
                'exclude_generated'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getTransformStats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.get_transform_stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_stats`;
        const meta = {
            name: 'transform.get_transform_stats',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'allow_no_match',
                'from',
                'size',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async previewTransform(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['transform.preview_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.transform_id != null) {
            method = body != null ? 'POST' : 'GET';
            path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_preview`;
        } else {
            method = body != null ? 'POST' : 'GET';
            path = '/_transform/_preview';
        }
        const meta = {
            name: 'transform.preview_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'dest',
                'description',
                'frequency',
                'pivot',
                'source',
                'settings',
                'sync',
                'retention_policy',
                'latest',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putTransform(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['transform.put_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;
        const meta = {
            name: 'transform.put_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'dest',
                'description',
                'frequency',
                'latest',
                '_meta',
                'pivot',
                'retention_policy',
                'settings',
                'source',
                'sync',
                'defer_validation',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async resetTransform(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.reset_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_reset`;
        const meta = {
            name: 'transform.reset_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'force',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async scheduleNowTransform(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.schedule_now_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_schedule_now`;
        const meta = {
            name: 'transform.schedule_now_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async setUpgradeMode(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.set_upgrade_mode'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_transform/set_upgrade_mode';
        const meta = {
            name: 'transform.set_upgrade_mode',
            acceptedParams: [
                'enabled',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async startTransform(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.start_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_start`;
        const meta = {
            name: 'transform.start_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'timeout',
                'from'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stopTransform(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.stop_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_stop`;
        const meta = {
            name: 'transform.stop_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'allow_no_match',
                'force',
                'timeout',
                'wait_for_checkpoint',
                'wait_for_completion'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateTransform(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['transform.update_transform'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'POST';
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_update`;
        const meta = {
            name: 'transform.update_transform',
            pathParts: {
                transform_id: params.transform_id
            },
            acceptedParams: [
                'transform_id',
                'dest',
                'description',
                'frequency',
                '_meta',
                'source',
                'settings',
                'sync',
                'retention_policy',
                'defer_validation',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async upgradeTransforms(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['transform.upgrade_transforms'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_transform/_upgrade';
        const meta = {
            name: 'transform.upgrade_transforms',
            acceptedParams: [
                'dry_run',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Transform; //# sourceMappingURL=transform.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/update.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = UpdateApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    update: {
        path: [
            'id',
            'index'
        ],
        body: [
            'detect_noop',
            'doc',
            'doc_as_upsert',
            'script',
            'scripted_upsert',
            '_source',
            'upsert'
        ],
        query: [
            'if_primary_term',
            'if_seq_no',
            'include_source_on_error',
            'lang',
            'refresh',
            'require_alias',
            'retry_on_conflict',
            'routing',
            'timeout',
            'wait_for_active_shards',
            '_source',
            '_source_excludes',
            '_source_includes'
        ]
    }
};
async function UpdateApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.update;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = 'POST';
    const path = `/${encodeURIComponent(params.index.toString())}/_update/${encodeURIComponent(params.id.toString())}`;
    const meta = {
        name: 'update',
        pathParts: {
            id: params.id,
            index: params.index
        },
        acceptedParams: [
            'id',
            'index',
            'detect_noop',
            'doc',
            'doc_as_upsert',
            'script',
            'scripted_upsert',
            '_source',
            'upsert',
            'if_primary_term',
            'if_seq_no',
            'include_source_on_error',
            'lang',
            'refresh',
            'require_alias',
            'retry_on_conflict',
            'routing',
            'timeout',
            'wait_for_active_shards',
            '_source',
            '_source_excludes',
            '_source_includes'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=update.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/update_by_query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = UpdateByQueryApi;
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
const acceptedParams = {
    update_by_query: {
        path: [
            'index'
        ],
        body: [
            'max_docs',
            'query',
            'script',
            'slice',
            'conflicts'
        ],
        query: [
            'allow_no_indices',
            'analyzer',
            'analyze_wildcard',
            'conflicts',
            'default_operator',
            'df',
            'expand_wildcards',
            'from',
            'ignore_unavailable',
            'lenient',
            'max_docs',
            'pipeline',
            'preference',
            'q',
            'refresh',
            'request_cache',
            'requests_per_second',
            'routing',
            'scroll',
            'scroll_size',
            'search_timeout',
            'search_type',
            'slices',
            'sort',
            'stats',
            'terminate_after',
            'timeout',
            'version',
            'version_type',
            'wait_for_active_shards',
            'wait_for_completion'
        ]
    }
};
async function UpdateByQueryApi(params, options) {
    const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.update_by_query;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            // @ts-expect-error
            body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                // @ts-expect-error
                querystring[key] = params[key];
            } else {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            }
        }
    }
    const method = 'POST';
    const path = `/${encodeURIComponent(params.index.toString())}/_update_by_query`;
    const meta = {
        name: 'update_by_query',
        pathParts: {
            index: params.index
        },
        acceptedParams: [
            'index',
            'max_docs',
            'query',
            'script',
            'slice',
            'conflicts',
            'allow_no_indices',
            'analyzer',
            'analyze_wildcard',
            'conflicts',
            'default_operator',
            'df',
            'expand_wildcards',
            'from',
            'ignore_unavailable',
            'lenient',
            'max_docs',
            'pipeline',
            'preference',
            'q',
            'refresh',
            'request_cache',
            'requests_per_second',
            'routing',
            'scroll',
            'scroll_size',
            'search_timeout',
            'search_type',
            'slices',
            'sort',
            'stats',
            'terminate_after',
            'timeout',
            'version',
            'version_type',
            'wait_for_active_shards',
            'wait_for_completion'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=update_by_query.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/update_by_query_rethrottle.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = UpdateByQueryRethrottleApi;
const acceptedParams = {
    update_by_query_rethrottle: {
        path: [
            'task_id'
        ],
        body: [],
        query: [
            'requests_per_second'
        ]
    }
};
async function UpdateByQueryRethrottleApi(params, options) {
    const { path: acceptedPath } = acceptedParams.update_by_query_rethrottle;
    const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
    const querystring = userQuery != null ? {
        ...userQuery
    } : {};
    let body;
    const userBody = params === null || params === void 0 ? void 0 : params.body;
    if (userBody != null) {
        if (typeof userBody === 'string') {
            body = userBody;
        } else {
            body = {
                ...userBody
            };
        }
    }
    for(const key in params){
        if (acceptedPath.includes(key)) {
            continue;
        } else if (key !== 'body' && key !== 'querystring') {
            // @ts-expect-error
            querystring[key] = params[key];
        }
    }
    const method = 'POST';
    const path = `/_update_by_query/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;
    const meta = {
        name: 'update_by_query_rethrottle',
        pathParts: {
            task_id: params.task_id
        },
        acceptedParams: [
            'task_id',
            'requests_per_second'
        ]
    };
    return await this.transport.request({
        path,
        method,
        querystring,
        body,
        meta
    }, options);
} //# sourceMappingURL=update_by_query_rethrottle.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/watcher.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
const commonQueryParams = [
    'error_trace',
    'filter_path',
    'human',
    'pretty'
];
class Watcher {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'watcher.ack_watch': {
                path: [
                    'watch_id',
                    'action_id'
                ],
                body: [],
                query: []
            },
            'watcher.activate_watch': {
                path: [
                    'watch_id'
                ],
                body: [],
                query: []
            },
            'watcher.deactivate_watch': {
                path: [
                    'watch_id'
                ],
                body: [],
                query: []
            },
            'watcher.delete_watch': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'watcher.execute_watch': {
                path: [
                    'id'
                ],
                body: [
                    'action_modes',
                    'alternative_input',
                    'ignore_condition',
                    'record_execution',
                    'simulated_actions',
                    'trigger_data',
                    'watch'
                ],
                query: [
                    'debug'
                ]
            },
            'watcher.get_settings': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'watcher.get_watch': {
                path: [
                    'id'
                ],
                body: [],
                query: []
            },
            'watcher.put_watch': {
                path: [
                    'id'
                ],
                body: [
                    'actions',
                    'condition',
                    'input',
                    'metadata',
                    'throttle_period',
                    'throttle_period_in_millis',
                    'transform',
                    'trigger'
                ],
                query: [
                    'active',
                    'if_primary_term',
                    'if_seq_no',
                    'version'
                ]
            },
            'watcher.query_watches': {
                path: [],
                body: [
                    'from',
                    'size',
                    'query',
                    'sort',
                    'search_after'
                ],
                query: []
            },
            'watcher.start': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'watcher.stats': {
                path: [
                    'metric'
                ],
                body: [],
                query: [
                    'emit_stacktraces',
                    'metric'
                ]
            },
            'watcher.stop': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            },
            'watcher.update_settings': {
                path: [],
                body: [
                    'index.auto_expand_replicas',
                    'index.number_of_replicas'
                ],
                query: [
                    'master_timeout',
                    'timeout'
                ]
            }
        };
    }
    async ackWatch(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.ack_watch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.watch_id != null && params.action_id != null) {
            method = 'PUT';
            path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_ack/${encodeURIComponent(params.action_id.toString())}`;
        } else {
            method = 'PUT';
            path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_ack`;
        }
        const meta = {
            name: 'watcher.ack_watch',
            pathParts: {
                watch_id: params.watch_id,
                action_id: params.action_id
            },
            acceptedParams: [
                'watch_id',
                'action_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async activateWatch(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.activate_watch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_activate`;
        const meta = {
            name: 'watcher.activate_watch',
            pathParts: {
                watch_id: params.watch_id
            },
            acceptedParams: [
                'watch_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deactivateWatch(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.deactivate_watch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'PUT';
        const path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_deactivate`;
        const meta = {
            name: 'watcher.deactivate_watch',
            pathParts: {
                watch_id: params.watch_id
            },
            acceptedParams: [
                'watch_id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async deleteWatch(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.delete_watch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'DELETE';
        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'watcher.delete_watch',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async executeWatch(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['watcher.execute_watch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        let method = '';
        let path = '';
        if (params.id != null) {
            method = 'PUT';
            path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}/_execute`;
        } else {
            method = 'PUT';
            path = '/_watcher/watch/_execute';
        }
        const meta = {
            name: 'watcher.execute_watch',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'action_modes',
                'alternative_input',
                'ignore_condition',
                'record_execution',
                'simulated_actions',
                'trigger_data',
                'watch',
                'debug'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getSettings(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.get_settings'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_watcher/settings';
        const meta = {
            name: 'watcher.get_settings',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async getWatch(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.get_watch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'watcher.get_watch',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async putWatch(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['watcher.put_watch'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;
        const meta = {
            name: 'watcher.put_watch',
            pathParts: {
                id: params.id
            },
            acceptedParams: [
                'id',
                'actions',
                'condition',
                'input',
                'metadata',
                'throttle_period',
                'throttle_period_in_millis',
                'transform',
                'trigger',
                'active',
                'if_primary_term',
                'if_seq_no',
                'version'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async queryWatches(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['watcher.query_watches'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = body != null ? 'POST' : 'GET';
        const path = '/_watcher/_query/watches';
        const meta = {
            name: 'watcher.query_watches',
            acceptedParams: [
                'from',
                'size',
                'query',
                'sort',
                'search_after'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async start(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.start'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_watcher/_start';
        const meta = {
            name: 'watcher.start',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stats(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.stats'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        let method = '';
        let path = '';
        if (params.metric != null) {
            method = 'GET';
            path = `/_watcher/stats/${encodeURIComponent(params.metric.toString())}`;
        } else {
            method = 'GET';
            path = '/_watcher/stats';
        }
        const meta = {
            name: 'watcher.stats',
            pathParts: {
                metric: params.metric
            },
            acceptedParams: [
                'metric',
                'emit_stacktraces',
                'metric'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async stop(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['watcher.stop'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'POST';
        const path = '/_watcher/_stop';
        const meta = {
            name: 'watcher.stop',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async updateSettings(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this[client_1.kAcceptedParams]['watcher.update_settings'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedBody.includes(key)) {
                body = body !== null && body !== void 0 ? body : {};
                // @ts-expect-error
                body[key] = params[key];
            } else if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
                    // @ts-expect-error
                    querystring[key] = params[key];
                } else {
                    body = body !== null && body !== void 0 ? body : {};
                    // @ts-expect-error
                    body[key] = params[key];
                }
            }
        }
        const method = 'PUT';
        const path = '/_watcher/settings';
        const meta = {
            name: 'watcher.update_settings',
            acceptedParams: [
                'index.auto_expand_replicas',
                'index.number_of_replicas',
                'master_timeout',
                'timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Watcher; //# sourceMappingURL=watcher.js.map
}),
"[project]/node_modules/@elastic/elasticsearch/lib/api/api/xpack.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const client_1 = __turbopack_context__.r("[project]/node_modules/@elastic/elasticsearch/lib/client.js [app-route] (ecmascript)");
class Xpack {
    constructor(transport){
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.transport = transport;
        this[client_1.kAcceptedParams] = {
            'xpack.info': {
                path: [],
                body: [],
                query: [
                    'categories',
                    'accept_enterprise',
                    'human'
                ]
            },
            'xpack.usage': {
                path: [],
                body: [],
                query: [
                    'master_timeout'
                ]
            }
        };
    }
    async info(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['xpack.info'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_xpack';
        const meta = {
            name: 'xpack.info',
            acceptedParams: [
                'categories',
                'accept_enterprise',
                'human'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
    async usage(params, options) {
        const { path: acceptedPath } = this[client_1.kAcceptedParams]['xpack.usage'];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? {
            ...userQuery
        } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
            if (typeof userBody === 'string') {
                body = userBody;
            } else {
                body = {
                    ...userBody
                };
            }
        }
        params = params !== null && params !== void 0 ? params : {};
        for(const key in params){
            if (acceptedPath.includes(key)) {
                continue;
            } else if (key !== 'body' && key !== 'querystring') {
                // @ts-expect-error
                querystring[key] = params[key];
            }
        }
        const method = 'GET';
        const path = '/_xpack/usage';
        const meta = {
            name: 'xpack.usage',
            acceptedParams: [
                'master_timeout'
            ]
        };
        return await this.transport.request({
            path,
            method,
            querystring,
            body,
            meta
        }, options);
    }
}
_a = client_1.kAcceptedParams;
exports.default = Xpack; //# sourceMappingURL=xpack.js.map
}),
];

//# sourceMappingURL=node_modules_%40elastic_elasticsearch_lib_api_api_15b0526d._.js.map