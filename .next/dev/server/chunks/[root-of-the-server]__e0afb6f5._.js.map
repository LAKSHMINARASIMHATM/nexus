{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/config/elasticsearch/index-mappings.json"],"sourcesContent":["{\"settings\":{\"number_of_shards\":64,\"number_of_replicas\":2,\"refresh_interval\":\"30s\",\"index\":{\"codec\":\"best_compression\",\"max_result_window\":10000},\"analysis\":{\"analyzer\":{\"custom_analyzer\":{\"type\":\"custom\",\"tokenizer\":\"standard\",\"filter\":[\"lowercase\",\"porter_stem\",\"stop\",\"asciifolding\"]},\"ngram_analyzer\":{\"type\":\"custom\",\"tokenizer\":\"standard\",\"filter\":[\"lowercase\",\"ngram_filter\"]}},\"filter\":{\"ngram_filter\":{\"type\":\"ngram\",\"min_gram\":2,\"max_gram\":15}}}},\"mappings\":{\"properties\":{\"url\":{\"type\":\"keyword\"},\"canonical_url\":{\"type\":\"keyword\"},\"title\":{\"type\":\"text\",\"analyzer\":\"custom_analyzer\",\"fields\":{\"raw\":{\"type\":\"keyword\"},\"ngram\":{\"type\":\"text\",\"analyzer\":\"ngram_analyzer\"}},\"term_vector\":\"with_positions_offsets\"},\"body\":{\"type\":\"text\",\"analyzer\":\"custom_analyzer\",\"term_vector\":\"with_positions_offsets\",\"store\":false},\"meta_description\":{\"type\":\"text\",\"analyzer\":\"custom_analyzer\"},\"anchor_texts\":{\"type\":\"text\",\"analyzer\":\"custom_analyzer\"},\"headings\":{\"type\":\"text\",\"analyzer\":\"custom_analyzer\"},\"doc_length\":{\"type\":\"integer\"},\"pagerank\":{\"type\":\"float\"},\"language\":{\"type\":\"keyword\"},\"domain\":{\"type\":\"keyword\"},\"crawl_timestamp\":{\"type\":\"date\"},\"content_hash\":{\"type\":\"keyword\"},\"inbound_links\":{\"type\":\"integer\"},\"outbound_links\":{\"type\":\"integer\"}}}}"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 243, "column": 1293}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 247, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/lib/services/elasticsearch-service.ts"],"sourcesContent":["import { Client } from '@elastic/elasticsearch';\r\n\r\nclass ElasticsearchService {\r\n    private client: Client;\r\n    private indexName = 'search-documents';\r\n\r\n    constructor() {\r\n        this.client = new Client({\r\n            nodes: process.env.ELASTICSEARCH_NODES?.split(',') || ['http://localhost:9200'],\r\n            maxRetries: 5,\r\n            requestTimeout: 60000,\r\n            sniffOnStart: true,\r\n        });\r\n    }\r\n\r\n    async createIndex() {\r\n        const exists = await this.client.indices.exists({ index: this.indexName });\r\n\r\n        if (!exists) {\r\n            const mappings = require('../../config/elasticsearch/index-mappings.json');\r\n            await this.client.indices.create({\r\n                index: this.indexName,\r\n                body: mappings,\r\n            });\r\n            console.log(`Created index: ${this.indexName}`);\r\n        }\r\n    }\r\n\r\n    async indexDocument(doc: any) {\r\n        return await this.client.index({\r\n            index: this.indexName,\r\n            id: doc.doc_id,\r\n            document: {\r\n                url: doc.url,\r\n                canonical_url: doc.canonical_url,\r\n                title: doc.title,\r\n                body: doc.body,\r\n                meta_description: doc.meta_description,\r\n                anchor_texts: doc.anchor_texts || [],\r\n                headings: doc.headings || [],\r\n                doc_length: doc.body_length,\r\n                pagerank: doc.pagerank || 0,\r\n                language: doc.language || 'en',\r\n                domain: new URL(doc.url).hostname,\r\n                crawl_timestamp: doc.crawl_timestamp,\r\n                content_hash: doc.content_hash,\r\n                inbound_links: doc.inbound_links || 0,\r\n                outbound_links: doc.outbound_links || 0,\r\n            },\r\n        });\r\n    }\r\n\r\n    async bulkIndex(docs: any[]) {\r\n        const operations = docs.flatMap(doc => [\r\n            { index: { _index: this.indexName, _id: doc.doc_id } },\r\n            {\r\n                url: doc.url,\r\n                canonical_url: doc.canonical_url,\r\n                title: doc.title,\r\n                body: doc.body,\r\n                meta_description: doc.meta_description,\r\n                anchor_texts: doc.anchor_texts || [],\r\n                headings: doc.headings || [],\r\n                doc_length: doc.body_length,\r\n                pagerank: doc.pagerank || 0,\r\n                language: doc.language || 'en',\r\n                domain: new URL(doc.url).hostname,\r\n                crawl_timestamp: doc.crawl_timestamp,\r\n                content_hash: doc.content_hash,\r\n                inbound_links: doc.inbound_links || 0,\r\n                outbound_links: doc.outbound_links || 0,\r\n            },\r\n        ]);\r\n\r\n        const result = await this.client.bulk({ operations, refresh: false });\r\n\r\n        if (result.errors) {\r\n            const erroredDocuments = result.items.filter((item: any) => item.index?.error);\r\n            console.error('Bulk indexing errors:', erroredDocuments);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    async search(query: string, options: any = {}) {\r\n        const {\r\n            page = 1,\r\n            pageSize = 10,\r\n            filters = {},\r\n        } = options;\r\n\r\n        const from = (page - 1) * pageSize;\r\n\r\n        // Build query\r\n        // Build query\r\n        let must: any[] = [];\r\n\r\n        if (typeof query === 'string') {\r\n            must.push({\r\n                multi_match: {\r\n                    query,\r\n                    fields: ['title^3', 'body', 'meta_description^2', 'anchor_texts^2', 'headings^2'],\r\n                    type: 'best_fields',\r\n                    fuzziness: 'AUTO',\r\n                },\r\n            });\r\n        } else {\r\n            // Assume it's a pre-built query object (e.g. from QueryParser)\r\n            // We need to merge it carefully. \r\n            // If the input 'query' is actually a ParsedQuery object (with bool), we use it.\r\n            // For type safety, we should probably change the signature, but for now let's cast.\r\n            const parsedQuery = query as any;\r\n            if (parsedQuery.bool) {\r\n                return await this.client.search({\r\n                    index: this.indexName,\r\n                    from,\r\n                    size: pageSize,\r\n                    query: parsedQuery, // Use the parsed query directly\r\n                    sort: [\r\n                        { _score: { order: 'desc' } },\r\n                        { pagerank: { order: 'desc' } },\r\n                    ],\r\n                    highlight: {\r\n                        fields: {\r\n                            title: {},\r\n                            body: {},\r\n                            meta_description: {},\r\n                        },\r\n                        pre_tags: ['<em>'],\r\n                        post_tags: ['</em>'],\r\n                    },\r\n                    _source: ['url', 'title', 'meta_description', 'pagerank', 'language', 'crawl_timestamp'],\r\n                }).then(result => ({\r\n                    total: typeof result.hits.total === 'number' ? result.hits.total : result.hits.total?.value || 0,\r\n                    hits: result.hits.hits.map((hit: any) => ({\r\n                        doc_id: hit._id,\r\n                        score: hit._score,\r\n                        ...hit._source,\r\n                        highlights: hit.highlight,\r\n                    })),\r\n                }));\r\n            }\r\n        }\r\n\r\n        // Add filters\r\n        if (filters.language) {\r\n            must.push({ term: { language: filters.language } });\r\n        }\r\n        if (filters.site) {\r\n            must.push({ term: { domain: filters.site } });\r\n        }\r\n        if (filters.dateRange) {\r\n            must.push({\r\n                range: {\r\n                    crawl_timestamp: {\r\n                        gte: filters.dateRange.start,\r\n                        lte: filters.dateRange.end,\r\n                    },\r\n                },\r\n            });\r\n        }\r\n\r\n        const result = await this.client.search({\r\n            index: this.indexName,\r\n            from,\r\n            size: pageSize,\r\n            query: {\r\n                bool: { must },\r\n            },\r\n            sort: [\r\n                { _score: { order: 'desc' } },\r\n                { pagerank: { order: 'desc' } },\r\n            ],\r\n            highlight: {\r\n                fields: {\r\n                    title: {},\r\n                    body: {},\r\n                    meta_description: {},\r\n                },\r\n                pre_tags: ['<em>'],\r\n                post_tags: ['</em>'],\r\n            },\r\n            _source: ['url', 'title', 'meta_description', 'pagerank', 'language', 'crawl_timestamp'],\r\n        });\r\n\r\n        return {\r\n            total: typeof result.hits.total === 'number' ? result.hits.total : result.hits.total?.value || 0,\r\n            hits: result.hits.hits.map((hit: any) => ({\r\n                doc_id: hit._id,\r\n                score: hit._score,\r\n                ...hit._source,\r\n                highlights: hit.highlight,\r\n            })),\r\n        };\r\n    }\r\n\r\n    async getStats() {\r\n        const stats = await this.client.indices.stats({ index: this.indexName });\r\n        const health = await this.client.cluster.health();\r\n\r\n        return {\r\n            index: stats.indices?.[this.indexName],\r\n            cluster: health,\r\n        };\r\n    }\r\n}\r\n\r\nexport const elasticsearchService = new ElasticsearchService();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 575, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/lib/services/cache-service.ts"],"sourcesContent":["import Redis from 'ioredis';\r\n\r\nclass CacheService {\r\n    private redis: Redis;\r\n    private localCache: Map<string, { value: any; expiry: number }>;\r\n    private readonly LOCAL_CACHE_TTL = 60 * 1000; // 1 minute\r\n    private readonly REDIS_TTL = 300; // 5 minutes\r\n\r\n    constructor() {\r\n        this.redis = new Redis({\r\n            host: process.env.REDIS_HOST || 'localhost',\r\n            port: parseInt(process.env.REDIS_PORT || '6379'),\r\n            maxRetriesPerRequest: 3,\r\n            retryStrategy: (times) => {\r\n                const delay = Math.min(times * 50, 2000);\r\n                return delay;\r\n            },\r\n        });\r\n\r\n        this.localCache = new Map();\r\n\r\n        // Cleanup expired local cache entries\r\n        setInterval(() => {\r\n            const now = Date.now();\r\n            for (const [key, entry] of this.localCache.entries()) {\r\n                if (entry.expiry < now) {\r\n                    this.localCache.delete(key);\r\n                }\r\n            }\r\n        }, 60000); // Every minute\r\n    }\r\n\r\n    private getCacheKey(prefix: string, key: string): string {\r\n        return `${prefix}:${key}`;\r\n    }\r\n\r\n    async get<T>(prefix: string, key: string): Promise<T | null> {\r\n        const cacheKey = this.getCacheKey(prefix, key);\r\n\r\n        // L1: Check local cache\r\n        const localEntry = this.localCache.get(cacheKey);\r\n        if (localEntry && localEntry.expiry > Date.now()) {\r\n            return localEntry.value as T;\r\n        }\r\n\r\n        // L2: Check Redis\r\n        try {\r\n            const value = await this.redis.get(cacheKey);\r\n            if (value) {\r\n                const parsed = JSON.parse(value);\r\n                // Update local cache\r\n                this.localCache.set(cacheKey, {\r\n                    value: parsed,\r\n                    expiry: Date.now() + this.LOCAL_CACHE_TTL,\r\n                });\r\n                return parsed as T;\r\n            }\r\n        } catch (error) {\r\n            console.error('Redis get error:', error);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    async set(prefix: string, key: string, value: any, ttl?: number): Promise<void> {\r\n        const cacheKey = this.getCacheKey(prefix, key);\r\n        const serialized = JSON.stringify(value);\r\n\r\n        // Update local cache\r\n        this.localCache.set(cacheKey, {\r\n            value,\r\n            expiry: Date.now() + this.LOCAL_CACHE_TTL,\r\n        });\r\n\r\n        // Update Redis\r\n        try {\r\n            if (ttl) {\r\n                await this.redis.setex(cacheKey, ttl, serialized);\r\n            } else {\r\n                await this.redis.setex(cacheKey, this.REDIS_TTL, serialized);\r\n            }\r\n        } catch (error) {\r\n            console.error('Redis set error:', error);\r\n        }\r\n    }\r\n\r\n    async delete(prefix: string, key: string): Promise<void> {\r\n        const cacheKey = this.getCacheKey(prefix, key);\r\n\r\n        // Remove from local cache\r\n        this.localCache.delete(cacheKey);\r\n\r\n        // Remove from Redis\r\n        try {\r\n            await this.redis.del(cacheKey);\r\n        } catch (error) {\r\n            console.error('Redis delete error:', error);\r\n        }\r\n    }\r\n\r\n    async invalidatePattern(pattern: string): Promise<void> {\r\n        try {\r\n            const keys = await this.redis.keys(pattern);\r\n            if (keys.length > 0) {\r\n                await this.redis.del(...keys);\r\n            }\r\n\r\n            // Clear local cache entries matching pattern\r\n            for (const key of this.localCache.keys()) {\r\n                if (key.match(pattern)) {\r\n                    this.localCache.delete(key);\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.error('Redis invalidate error:', error);\r\n        }\r\n    }\r\n\r\n    // Rate limiting\r\n    async checkRateLimit(key: string, limit: number, window: number): Promise<boolean> {\r\n        const now = Date.now();\r\n        const windowKey = `ratelimit:${key}:${Math.floor(now / (window * 1000))}`;\r\n\r\n        try {\r\n            const count = await this.redis.incr(windowKey);\r\n            if (count === 1) {\r\n                await this.redis.expire(windowKey, window);\r\n            }\r\n            return count <= limit;\r\n        } catch (error) {\r\n            console.error('Rate limit check error:', error);\r\n            return true; // Fail open\r\n        }\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        await this.redis.quit();\r\n    }\r\n}\r\n\r\nexport const cacheService = new CacheService();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 728, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/lib/metrics/prometheus.ts"],"sourcesContent":["import { register, Counter, Histogram, Gauge } from 'prom-client';\r\n\r\n// Query metrics\r\nexport const queryCounter = new Counter({\r\n    name: 'search_queries_total',\r\n    help: 'Total number of search queries',\r\n    labelNames: ['status', 'cache_hit'],\r\n});\r\n\r\nexport const queryLatency = new Histogram({\r\n    name: 'search_query_duration_seconds',\r\n    help: 'Search query latency in seconds',\r\n    labelNames: ['stage'],\r\n    buckets: [0.01, 0.05, 0.1, 0.2, 0.5, 1, 2, 5],\r\n});\r\n\r\nexport const queryResultCount = new Histogram({\r\n    name: 'search_query_results',\r\n    help: 'Number of results returned per query',\r\n    buckets: [0, 1, 10, 100, 1000, 10000],\r\n});\r\n\r\n// Indexing metrics\r\nexport const indexingCounter = new Counter({\r\n    name: 'documents_indexed_total',\r\n    help: 'Total number of documents indexed',\r\n    labelNames: ['status'],\r\n});\r\n\r\nexport const indexingLatency = new Histogram({\r\n    name: 'indexing_duration_seconds',\r\n    help: 'Document indexing latency in seconds',\r\n    buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5],\r\n});\r\n\r\n// Crawler metrics\r\nexport const crawlCounter = new Counter({\r\n    name: 'urls_crawled_total',\r\n    help: 'Total number of URLs crawled',\r\n    labelNames: ['status'],\r\n});\r\n\r\nexport const crawlLatency = new Histogram({\r\n    name: 'crawl_duration_seconds',\r\n    help: 'URL crawl latency in seconds',\r\n    buckets: [0.1, 0.5, 1, 2, 5, 10, 30],\r\n});\r\n\r\nexport const crawlQueueSize = new Gauge({\r\n    name: 'crawl_queue_size',\r\n    help: 'Current size of the crawl queue',\r\n    labelNames: ['priority'],\r\n});\r\n\r\n// Cache metrics\r\nexport const cacheHitCounter = new Counter({\r\n    name: 'cache_hits_total',\r\n    help: 'Total number of cache hits',\r\n    labelNames: ['tier'],\r\n});\r\n\r\nexport const cacheMissCounter = new Counter({\r\n    name: 'cache_misses_total',\r\n    help: 'Total number of cache misses',\r\n    labelNames: ['tier'],\r\n});\r\n\r\n// System metrics\r\nexport const activeConnections = new Gauge({\r\n    name: 'active_connections',\r\n    help: 'Number of active connections',\r\n    labelNames: ['service'],\r\n});\r\n\r\nexport const errorCounter = new Counter({\r\n    name: 'errors_total',\r\n    help: 'Total number of errors',\r\n    labelNames: ['service', 'type'],\r\n});\r\n\r\n// Export metrics endpoint\r\nexport function getMetrics() {\r\n    return register.metrics();\r\n}\r\n\r\nexport { register };\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAGO,MAAM,eAAe,IAAI,oJAAO,CAAC;IACpC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;QAAU;KAAY;AACvC;AAEO,MAAM,eAAe,IAAI,sJAAS,CAAC;IACtC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;KAAQ;IACrB,SAAS;QAAC;QAAM;QAAM;QAAK;QAAK;QAAK;QAAG;QAAG;KAAE;AACjD;AAEO,MAAM,mBAAmB,IAAI,sJAAS,CAAC;IAC1C,MAAM;IACN,MAAM;IACN,SAAS;QAAC;QAAG;QAAG;QAAI;QAAK;QAAM;KAAM;AACzC;AAGO,MAAM,kBAAkB,IAAI,oJAAO,CAAC;IACvC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;KAAS;AAC1B;AAEO,MAAM,kBAAkB,IAAI,sJAAS,CAAC;IACzC,MAAM;IACN,MAAM;IACN,SAAS;QAAC;QAAM;QAAM;QAAK;QAAK;QAAG;QAAG;KAAE;AAC5C;AAGO,MAAM,eAAe,IAAI,oJAAO,CAAC;IACpC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;KAAS;AAC1B;AAEO,MAAM,eAAe,IAAI,sJAAS,CAAC;IACtC,MAAM;IACN,MAAM;IACN,SAAS;QAAC;QAAK;QAAK;QAAG;QAAG;QAAG;QAAI;KAAG;AACxC;AAEO,MAAM,iBAAiB,IAAI,kJAAK,CAAC;IACpC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;KAAW;AAC5B;AAGO,MAAM,kBAAkB,IAAI,oJAAO,CAAC;IACvC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;KAAO;AACxB;AAEO,MAAM,mBAAmB,IAAI,oJAAO,CAAC;IACxC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;KAAO;AACxB;AAGO,MAAM,oBAAoB,IAAI,kJAAK,CAAC;IACvC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;KAAU;AAC3B;AAEO,MAAM,eAAe,IAAI,oJAAO,CAAC;IACpC,MAAM;IACN,MAAM;IACN,YAAY;QAAC;QAAW;KAAO;AACnC;AAGO,SAAS;IACZ,OAAO,qJAAQ,CAAC,OAAO;AAC3B"}},
    {"offset": {"line": 879, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/app/api/v1/search/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { elasticsearchService } from '@/lib/services/elasticsearch-service';\r\nimport { cacheService } from '@/lib/services/cache-service';\r\nimport { kafkaService } from '@/lib/services/kafka-service';\r\nimport { queryCounter, queryLatency, queryResultCount } from '@/lib/metrics/prometheus';\r\nimport crypto from 'crypto';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n        const body = await req.json();\r\n        const { query, page = 1, page_size = 10, filters, options } = body;\r\n\r\n        if (!query || typeof query !== 'string' || query.trim().length === 0) {\r\n            queryCounter.inc({ status: 'error', cache_hit: 'false' });\r\n            return NextResponse.json(\r\n                {\r\n                    error: {\r\n                        code: 'INVALID_QUERY',\r\n                        message: 'Query string is required',\r\n                        details: { field: 'query', constraint: 'non_empty' },\r\n                    },\r\n                    request_id: `req_${Date.now()}`,\r\n                },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Generate cache key\r\n        const cacheKey = crypto\r\n            .createHash('sha256')\r\n            .update(JSON.stringify({ query, page, page_size, filters }))\r\n            .digest('hex');\r\n\r\n        // Check cache\r\n        const cached = await cacheService.get<any>('query', cacheKey);\r\n        if (cached) {\r\n            queryCounter.inc({ status: 'success', cache_hit: 'true' });\r\n            queryLatency.observe({ stage: 'total' }, (Date.now() - startTime) / 1000);\r\n            return NextResponse.json(cached);\r\n        }\r\n\r\n        // Search with Elasticsearch\r\n        const searchStart = Date.now();\r\n        const searchResults = await elasticsearchService.search(query, {\r\n            page,\r\n            pageSize: page_size,\r\n            filters,\r\n        });\r\n        queryLatency.observe({ stage: 'elasticsearch' }, (Date.now() - searchStart) / 1000);\r\n\r\n        // Format results\r\n        const results = {\r\n            query: {\r\n                original: query,\r\n                corrected: query, // TODO: Add spell correction\r\n                intent: 'informational', // TODO: Add intent classification\r\n            },\r\n            results: searchResults.hits.map((hit: any) => ({\r\n                doc_id: hit.doc_id,\r\n                url: hit.url,\r\n                title: hit.title,\r\n                snippet: hit.meta_description || '',\r\n                score: hit.score,\r\n                highlights: Object.values(hit.highlights || {}).flat(),\r\n                metadata: {\r\n                    language: hit.language,\r\n                    published_date: hit.crawl_timestamp,\r\n                },\r\n            })),\r\n            total_results: searchResults.total,\r\n            page,\r\n            page_size,\r\n            query_time_ms: Date.now() - startTime,\r\n            suggestions: [], // TODO: Add query suggestions\r\n        };\r\n\r\n        // Cache results\r\n        await cacheService.set('query', cacheKey, results, 300); // 5 minutes\r\n\r\n        // Record metrics\r\n        queryCounter.inc({ status: 'success', cache_hit: 'false' });\r\n        queryResultCount.observe(results.results.length);\r\n        queryLatency.observe({ stage: 'total' }, (Date.now() - startTime) / 1000);\r\n\r\n        return NextResponse.json(results);\r\n    } catch (error: any) {\r\n        console.error('Search API error:', error);\r\n        queryCounter.inc({ status: 'error', cache_hit: 'false' });\r\n\r\n        return NextResponse.json(\r\n            {\r\n                error: {\r\n                    code: 'INTERNAL_ERROR',\r\n                    message: 'An internal server error occurred',\r\n                    details: process.env.NODE_ENV === 'development' ? error.message : undefined,\r\n                },\r\n                request_id: `req_${Date.now()}`,\r\n            },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}