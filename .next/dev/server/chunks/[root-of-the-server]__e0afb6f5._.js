module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/node:os [external] (node:os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:os", () => require("node:os"));

module.exports = mod;
}),
"[externals]/node:zlib [external] (node:zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:zlib", () => require("node:zlib"));

module.exports = mod;
}),
"[externals]/node:buffer [external] (node:buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:buffer", () => require("node:buffer"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:process [external] (node:process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}),
"[externals]/node:querystring [external] (node:querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:querystring", () => require("node:querystring"));

module.exports = mod;
}),
"[externals]/node:timers/promises [external] (node:timers/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:timers/promises", () => require("node:timers/promises"));

module.exports = mod;
}),
"[externals]/perf_hooks [external] (perf_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("perf_hooks", () => require("perf_hooks"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:assert [external] (node:assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:assert", () => require("node:assert"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:diagnostics_channel", () => require("node:diagnostics_channel"));

module.exports = mod;
}),
"[externals]/node:tls [external] (node:tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:tls", () => require("node:tls"));

module.exports = mod;
}),
"[externals]/node:perf_hooks [external] (node:perf_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:perf_hooks", () => require("node:perf_hooks"));

module.exports = mod;
}),
"[externals]/node:util/types [external] (node:util/types, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util/types", () => require("node:util/types"));

module.exports = mod;
}),
"[externals]/node:worker_threads [external] (node:worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:worker_threads", () => require("node:worker_threads"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:http2 [external] (node:http2, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http2", () => require("node:http2"));

module.exports = mod;
}),
"[externals]/node:async_hooks [external] (node:async_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:async_hooks", () => require("node:async_hooks"));

module.exports = mod;
}),
"[externals]/node:console [external] (node:console, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:console", () => require("node:console"));

module.exports = mod;
}),
"[externals]/node:fs/promises [external] (node:fs/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs/promises", () => require("node:fs/promises"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/node:timers [external] (node:timers, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:timers", () => require("node:timers"));

module.exports = mod;
}),
"[externals]/node:dns [external] (node:dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:dns", () => require("node:dns"));

module.exports = mod;
}),
"[externals]/node:url [external] (node:url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}),
"[project]/config/elasticsearch/index-mappings.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"settings":{"number_of_shards":64,"number_of_replicas":2,"refresh_interval":"30s","index":{"codec":"best_compression","max_result_window":10000},"analysis":{"analyzer":{"custom_analyzer":{"type":"custom","tokenizer":"standard","filter":["lowercase","porter_stem","stop","asciifolding"]},"ngram_analyzer":{"type":"custom","tokenizer":"standard","filter":["lowercase","ngram_filter"]}},"filter":{"ngram_filter":{"type":"ngram","min_gram":2,"max_gram":15}}}},"mappings":{"properties":{"url":{"type":"keyword"},"canonical_url":{"type":"keyword"},"title":{"type":"text","analyzer":"custom_analyzer","fields":{"raw":{"type":"keyword"},"ngram":{"type":"text","analyzer":"ngram_analyzer"}},"term_vector":"with_positions_offsets"},"body":{"type":"text","analyzer":"custom_analyzer","term_vector":"with_positions_offsets","store":false},"meta_description":{"type":"text","analyzer":"custom_analyzer"},"anchor_texts":{"type":"text","analyzer":"custom_analyzer"},"headings":{"type":"text","analyzer":"custom_analyzer"},"doc_length":{"type":"integer"},"pagerank":{"type":"float"},"language":{"type":"keyword"},"domain":{"type":"keyword"},"crawl_timestamp":{"type":"date"},"content_hash":{"type":"keyword"},"inbound_links":{"type":"integer"},"outbound_links":{"type":"integer"}}}});}),
"[project]/lib/services/elasticsearch-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "elasticsearchService",
    ()=>elasticsearchService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$elastic$2f$elasticsearch$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@elastic/elasticsearch/index.js [app-route] (ecmascript)");
;
class ElasticsearchService {
    client;
    indexName = 'search-documents';
    constructor(){
        this.client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$elastic$2f$elasticsearch$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Client"]({
            nodes: process.env.ELASTICSEARCH_NODES?.split(',') || [
                'http://localhost:9200'
            ],
            maxRetries: 5,
            requestTimeout: 60000,
            sniffOnStart: true
        });
    }
    async createIndex() {
        const exists = await this.client.indices.exists({
            index: this.indexName
        });
        if (!exists) {
            const mappings = __turbopack_context__.r("[project]/config/elasticsearch/index-mappings.json (json)");
            await this.client.indices.create({
                index: this.indexName,
                body: mappings
            });
            console.log(`Created index: ${this.indexName}`);
        }
    }
    async indexDocument(doc) {
        return await this.client.index({
            index: this.indexName,
            id: doc.doc_id,
            document: {
                url: doc.url,
                canonical_url: doc.canonical_url,
                title: doc.title,
                body: doc.body,
                meta_description: doc.meta_description,
                anchor_texts: doc.anchor_texts || [],
                headings: doc.headings || [],
                doc_length: doc.body_length,
                pagerank: doc.pagerank || 0,
                language: doc.language || 'en',
                domain: new URL(doc.url).hostname,
                crawl_timestamp: doc.crawl_timestamp,
                content_hash: doc.content_hash,
                inbound_links: doc.inbound_links || 0,
                outbound_links: doc.outbound_links || 0
            }
        });
    }
    async bulkIndex(docs) {
        const operations = docs.flatMap((doc)=>[
                {
                    index: {
                        _index: this.indexName,
                        _id: doc.doc_id
                    }
                },
                {
                    url: doc.url,
                    canonical_url: doc.canonical_url,
                    title: doc.title,
                    body: doc.body,
                    meta_description: doc.meta_description,
                    anchor_texts: doc.anchor_texts || [],
                    headings: doc.headings || [],
                    doc_length: doc.body_length,
                    pagerank: doc.pagerank || 0,
                    language: doc.language || 'en',
                    domain: new URL(doc.url).hostname,
                    crawl_timestamp: doc.crawl_timestamp,
                    content_hash: doc.content_hash,
                    inbound_links: doc.inbound_links || 0,
                    outbound_links: doc.outbound_links || 0
                }
            ]);
        const result = await this.client.bulk({
            operations,
            refresh: false
        });
        if (result.errors) {
            const erroredDocuments = result.items.filter((item)=>item.index?.error);
            console.error('Bulk indexing errors:', erroredDocuments);
        }
        return result;
    }
    async search(query, options = {}) {
        const { page = 1, pageSize = 10, filters = {} } = options;
        const from = (page - 1) * pageSize;
        // Build query
        // Build query
        let must = [];
        if (typeof query === 'string') {
            must.push({
                multi_match: {
                    query,
                    fields: [
                        'title^3',
                        'body',
                        'meta_description^2',
                        'anchor_texts^2',
                        'headings^2'
                    ],
                    type: 'best_fields',
                    fuzziness: 'AUTO'
                }
            });
        } else {
            // Assume it's a pre-built query object (e.g. from QueryParser)
            // We need to merge it carefully. 
            // If the input 'query' is actually a ParsedQuery object (with bool), we use it.
            // For type safety, we should probably change the signature, but for now let's cast.
            const parsedQuery = query;
            if (parsedQuery.bool) {
                return await this.client.search({
                    index: this.indexName,
                    from,
                    size: pageSize,
                    query: parsedQuery,
                    sort: [
                        {
                            _score: {
                                order: 'desc'
                            }
                        },
                        {
                            pagerank: {
                                order: 'desc'
                            }
                        }
                    ],
                    highlight: {
                        fields: {
                            title: {},
                            body: {},
                            meta_description: {}
                        },
                        pre_tags: [
                            '<em>'
                        ],
                        post_tags: [
                            '</em>'
                        ]
                    },
                    _source: [
                        'url',
                        'title',
                        'meta_description',
                        'pagerank',
                        'language',
                        'crawl_timestamp'
                    ]
                }).then((result)=>({
                        total: typeof result.hits.total === 'number' ? result.hits.total : result.hits.total?.value || 0,
                        hits: result.hits.hits.map((hit)=>({
                                doc_id: hit._id,
                                score: hit._score,
                                ...hit._source,
                                highlights: hit.highlight
                            }))
                    }));
            }
        }
        // Add filters
        if (filters.language) {
            must.push({
                term: {
                    language: filters.language
                }
            });
        }
        if (filters.site) {
            must.push({
                term: {
                    domain: filters.site
                }
            });
        }
        if (filters.dateRange) {
            must.push({
                range: {
                    crawl_timestamp: {
                        gte: filters.dateRange.start,
                        lte: filters.dateRange.end
                    }
                }
            });
        }
        const result = await this.client.search({
            index: this.indexName,
            from,
            size: pageSize,
            query: {
                bool: {
                    must
                }
            },
            sort: [
                {
                    _score: {
                        order: 'desc'
                    }
                },
                {
                    pagerank: {
                        order: 'desc'
                    }
                }
            ],
            highlight: {
                fields: {
                    title: {},
                    body: {},
                    meta_description: {}
                },
                pre_tags: [
                    '<em>'
                ],
                post_tags: [
                    '</em>'
                ]
            },
            _source: [
                'url',
                'title',
                'meta_description',
                'pagerank',
                'language',
                'crawl_timestamp'
            ]
        });
        return {
            total: typeof result.hits.total === 'number' ? result.hits.total : result.hits.total?.value || 0,
            hits: result.hits.hits.map((hit)=>({
                    doc_id: hit._id,
                    score: hit._score,
                    ...hit._source,
                    highlights: hit.highlight
                }))
        };
    }
    async getStats() {
        const stats = await this.client.indices.stats({
            index: this.indexName
        });
        const health = await this.client.cluster.health();
        return {
            index: stats.indices?.[this.indexName],
            cluster: health
        };
    }
}
const elasticsearchService = new ElasticsearchService();
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[project]/lib/services/cache-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cacheService",
    ()=>cacheService
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ioredis$2f$built$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ioredis/built/index.js [app-route] (ecmascript)");
;
class CacheService {
    redis;
    localCache;
    LOCAL_CACHE_TTL = 60 * 1000;
    REDIS_TTL = 300;
    constructor(){
        this.redis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ioredis$2f$built$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            host: process.env.REDIS_HOST || 'localhost',
            port: parseInt(process.env.REDIS_PORT || '6379'),
            maxRetriesPerRequest: 3,
            retryStrategy: (times)=>{
                const delay = Math.min(times * 50, 2000);
                return delay;
            }
        });
        this.localCache = new Map();
        // Cleanup expired local cache entries
        setInterval(()=>{
            const now = Date.now();
            for (const [key, entry] of this.localCache.entries()){
                if (entry.expiry < now) {
                    this.localCache.delete(key);
                }
            }
        }, 60000); // Every minute
    }
    getCacheKey(prefix, key) {
        return `${prefix}:${key}`;
    }
    async get(prefix, key) {
        const cacheKey = this.getCacheKey(prefix, key);
        // L1: Check local cache
        const localEntry = this.localCache.get(cacheKey);
        if (localEntry && localEntry.expiry > Date.now()) {
            return localEntry.value;
        }
        // L2: Check Redis
        try {
            const value = await this.redis.get(cacheKey);
            if (value) {
                const parsed = JSON.parse(value);
                // Update local cache
                this.localCache.set(cacheKey, {
                    value: parsed,
                    expiry: Date.now() + this.LOCAL_CACHE_TTL
                });
                return parsed;
            }
        } catch (error) {
            console.error('Redis get error:', error);
        }
        return null;
    }
    async set(prefix, key, value, ttl) {
        const cacheKey = this.getCacheKey(prefix, key);
        const serialized = JSON.stringify(value);
        // Update local cache
        this.localCache.set(cacheKey, {
            value,
            expiry: Date.now() + this.LOCAL_CACHE_TTL
        });
        // Update Redis
        try {
            if (ttl) {
                await this.redis.setex(cacheKey, ttl, serialized);
            } else {
                await this.redis.setex(cacheKey, this.REDIS_TTL, serialized);
            }
        } catch (error) {
            console.error('Redis set error:', error);
        }
    }
    async delete(prefix, key) {
        const cacheKey = this.getCacheKey(prefix, key);
        // Remove from local cache
        this.localCache.delete(cacheKey);
        // Remove from Redis
        try {
            await this.redis.del(cacheKey);
        } catch (error) {
            console.error('Redis delete error:', error);
        }
    }
    async invalidatePattern(pattern) {
        try {
            const keys = await this.redis.keys(pattern);
            if (keys.length > 0) {
                await this.redis.del(...keys);
            }
            // Clear local cache entries matching pattern
            for (const key of this.localCache.keys()){
                if (key.match(pattern)) {
                    this.localCache.delete(key);
                }
            }
        } catch (error) {
            console.error('Redis invalidate error:', error);
        }
    }
    // Rate limiting
    async checkRateLimit(key, limit, window) {
        const now = Date.now();
        const windowKey = `ratelimit:${key}:${Math.floor(now / (window * 1000))}`;
        try {
            const count = await this.redis.incr(windowKey);
            if (count === 1) {
                await this.redis.expire(windowKey, window);
            }
            return count <= limit;
        } catch (error) {
            console.error('Rate limit check error:', error);
            return true; // Fail open
        }
    }
    async disconnect() {
        await this.redis.quit();
    }
}
const cacheService = new CacheService();
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/v8 [external] (v8, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("v8", () => require("v8"));

module.exports = mod;
}),
"[externals]/cluster [external] (cluster, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("cluster", () => require("cluster"));

module.exports = mod;
}),
"[project]/lib/metrics/prometheus.ts [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "activeConnections",
    ()=>activeConnections,
    "cacheHitCounter",
    ()=>cacheHitCounter,
    "cacheMissCounter",
    ()=>cacheMissCounter,
    "crawlCounter",
    ()=>crawlCounter,
    "crawlLatency",
    ()=>crawlLatency,
    "crawlQueueSize",
    ()=>crawlQueueSize,
    "errorCounter",
    ()=>errorCounter,
    "getMetrics",
    ()=>getMetrics,
    "indexingCounter",
    ()=>indexingCounter,
    "indexingLatency",
    ()=>indexingLatency,
    "queryCounter",
    ()=>queryCounter,
    "queryLatency",
    ()=>queryLatency,
    "queryResultCount",
    ()=>queryResultCount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/prom-client/index.js [app-route] (ecmascript)");
;
const queryCounter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Counter"]({
    name: 'search_queries_total',
    help: 'Total number of search queries',
    labelNames: [
        'status',
        'cache_hit'
    ]
});
const queryLatency = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Histogram"]({
    name: 'search_query_duration_seconds',
    help: 'Search query latency in seconds',
    labelNames: [
        'stage'
    ],
    buckets: [
        0.01,
        0.05,
        0.1,
        0.2,
        0.5,
        1,
        2,
        5
    ]
});
const queryResultCount = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Histogram"]({
    name: 'search_query_results',
    help: 'Number of results returned per query',
    buckets: [
        0,
        1,
        10,
        100,
        1000,
        10000
    ]
});
const indexingCounter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Counter"]({
    name: 'documents_indexed_total',
    help: 'Total number of documents indexed',
    labelNames: [
        'status'
    ]
});
const indexingLatency = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Histogram"]({
    name: 'indexing_duration_seconds',
    help: 'Document indexing latency in seconds',
    buckets: [
        0.01,
        0.05,
        0.1,
        0.5,
        1,
        2,
        5
    ]
});
const crawlCounter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Counter"]({
    name: 'urls_crawled_total',
    help: 'Total number of URLs crawled',
    labelNames: [
        'status'
    ]
});
const crawlLatency = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Histogram"]({
    name: 'crawl_duration_seconds',
    help: 'URL crawl latency in seconds',
    buckets: [
        0.1,
        0.5,
        1,
        2,
        5,
        10,
        30
    ]
});
const crawlQueueSize = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Gauge"]({
    name: 'crawl_queue_size',
    help: 'Current size of the crawl queue',
    labelNames: [
        'priority'
    ]
});
const cacheHitCounter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Counter"]({
    name: 'cache_hits_total',
    help: 'Total number of cache hits',
    labelNames: [
        'tier'
    ]
});
const cacheMissCounter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Counter"]({
    name: 'cache_misses_total',
    help: 'Total number of cache misses',
    labelNames: [
        'tier'
    ]
});
const activeConnections = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Gauge"]({
    name: 'active_connections',
    help: 'Number of active connections',
    labelNames: [
        'service'
    ]
});
const errorCounter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Counter"]({
    name: 'errors_total',
    help: 'Total number of errors',
    labelNames: [
        'service',
        'type'
    ]
});
function getMetrics() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$prom$2d$client$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["register"].metrics();
}
;
}),
"[project]/app/api/v1/search/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$elasticsearch$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/services/elasticsearch-service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/services/cache-service.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/lib/metrics/prometheus.ts [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
;
;
;
;
async function POST(req) {
    const startTime = Date.now();
    try {
        const body = await req.json();
        const { query, page = 1, page_size = 10, filters, options } = body;
        if (!query || typeof query !== 'string' || query.trim().length === 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryCounter"].inc({
                status: 'error',
                cache_hit: 'false'
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: {
                    code: 'INVALID_QUERY',
                    message: 'Query string is required',
                    details: {
                        field: 'query',
                        constraint: 'non_empty'
                    }
                },
                request_id: `req_${Date.now()}`
            }, {
                status: 400
            });
        }
        // Generate cache key
        const cacheKey = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash('sha256').update(JSON.stringify({
            query,
            page,
            page_size,
            filters
        })).digest('hex');
        // Check cache
        const cached = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cacheService"].get('query', cacheKey);
        if (cached) {
            __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryCounter"].inc({
                status: 'success',
                cache_hit: 'true'
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryLatency"].observe({
                stage: 'total'
            }, (Date.now() - startTime) / 1000);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(cached);
        }
        // Search with Elasticsearch
        const searchStart = Date.now();
        const searchResults = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$elasticsearch$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["elasticsearchService"].search(query, {
            page,
            pageSize: page_size,
            filters
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryLatency"].observe({
            stage: 'elasticsearch'
        }, (Date.now() - searchStart) / 1000);
        // Format results
        const results = {
            query: {
                original: query,
                corrected: query,
                intent: 'informational'
            },
            results: searchResults.hits.map((hit)=>({
                    doc_id: hit.doc_id,
                    url: hit.url,
                    title: hit.title,
                    snippet: hit.meta_description || '',
                    score: hit.score,
                    highlights: Object.values(hit.highlights || {}).flat(),
                    metadata: {
                        language: hit.language,
                        published_date: hit.crawl_timestamp
                    }
                })),
            total_results: searchResults.total,
            page,
            page_size,
            query_time_ms: Date.now() - startTime,
            suggestions: []
        };
        // Cache results
        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$cache$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cacheService"].set('query', cacheKey, results, 300); // 5 minutes
        // Record metrics
        __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryCounter"].inc({
            status: 'success',
            cache_hit: 'false'
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryResultCount"].observe(results.results.length);
        __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryLatency"].observe({
            stage: 'total'
        }, (Date.now() - startTime) / 1000);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(results);
    } catch (error) {
        console.error('Search API error:', error);
        __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$metrics$2f$prometheus$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryCounter"].inc({
            status: 'error',
            cache_hit: 'false'
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: {
                code: 'INTERNAL_ERROR',
                message: 'An internal server error occurred',
                details: ("TURBOPACK compile-time truthy", 1) ? error.message : "TURBOPACK unreachable"
            },
            request_id: `req_${Date.now()}`
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__e0afb6f5._.js.map