{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/lib/db.ts"],"sourcesContent":["import { Pool } from 'pg';\r\nimport * as dotenv from 'dotenv';\r\n\r\ndotenv.config({ path: '.env.local' });\r\ndotenv.config({ path: '.env' });\r\n\r\nconsole.log('Initializing DB pool with:', process.env.DATABASE_URL);\r\n\r\nconst pool = new Pool({\r\n    connectionString: process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:5432/search_engine',\r\n    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\r\n});\r\n\r\nexport default pool;\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAEA,iJAAa,CAAC;IAAE,MAAM;AAAa;AACnC,iJAAa,CAAC;IAAE,MAAM;AAAO;AAE7B,QAAQ,GAAG,CAAC,8BAA8B,QAAQ,GAAG,CAAC,YAAY;AAElE,MAAM,OAAO,IAAI,4GAAI,CAAC;IAClB,kBAAkB,QAAQ,GAAG,CAAC,YAAY,IAAI;IAC9C,KAAK,sCAAwC,0BAAgC;AACjF;uCAEe"}},
    {"offset": {"line": 107, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/lib/services/local-recommendation-service.ts"],"sourcesContent":["/**\r\n * Local Document Recommendation Service\r\n * \r\n * Provides recommendations based on documents in the local database\r\n */\r\n\r\nimport pool from '../db';\r\n\r\nexport interface DocumentRecommendation {\r\n  doc_id: string;\r\n  url: string;\r\n  title: string;\r\n  meta_description: string | null;\r\n  score: number;\r\n  pagerank: number;\r\n  created_at: Date;\r\n}\r\n\r\nexport interface RecommendationOptions {\r\n  limit?: number;\r\n  offset?: number;\r\n}\r\n\r\nexport class LocalRecommendationService {\r\n  /**\r\n   * Get popular documents based on PageRank and recency\r\n   */\r\n  async getPopularDocuments(options: RecommendationOptions = {}): Promise<DocumentRecommendation[]> {\r\n    const { limit = 10, offset = 0 } = options;\r\n\r\n    const query = `\r\n      SELECT \r\n        doc_id,\r\n        url,\r\n        title,\r\n        meta_description,\r\n        pagerank as score,\r\n        pagerank,\r\n        created_at\r\n      FROM documents\r\n      WHERE index_status = 'indexed'\r\n        AND title IS NOT NULL\r\n        AND title != ''\r\n      ORDER BY \r\n        pagerank DESC,\r\n        created_at DESC\r\n      LIMIT $1 OFFSET $2\r\n    `;\r\n\r\n    const result = await pool.query(query, [limit, offset]);\r\n    return result.rows;\r\n  }\r\n\r\n  /**\r\n   * Get trending documents (recently added or updated)\r\n   */\r\n  async getTrendingDocuments(options: RecommendationOptions = {}): Promise<DocumentRecommendation[]> {\r\n    const { limit = 10, offset = 0 } = options;\r\n\r\n    const query = `\r\n      SELECT \r\n        doc_id,\r\n        url,\r\n        title,\r\n        meta_description,\r\n        pagerank as score,\r\n        pagerank,\r\n        created_at\r\n      FROM documents\r\n      WHERE index_status = 'indexed'\r\n        AND title IS NOT NULL\r\n        AND title != ''\r\n        AND created_at >= NOW() - INTERVAL '30 days'\r\n      ORDER BY \r\n        created_at DESC,\r\n        pagerank DESC\r\n      LIMIT $1 OFFSET $2\r\n    `;\r\n\r\n    const result = await pool.query(query, [limit, offset]);\r\n    return result.rows;\r\n  }\r\n\r\n  /**\r\n   * Get similar documents based on content similarity\r\n   * Uses the document's title and description to find related content\r\n   */\r\n  async getSimilarDocuments(\r\n    docId: string,\r\n    options: RecommendationOptions = {}\r\n  ): Promise<DocumentRecommendation[]> {\r\n    const { limit = 10, offset = 0 } = options;\r\n\r\n    // First, get the source document\r\n    const sourceDoc = await pool.query(\r\n      'SELECT title, meta_description FROM documents WHERE doc_id = $1',\r\n      [docId]\r\n    );\r\n\r\n    if (sourceDoc.rows.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const { title, meta_description } = sourceDoc.rows[0];\r\n\r\n    // Create search terms from title and description\r\n    const searchText = [title, meta_description]\r\n      .filter(Boolean)\r\n      .join(' ')\r\n      .replace(/[^\\w\\s]/g, ' ') // Remove special characters\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 3) // Only words longer than 3 chars\r\n      .slice(0, 10) // Take first 10 words\r\n      .join(' & '); // Use AND operator for tsquery\r\n\r\n    if (!searchText) {\r\n      return this.getPopularDocuments(options);\r\n    }\r\n\r\n    const query = `\r\n      SELECT \r\n        doc_id,\r\n        url,\r\n        title,\r\n        meta_description,\r\n        similarity as score,\r\n        pagerank,\r\n        created_at\r\n      FROM documents,\r\n        similarity(title || ' ' || COALESCE(meta_description, ''), $1) as similarity\r\n      WHERE doc_id != $2\r\n        AND index_status = 'indexed'\r\n        AND title IS NOT NULL\r\n        AND title != ''\r\n      ORDER BY \r\n        similarity DESC,\r\n        pagerank DESC\r\n      LIMIT $3 OFFSET $4\r\n    `;\r\n\r\n    try {\r\n      const result = await pool.query(query, [\r\n        title + ' ' + (meta_description || ''),\r\n        docId,\r\n        limit,\r\n        offset\r\n      ]);\r\n      return result.rows;\r\n    } catch (error) {\r\n      // Fallback to simple text matching if similarity function not available\r\n      const fallbackQuery = `\r\n        SELECT \r\n          doc_id,\r\n          url,\r\n          title,\r\n          meta_description,\r\n          0.5 as score,\r\n          pagerank,\r\n          created_at\r\n        FROM documents\r\n        WHERE doc_id != $1\r\n          AND index_status = 'indexed'\r\n          AND title IS NOT NULL\r\n          AND title != ''\r\n          AND (\r\n            title ILIKE $2\r\n            OR meta_description ILIKE $2\r\n          )\r\n        ORDER BY \r\n          pagerank DESC,\r\n          created_at DESC\r\n        LIMIT $3 OFFSET $4\r\n      `;\r\n\r\n      const searchPattern = `%${title.split(' ')[0]}%`;\r\n      const result = await pool.query(fallbackQuery, [docId, searchPattern, limit, offset]);\r\n      return result.rows;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get documents related to a search query\r\n   */\r\n  async getRelatedDocuments(\r\n    query: string,\r\n    options: RecommendationOptions = {}\r\n  ): Promise<DocumentRecommendation[]> {\r\n    const { limit = 10, offset = 0 } = options;\r\n\r\n    if (!query || query.trim().length === 0) {\r\n      return this.getPopularDocuments(options);\r\n    }\r\n\r\n    const searchQuery = `\r\n      SELECT \r\n        doc_id,\r\n        url,\r\n        title,\r\n        meta_description,\r\n        GREATEST(\r\n          similarity(title, $1),\r\n          similarity(COALESCE(meta_description, ''), $1)\r\n        ) as score,\r\n        pagerank,\r\n        created_at\r\n      FROM documents\r\n      WHERE index_status = 'indexed'\r\n        AND title IS NOT NULL\r\n        AND title != ''\r\n      ORDER BY \r\n        score DESC,\r\n        pagerank DESC\r\n      LIMIT $2 OFFSET $3\r\n    `;\r\n\r\n    try {\r\n      const result = await pool.query(searchQuery, [query, limit, offset]);\r\n      return result.rows;\r\n    } catch (error) {\r\n      // Fallback to ILIKE search\r\n      const fallbackQuery = `\r\n        SELECT \r\n          doc_id,\r\n          url,\r\n          title,\r\n          meta_description,\r\n          CASE \r\n            WHEN title ILIKE $1 THEN 0.9\r\n            WHEN meta_description ILIKE $1 THEN 0.7\r\n            ELSE 0.5\r\n          END as score,\r\n          pagerank,\r\n          created_at\r\n        FROM documents\r\n        WHERE index_status = 'indexed'\r\n          AND title IS NOT NULL\r\n          AND title != ''\r\n          AND (\r\n            title ILIKE $1\r\n            OR meta_description ILIKE $1\r\n          )\r\n        ORDER BY \r\n          score DESC,\r\n          pagerank DESC,\r\n          created_at DESC\r\n        LIMIT $2 OFFSET $3\r\n      `;\r\n\r\n      const searchPattern = `%${query}%`;\r\n      const result = await pool.query(fallbackQuery, [searchPattern, limit, offset]);\r\n      return result.rows;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get random documents (for discovery)\r\n   */\r\n  async getRandomDocuments(options: RecommendationOptions = {}): Promise<DocumentRecommendation[]> {\r\n    const { limit = 10, offset = 0 } = options;\r\n\r\n    const query = `\r\n      SELECT \r\n        doc_id,\r\n        url,\r\n        title,\r\n        meta_description,\r\n        RANDOM() as score,\r\n        pagerank,\r\n        created_at\r\n      FROM documents\r\n      WHERE index_status = 'indexed'\r\n        AND title IS NOT NULL\r\n        AND title != ''\r\n      ORDER BY RANDOM()\r\n      LIMIT $1 OFFSET $2\r\n    `;\r\n\r\n    const result = await pool.query(query, [limit, offset]);\r\n    return result.rows;\r\n  }\r\n\r\n  /**\r\n   * Get document count for statistics\r\n   */\r\n  async getDocumentCount(): Promise<number> {\r\n    const result = await pool.query(\r\n      \"SELECT COUNT(*) as count FROM documents WHERE index_status = 'indexed'\"\r\n    );\r\n    return parseInt(result.rows[0].count);\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const localRecommendationService = new LocalRecommendationService();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///D:/search-engine-spec/app/api/recommendations/local/route.ts"],"sourcesContent":["/**\r\n * Local Document Recommendations API\r\n * \r\n * Provides recommendations based on documents in the local database\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { localRecommendationService } from '@/lib/services/local-recommendation-service';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\n/**\r\n * GET /api/recommendations/local\r\n * \r\n * Query parameters:\r\n * - type: 'popular' | 'trending' | 'similar' | 'related' | 'random' (required)\r\n * - limit: number (optional, default: 10, max: 50)\r\n * - offset: number (optional, default: 0)\r\n * - docId: string (required for type=similar)\r\n * - query: string (required for type=related)\r\n * \r\n * Examples:\r\n * - /api/recommendations/local?type=popular&limit=10\r\n * - /api/recommendations/local?type=trending&limit=20\r\n * - /api/recommendations/local?type=similar&docId=123e4567-e89b-12d3-a456-426614174000&limit=10\r\n * - /api/recommendations/local?type=related&query=javascript&limit=15\r\n * - /api/recommendations/local?type=random&limit=5\r\n */\r\nexport async function GET(request: NextRequest) {\r\n    try {\r\n        const searchParams = request.nextUrl.searchParams;\r\n\r\n        // Parse and validate parameters\r\n        const type = searchParams.get('type');\r\n        const limitParam = searchParams.get('limit');\r\n        const offsetParam = searchParams.get('offset');\r\n        const docId = searchParams.get('docId');\r\n        const query = searchParams.get('query');\r\n\r\n        // Validate type parameter\r\n        if (!type) {\r\n            return NextResponse.json(\r\n                {\r\n                    success: false,\r\n                    error: 'Missing required parameter: type',\r\n                    validTypes: ['popular', 'trending', 'similar', 'related', 'random'],\r\n                },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const validTypes = ['popular', 'trending', 'similar', 'related', 'random'];\r\n        if (!validTypes.includes(type)) {\r\n            return NextResponse.json(\r\n                {\r\n                    success: false,\r\n                    error: `Invalid type: ${type}`,\r\n                    validTypes,\r\n                },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Parse limit and offset\r\n        const limit = limitParam ? Math.min(parseInt(limitParam), 50) : 10;\r\n        const offset = offsetParam ? parseInt(offsetParam) : 0;\r\n\r\n        if (isNaN(limit) || limit < 1) {\r\n            return NextResponse.json(\r\n                {\r\n                    success: false,\r\n                    error: 'Invalid limit: must be a number between 1 and 50',\r\n                },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        if (isNaN(offset) || offset < 0) {\r\n            return NextResponse.json(\r\n                {\r\n                    success: false,\r\n                    error: 'Invalid offset: must be a non-negative number',\r\n                },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Get recommendations based on type\r\n        let recommendations;\r\n\r\n        switch (type) {\r\n            case 'popular':\r\n                recommendations = await localRecommendationService.getPopularDocuments({\r\n                    limit,\r\n                    offset,\r\n                });\r\n                break;\r\n\r\n            case 'trending':\r\n                recommendations = await localRecommendationService.getTrendingDocuments({\r\n                    limit,\r\n                    offset,\r\n                });\r\n                break;\r\n\r\n            case 'similar':\r\n                if (!docId) {\r\n                    return NextResponse.json(\r\n                        {\r\n                            success: false,\r\n                            error: 'Missing required parameter for type=similar: docId',\r\n                        },\r\n                        { status: 400 }\r\n                    );\r\n                }\r\n                recommendations = await localRecommendationService.getSimilarDocuments(\r\n                    docId,\r\n                    { limit, offset }\r\n                );\r\n                break;\r\n\r\n            case 'related':\r\n                if (!query) {\r\n                    return NextResponse.json(\r\n                        {\r\n                            success: false,\r\n                            error: 'Missing required parameter for type=related: query',\r\n                        },\r\n                        { status: 400 }\r\n                    );\r\n                }\r\n                recommendations = await localRecommendationService.getRelatedDocuments(\r\n                    query,\r\n                    { limit, offset }\r\n                );\r\n                break;\r\n\r\n            case 'random':\r\n                recommendations = await localRecommendationService.getRandomDocuments({\r\n                    limit,\r\n                    offset,\r\n                });\r\n                break;\r\n\r\n            default:\r\n                return NextResponse.json(\r\n                    {\r\n                        success: false,\r\n                        error: `Unsupported type: ${type}`,\r\n                    },\r\n                    { status: 400 }\r\n                );\r\n        }\r\n\r\n        // Get total document count for context\r\n        const totalDocuments = await localRecommendationService.getDocumentCount();\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            type,\r\n            recommendations,\r\n            total: recommendations.length,\r\n            totalDocuments,\r\n            limit,\r\n            offset,\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching local recommendations:', error);\r\n\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: 'Failed to fetch recommendations',\r\n                details: error instanceof Error ? error.message : 'Unknown error',\r\n            },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}