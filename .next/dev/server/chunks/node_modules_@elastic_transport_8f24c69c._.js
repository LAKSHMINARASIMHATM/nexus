module.exports = [
"[project]/node_modules/@elastic/transport/lib/security.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.redactObject = redactObject;
exports.redactDiagnostic = redactDiagnostic;
const secretKeys = [
    'authorization',
    'password',
    'apikey',
    'x-elastic-app-auth'
];
/**
 * Clones an object and recursively loops through all keys, redacting their values if the key matches any of a list of strings.
 * @param obj: Object to clone and redact
 * @param additionalKeys: Extra keys that can be matched for redaction. Does not overwrite the default set.
 */ function redactObject(obj, additionalKeys = []) {
    const toRedact = [
        ...secretKeys,
        ...additionalKeys
    ].map((key)=>key.toLowerCase());
    // `seen` stores each Object it sees, so we can prevent infinite recursion due to circular references
    const seen = new Map();
    return doRedact(obj);
    //TURBOPACK unreachable
    ;
    function doRedact(obj) {
        if (typeof obj !== 'object' || obj == null) return obj;
        const newObj = {};
        Object.entries(obj).forEach(([key, value])=>{
            // pull auth info out of URL objects
            if (value instanceof URL) {
                value = `${value.origin}${value.pathname}${value.search}`;
            } else if (typeof value === 'object' && value !== null) {
                if (Array.isArray(value)) {
                    // if it's an array, redact each item
                    value = value.map((v)=>doRedact(v));
                } else {
                    if (seen.get(value) !== true) {
                        // if this Object hasn't been seen, recursively redact it
                        seen.set(value, true);
                        value = doRedact(value);
                    } else {
                        // if it has been seen, set the value that goes in newObj to null
                        // this is what prevents the circular references
                        value = null;
                    }
                }
            }
            // check if redaction is needed for this key
            if (toRedact.includes(key.toLowerCase())) {
                newObj[key] = '[redacted]';
            } else {
                newObj[key] = value;
            }
        });
        return newObj;
    }
}
/**
 * Redacts a DiagnosticResult object using the provided options.
 * - 'off' does nothing
 * - 'remove' removes most optional properties, replaces non-optional properties with the simplest possible alternative
 * - 'replace' runs `redactObject`, which replaces secret keys with `[redacted]`
 */ function redactDiagnostic(diag, options) {
    var _a;
    switch(options.type){
        case 'off':
            break;
        case 'remove':
            delete diag.headers;
            delete diag.meta.sniff;
            delete diag.meta.request.params.headers;
            diag.meta.request.options = {};
            diag.meta.connection = null;
            break;
        case 'replace':
            diag = redactObject(diag, (_a = options.additionalKeys) !== null && _a !== void 0 ? _a : []);
            break;
    }
    return diag;
} //# sourceMappingURL=security.js.map
}),
"[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProductNotSupportedError = exports.RequestAbortedError = exports.ResponseError = exports.ConfigurationError = exports.DeserializationError = exports.SerializationError = exports.NoLivingConnectionsError = exports.ConnectionError = exports.TimeoutError = exports.ElasticsearchClientError = void 0;
const security_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/security.js [app-route] (ecmascript)");
class ElasticsearchClientError extends Error {
    constructor(message, options){
        super(message);
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'ElasticsearchClientError';
        this.options = {
            redaction: {
                type: 'replace',
                additionalKeys: []
            }
        };
        if (isObject(options)) {
            this.options.redaction = {
                ...this.options.redaction,
                ...options.redaction
            };
        }
    }
}
exports.ElasticsearchClientError = ElasticsearchClientError;
class TimeoutError extends ElasticsearchClientError {
    constructor(message, meta, options){
        super(message, options);
        Object.defineProperty(this, "meta", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, TimeoutError);
        this.name = 'TimeoutError';
        this.message = message !== null && message !== void 0 ? message : 'Timeout Error';
        if (isObject(meta)) meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
        this.meta = meta;
    }
}
exports.TimeoutError = TimeoutError;
class ConnectionError extends ElasticsearchClientError {
    constructor(message, meta, options){
        super(message, options);
        Object.defineProperty(this, "meta", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, ConnectionError);
        this.name = 'ConnectionError';
        this.message = message !== null && message !== void 0 ? message : 'Connection Error';
        if (isObject(meta)) meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
        this.meta = meta;
    }
}
exports.ConnectionError = ConnectionError;
class NoLivingConnectionsError extends ElasticsearchClientError {
    constructor(message, meta, options){
        super(message, options);
        Object.defineProperty(this, "meta", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, NoLivingConnectionsError);
        this.name = 'NoLivingConnectionsError';
        this.message = message !== null && message !== void 0 ? message : 'Given the configuration, the ConnectionPool was not able to find a usable Connection for this request.';
        this.meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
    }
}
exports.NoLivingConnectionsError = NoLivingConnectionsError;
class SerializationError extends ElasticsearchClientError {
    constructor(message, data){
        super(message);
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, SerializationError);
        this.name = 'SerializationError';
        this.message = message !== null && message !== void 0 ? message : 'Serialization Error';
        this.data = data;
    }
}
exports.SerializationError = SerializationError;
class DeserializationError extends ElasticsearchClientError {
    constructor(message, data){
        super(message);
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, DeserializationError);
        this.name = 'DeserializationError';
        this.message = message !== null && message !== void 0 ? message : 'Deserialization Error';
        this.data = data;
    }
}
exports.DeserializationError = DeserializationError;
class ConfigurationError extends ElasticsearchClientError {
    constructor(message){
        super(message);
        Error.captureStackTrace(this, ConfigurationError);
        this.name = 'ConfigurationError';
        this.message = message !== null && message !== void 0 ? message : 'Configuration Error';
    }
}
exports.ConfigurationError = ConfigurationError;
class ResponseError extends ElasticsearchClientError {
    constructor(meta, options){
        var _a;
        super('Response Error', options);
        Object.defineProperty(this, "meta", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, ResponseError);
        this.name = 'ResponseError';
        if (isObject(meta.body) && meta.body.error != null && meta.body.error.type != null) {
            this.message = meta.body.error.type;
            if (isObject(meta.body.error.caused_by)) {
                const { type, reason } = meta.body.error.caused_by;
                const causedBy = [
                    '\tCaused by:',
                    `\t\t${type}: ${reason}`
                ].join('\n');
                this.message += `\n${causedBy}`;
            }
            if (Array.isArray(meta.body.error.root_cause) && meta.body.error.root_cause.length !== 0) {
                const formatRootCause = (entry)=>`\t\t${entry.type}: ${entry.reason}`;
                const rootCauses = [
                    '\tRoot causes:',
                    ...meta.body.error.root_cause.map(formatRootCause)
                ].join('\n');
                this.message += `\n${rootCauses}`;
            }
        } else if (typeof meta.body === 'object' && meta.body != null) {
            this.message = JSON.stringify(meta.body);
        } else {
            this.message = (_a = meta.body) !== null && _a !== void 0 ? _a : 'Response Error';
        }
        this.meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
    }
    get body() {
        return this.meta.body;
    }
    get statusCode() {
        if (isObject(this.meta.body) && typeof this.meta.body.status === 'number') {
            return this.meta.body.status;
        }
        return this.meta.statusCode;
    }
    get headers() {
        return this.meta.headers;
    }
}
exports.ResponseError = ResponseError;
class RequestAbortedError extends ElasticsearchClientError {
    constructor(message, meta, options){
        super(message, options);
        Object.defineProperty(this, "meta", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, RequestAbortedError);
        this.name = 'RequestAbortedError';
        this.message = message !== null && message !== void 0 ? message : 'Request aborted';
        if (isObject(meta)) meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
        this.meta = meta;
    }
}
exports.RequestAbortedError = RequestAbortedError;
class ProductNotSupportedError extends ElasticsearchClientError {
    constructor(product, meta, options){
        super('Product Not Supported Error', options);
        Object.defineProperty(this, "meta", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, ProductNotSupportedError);
        this.name = 'ProductNotSupportedError';
        this.message = `The client noticed that the server is not ${product} and we do not support this unknown product.`;
        if (isObject(meta)) meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
        this.meta = meta;
    }
}
exports.ProductNotSupportedError = ProductNotSupportedError;
function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
} //# sourceMappingURL=errors.js.map
}),
"[project]/node_modules/@elastic/transport/lib/Diagnostic.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.events = void 0;
const node_events_1 = __turbopack_context__.r("[externals]/node:events [external] (node:events, cjs)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)");
var events;
(function(events) {
    events["RESPONSE"] = "response";
    events["REQUEST"] = "request";
    events["SNIFF"] = "sniff";
    events["RESURRECT"] = "resurrect";
    events["SERIALIZATION"] = "serialization";
    events["DESERIALIZATION"] = "deserialization";
})(events || (exports.events = events = {}));
class Diagnostic extends node_events_1.EventEmitter {
    on(event, listener) {
        assertSupportedEvent(event);
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        assertSupportedEvent(event);
        super.once(event, listener);
        return this;
    }
    off(event, listener) {
        assertSupportedEvent(event);
        super.off(event, listener);
        return this;
    }
}
exports.default = Diagnostic;
function assertSupportedEvent(event) {
    if (!supportedEvents.includes(event)) {
        throw new errors_1.ConfigurationError(`The event '${event}' is not supported.`);
    }
}
// @ts-expect-error
const supportedEvents = Object.keys(events).map((key)=>events[key]); //# sourceMappingURL=Diagnostic.js.map
}),
"[project]/node_modules/@elastic/transport/lib/symbols.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.kOtelOptions = exports.kOtelTracer = exports.kRetryBackoff = exports.kRedaction = exports.kAcceptHeader = exports.kNdjsonContentType = exports.kJsonContentType = exports.kMaxCompressedResponseSize = exports.kMaxResponseSize = exports.kCaFingerprint = exports.kProductCheck = exports.kStatus = exports.kJsonOptions = exports.kNodeSelector = exports.kNodeFilter = exports.kHeaders = exports.kDiagnostic = exports.kSerializer = exports.kConnectionPool = exports.kContext = exports.kGenerateRequestId = exports.kOpaqueIdPrefix = exports.kName = exports.kMaxRetries = exports.kCompression = exports.kRetryOnTimeout = exports.kRequestTimeout = exports.kSniffEndpoint = exports.kSniffOnConnectionFault = exports.kSniffInterval = exports.kIsSniffing = exports.kNextSniff = exports.kSniffEnabled = void 0;
exports.kSniffEnabled = Symbol('sniff enabled');
exports.kNextSniff = Symbol('next sniff');
exports.kIsSniffing = Symbol('is sniffing');
exports.kSniffInterval = Symbol('sniff interval');
exports.kSniffOnConnectionFault = Symbol('sniff on connection fault');
exports.kSniffEndpoint = Symbol('sniff endpoint');
exports.kRequestTimeout = Symbol('request timeout');
exports.kRetryOnTimeout = Symbol('retry on timeout');
exports.kCompression = Symbol('compression');
exports.kMaxRetries = Symbol('max retries');
exports.kName = Symbol('name');
exports.kOpaqueIdPrefix = Symbol('opaque id prefix');
exports.kGenerateRequestId = Symbol('generate request id');
exports.kContext = Symbol('context');
exports.kConnectionPool = Symbol('connection pool');
exports.kSerializer = Symbol('serializer');
exports.kDiagnostic = Symbol('diagnostics');
exports.kHeaders = Symbol('headers');
exports.kNodeFilter = Symbol('node filter');
exports.kNodeSelector = Symbol('node selector');
exports.kJsonOptions = Symbol('secure json parse options');
exports.kStatus = Symbol('status');
exports.kProductCheck = Symbol('product check');
exports.kCaFingerprint = Symbol('ca fingerprint');
exports.kMaxResponseSize = Symbol('max response size');
exports.kMaxCompressedResponseSize = Symbol('max compressed response size');
exports.kJsonContentType = Symbol('json content type');
exports.kNdjsonContentType = Symbol('ndjson content type');
exports.kAcceptHeader = Symbol('accept header');
exports.kRedaction = Symbol('redaction');
exports.kRetryBackoff = Symbol('retry backoff');
exports.kOtelTracer = Symbol('opentelemetry tracer');
exports.kOtelOptions = Symbol('opentelemetry options'); //# sourceMappingURL=symbols.js.map
}),
"[project]/node_modules/@elastic/transport/lib/connection/BaseConnection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a, _b, _c;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.prepareHeaders = prepareHeaders;
exports.getIssuerCertificate = getIssuerCertificate;
exports.isCaFingerprintMatch = isCaFingerprintMatch;
exports.isBinary = isBinary;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_util_1 = __turbopack_context__.r("[externals]/node:util [external] (node:util, cjs)");
const Diagnostic_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/Diagnostic.js [app-route] (ecmascript)"));
const errors_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)");
const symbols_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/symbols.js [app-route] (ecmascript)");
/**
 * An HTTP connection to a single Elasticsearch node.
 */ class BaseConnection {
    constructor(opts){
        var _d, _e, _f, _g, _h, _j, _k;
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "deadCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resurrectTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_openRequests", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "weight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxEventListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "roles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _b, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _c, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.url = opts.url;
        this.tls = (_d = opts.tls) !== null && _d !== void 0 ? _d : null;
        this.id = (_e = opts.id) !== null && _e !== void 0 ? _e : stripAuth(opts.url.href);
        this.headers = prepareHeaders(opts.headers, opts.auth);
        this.timeout = (_f = opts.timeout) !== null && _f !== void 0 ? _f : null;
        this.deadCount = 0;
        this.resurrectTimeout = 0;
        this.weight = 0;
        this._openRequests = 0;
        this.maxEventListeners = (_g = opts.maxEventListeners) !== null && _g !== void 0 ? _g : 100;
        if (opts.roles != null) this.roles = opts.roles;
        this[symbols_1.kStatus] = (_h = opts.status) !== null && _h !== void 0 ? _h : BaseConnection.statuses.ALIVE;
        this[symbols_1.kDiagnostic] = (_j = opts.diagnostic) !== null && _j !== void 0 ? _j : new Diagnostic_1.default();
        this[symbols_1.kCaFingerprint] = (_k = opts.caFingerprint) !== null && _k !== void 0 ? _k : null;
        if (![
            'http:',
            'https:'
        ].includes(this.url.protocol)) {
            throw new errors_1.ConfigurationError(`Invalid protocol: '${this.url.protocol}'`);
        }
    }
    get status() {
        return this[symbols_1.kStatus];
    }
    set status(status) {
        if (!validStatuses.includes(status)) {
            throw new errors_1.ConfigurationError(`Unsupported status: '${status}'`);
        }
        this[symbols_1.kStatus] = status;
    }
    get diagnostic() {
        return this[symbols_1.kDiagnostic];
    }
    async request(params, options) {
        throw new errors_1.ConfigurationError('The request method should be implemented by extended classes');
    }
    /* istanbul ignore next */ async close() {
        throw new errors_1.ConfigurationError('The close method should be implemented by extended classes');
    }
    // Handles console.log and utils.inspect invocations.
    // We want to hide `auth`, `agent` and `tls` since they made
    // the logs very hard to read. The user can still
    // access them with `instance.agent` and `instance.tls`.
    [(_a = symbols_1.kStatus, _b = symbols_1.kCaFingerprint, _c = symbols_1.kDiagnostic, node_util_1.inspect.custom)](depth, options) {
        const { authorization, ...headers } = this.headers;
        return {
            url: stripAuth(this.url.toString()),
            id: this.id,
            headers,
            status: this.status
        };
    }
    toJSON() {
        const { authorization, ...headers } = this.headers;
        return {
            url: stripAuth(this.url.toString()),
            id: this.id,
            headers,
            status: this.status
        };
    }
}
Object.defineProperty(BaseConnection, "statuses", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        ALIVE: 'alive',
        DEAD: 'dead'
    }
});
exports.default = BaseConnection;
const validStatuses = Object.keys(BaseConnection.statuses)// @ts-expect-error
.map((k)=>BaseConnection.statuses[k]);
function stripAuth(url) {
    if (!url.includes('@')) return url;
    return url.slice(0, url.indexOf('//') + 2) + url.slice(url.indexOf('@') + 1);
}
function prepareHeaders(headers = {}, auth) {
    if (auth != null && headers.authorization == null) {
        /* istanbul ignore else */ if (isApiKeyAuth(auth)) {
            if (typeof auth.apiKey === 'object') {
                headers.authorization = 'ApiKey ' + Buffer.from(`${auth.apiKey.id}:${auth.apiKey.api_key}`).toString('base64');
            } else {
                headers.authorization = `ApiKey ${auth.apiKey}`;
            }
        } else if (isBearerAuth(auth)) {
            headers.authorization = `Bearer ${auth.bearer}`;
        } else if (auth.username != null && auth.password != null) {
            headers.authorization = 'Basic ' + Buffer.from(`${auth.username}:${auth.password}`).toString('base64');
        }
    }
    return headers;
}
function isApiKeyAuth(auth) {
    return auth.apiKey != null;
}
function isBearerAuth(auth) {
    return auth.bearer != null;
}
function getIssuerCertificate(socket) {
    let certificate = socket.getPeerCertificate(true);
    while(certificate !== null && Object.keys(certificate).length > 0){
        // invalid certificate
        if (certificate.issuerCertificate == null) {
            return null;
        }
        // We have reached the root certificate.
        // In case of self-signed certificates, `issuerCertificate` may be a circular reference.
        if (certificate.fingerprint256 === certificate.issuerCertificate.fingerprint256) {
            break;
        }
        // continue the loop
        certificate = certificate.issuerCertificate;
    }
    return certificate;
}
function isCaFingerprintMatch(cert1, cert2) {
    if (typeof cert1 === 'string' && typeof cert2 === 'string') {
        const c1 = cert1.toLowerCase().replace(/:/g, '');
        const c2 = cert2.toLowerCase().replace(/:/g, '');
        return c1 === c2;
    }
    return cert1 === cert2;
}
function isBinary(contentType) {
    const binaryTypes = [
        'application/vnd.mapbox-vector-tile',
        'application/vnd.apache.arrow.stream',
        'application/vnd.elasticsearch+arrow+stream',
        'application/smile',
        'application/vnd.elasticsearch+smile',
        'application/cbor',
        'application/vnd.elasticsearch+cbor'
    ];
    return binaryTypes.map((type)=>contentType.includes(type)).includes(true);
} //# sourceMappingURL=BaseConnection.js.map
}),
"[project]/node_modules/@elastic/transport/lib/Serializer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_querystring_1 = __turbopack_context__.r("[externals]/node:querystring [external] (node:querystring, cjs)");
const debug_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const secure_json_parse_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/secure-json-parse/index.js [app-route] (ecmascript)"));
const errors_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)");
const symbols_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/symbols.js [app-route] (ecmascript)");
const debug = (0, debug_1.default)('elasticsearch');
class Serializer {
    constructor(opts = {}){
        var _b;
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const enabled = (_b = opts.enablePrototypePoisoningProtection) !== null && _b !== void 0 ? _b : false;
        this[symbols_1.kJsonOptions] = {
            protoAction: enabled === true || enabled === 'proto' ? 'error' : 'ignore',
            constructorAction: enabled === true || enabled === 'constructor' ? 'error' : 'ignore'
        };
    }
    /**
     * Serializes a record into a JSON string
     */ serialize(object) {
        debug('Serializing', object);
        try {
            return JSON.stringify(object);
        } catch (err) {
            throw new errors_1.SerializationError(err.message, object);
        }
    }
    /**
     * Given a string, attempts to parse it from raw JSON into an object
     */ deserialize(json) {
        debug('Deserializing', json);
        try {
            return secure_json_parse_1.default.parse(json, this[symbols_1.kJsonOptions]);
        } catch (err) {
            throw new errors_1.DeserializationError(err.message, json);
        }
    }
    /**
     * Serializes an array of records into a ndjson string
     */ ndserialize(array) {
        debug('ndserialize', array);
        if (!Array.isArray(array)) {
            throw new errors_1.SerializationError('The argument provided is not an array', array);
        }
        let ndjson = '';
        for(let i = 0, len = array.length; i < len; i++){
            if (typeof array[i] === 'string') {
                ndjson += array[i] + '\n'; // eslint-disable-line
            } else {
                // @ts-expect-error
                ndjson += this.serialize(array[i]) + '\n'; // eslint-disable-line
            }
        }
        return ndjson;
    }
    qserialize(object) {
        debug('qserialize', object);
        if (object == null) return '';
        if (typeof object === 'string') return object;
        // arrays should be serialized as comma separated list
        const keys = Object.keys(object);
        for(let i = 0, len = keys.length; i < len; i++){
            const key = keys[i];
            // elasticsearch will complain about keys without a value
            if (object[key] === undefined) {
                delete object[key]; // eslint-disable-line
            } else if (Array.isArray(object[key])) {
                object[key] = object[key].join(',');
            }
        }
        return (0, node_querystring_1.stringify)(object);
    }
}
_a = symbols_1.kJsonOptions;
exports.default = Serializer; //# sourceMappingURL=Serializer.js.map
}),
"[project]/node_modules/@elastic/transport/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"@elastic/transport","version":"9.2.3","description":"Transport classes and utilities shared among Node.js Elastic client libraries","main":"./index.js","types":"index.d.ts","exports":{".":"./index.js","./package.json":"./package.json","./connection/BaseConnection":"./lib/connection/BaseConnection.js","./lib/connection/BaseConnection":"./lib/connection/BaseConnection.js","./pool/BaseConnectionPool":"./lib/pool/BaseConnectionPool.js","./lib/pool/BaseConnectionPool":"./lib/pool/BaseConnectionPool.js","./pool/CloudConnectionPool":"./lib/pool/CloudConnectionPool.js","./lib/pool/CloudConnectionPool":"./lib/pool/CloudConnectionPool.js","./pool/ClusterConnectionPool":"./lib/pool/ClusterConnectionPool.js","./lib/pool/ClusterConnectionPool":"./lib/pool/ClusterConnectionPool.js","./Diagnostic":"./lib/Diagnostic.js","./lib/Diagnostic":"./lib/Diagnostic.js","./errors":"./lib/errors.js","./lib/errors":"./lib/errors.js","./connection/HttpConnection":"./lib/connection/HttpConnection.js","./lib/connection/HttpConnection":"./lib/connection/HttpConnection.js","./connection":"./lib/connection/index.js","./lib/connection":"./lib/connection/index.js","./pool":"./lib/pool/index.js","./lib/pool":"./lib/pool/index.js","./security":"./lib/security.js","./lib/security":"./lib/security.js","./Serializer":"./lib/Serializer.js","./lib/Serializer":"./lib/Serializer.js","./symbols":"./lib/symbols.js","./lib/symbols":"./lib/symbols.js","./Transport":"./lib/Transport.js","./lib/Transport":"./lib/Transport.js","./types":"./lib/types.js","./lib/types":"./lib/types.js","./connection/UndiciConnection":"./lib/connection/UndiciConnection.js","./lib/connection/UndiciConnection":"./lib/connection/UndiciConnection.js","./pool/WeightedConnectionPool":"./lib/pool/WeightedConnectionPool.js","./lib/pool/WeightedConnectionPool":"./lib/pool/WeightedConnectionPool.js"},"scripts":{"test":"npm run build && npm run lint && tap","test:unit":"npm run build && tap test/unit/**/*.test.ts --disable-coverage","test:unit-bun":"bun run build && bunx tap test/unit/**/*.test.ts --disable-coverage","test:acceptance":"npm run build && tap test/acceptance/**/*.test.ts --disable-coverage","test:coverage-100":"npm run build && tap --show-full-coverage","test:coverage-report":"npm test && tap report --coverage-report=lcov","test:coverage-ui":"npm run build && tap --coverage-report=html","lint":"ts-standard src","lint:fix":"ts-standard --fix src","license-checker":"license-checker --production --onlyAllow='MIT;Apache-2.0;Apache1.1;ISC;BSD-3-Clause;BSD-2-Clause;0BSD'","license-header":"./scripts/check-spdx","prebuild":"npm run clean-build && npm run lint","build":"tsc","clean-build":"rimraf ./lib && mkdir lib","prepublishOnly":"npm run build","benchmark":"npm run build && npm run benchmark:mitata && npm run benchmark:gc","benchmark:mitata":"node --expose-gc test/benchmark/benchmark.mjs","benchmark:gc":"node --expose-gc test/benchmark/gc-tracking.mjs","benchmark:pr-comment":"node scripts/generate-pr-comment.mjs"},"repository":{"type":"git","url":"git+https://github.com/elastic/elastic-transport-js.git"},"keywords":[],"author":{"name":"Elastic Client Library Maintainers","company":"Elastic BV"},"license":"Apache-2.0","bugs":{"url":"https://github.com/elastic/elastic-transport-js/issues"},"homepage":"https://github.com/elastic/elastic-transport-js#readme","engines":{"node":">=20"},"devDependencies":{"@opentelemetry/sdk-trace-base":"1.30.1","@sinonjs/fake-timers":"14.0.0","@types/debug":"4.1.12","@types/ms":"2.1.0","@types/node":"22.17.1","@types/sinonjs__fake-timers":"8.1.5","@types/stoppable":"1.1.3","into-stream":"6.0.0","license-checker":"25.0.1","mitata":"^1.0.34","node-abort-controller":"3.1.1","proxy":"2.2.0","rimraf":"6.0.1","stoppable":"1.1.0","tap":"21.1.1","ts-node":"10.9.2","ts-standard":"12.0.2","typescript":"5.9.3","workq":"3.0.0"},"dependencies":{"@opentelemetry/api":"1.x","@opentelemetry/core":"2.x","debug":"^4.4.1","hpagent":"^1.2.0","ms":"^2.1.3","secure-json-parse":"^4.0.0","tslib":"^2.8.1","undici":"^7.16.0"},"tap":{"files":["test/unit/**/*.test.ts","test/acceptance/**/*.test.ts"],"allow-incomplete-coverage":true,"plugin":["@tapjs/before"]}});}),
"[project]/node_modules/@elastic/transport/lib/Transport.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateRequestId = generateRequestId;
exports.lowerCaseHeaders = lowerCaseHeaders;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const debug_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const node_os_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:os [external] (node:os, cjs)"));
const node_zlib_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:zlib [external] (node:zlib, cjs)"));
const node_buffer_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)"));
const node_util_1 = __turbopack_context__.r("[externals]/node:util [external] (node:util, cjs)");
const node_process_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:process [external] (node:process, cjs)"));
const ms_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ms/index.js [app-route] (ecmascript)"));
const errors_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)");
const BaseConnection_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/BaseConnection.js [app-route] (ecmascript)");
const Diagnostic_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/Diagnostic.js [app-route] (ecmascript)"));
const Serializer_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/Serializer.js [app-route] (ecmascript)"));
const symbols_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/symbols.js [app-route] (ecmascript)");
const promises_1 = __turbopack_context__.r("[externals]/node:timers/promises [external] (node:timers/promises, cjs)");
const api_1 = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@opentelemetry/api/build/esm/index.js [app-route] (ecmascript)"));
const core_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/core/build/esm/index.js [app-route] (ecmascript)");
const nodeVersion = node_process_1.default.versions.node;
const { version: clientVersion } = __turbopack_context__.r("[project]/node_modules/@elastic/transport/package.json (json)"); // eslint-disable-line
const debug = (0, debug_1.default)('elasticsearch');
const gzip = (0, node_util_1.promisify)(node_zlib_1.default.gzip);
const unzip = (0, node_util_1.promisify)(node_zlib_1.default.unzip);
const { createGzip } = node_zlib_1.default;
const userAgent = `elastic-transport-js/${clientVersion} (${node_os_1.default.platform()} ${node_os_1.default.release()}-${node_os_1.default.arch()}; Node.js ${node_process_1.default.version})`; // eslint-disable-line
class Transport {
    constructor(opts){
        var _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28;
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _b, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _c, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _d, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _e, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _f, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _g, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _h, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _j, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _k, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _l, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _m, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _o, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _p, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _q, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _r, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _s, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _t, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _u, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _v, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _w, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _x, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _y, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _z, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _0, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _1, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _2, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _3, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _4, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _5, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (opts.connectionPool == null) {
            throw new errors_1.ConfigurationError('The Connection Pool option is not defined');
        }
        if (typeof opts.maxRetries === 'number' && opts.maxRetries < 0 && Number.isInteger(opts.maxRetries)) {
            throw new errors_1.ConfigurationError('The maxRetries option must be a positive integer or zero');
        }
        if (opts.sniffInterval === true || typeof opts.sniffInterval === 'number' && opts.sniffInterval < 0 && Number.isInteger(opts.sniffInterval)) {
            throw new errors_1.ConfigurationError('The sniffInterval option must be false or a positive integer');
        }
        if (opts.maxResponseSize != null && opts.maxResponseSize > node_buffer_1.default.constants.MAX_STRING_LENGTH) {
            throw new errors_1.ConfigurationError(`The maxResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_STRING_LENGTH}`);
        }
        if (opts.maxCompressedResponseSize != null && opts.maxCompressedResponseSize > node_buffer_1.default.constants.MAX_LENGTH) {
            throw new errors_1.ConfigurationError(`The maxCompressedResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_LENGTH}`);
        }
        this[symbols_1.kNodeFilter] = (_6 = opts.nodeFilter) !== null && _6 !== void 0 ? _6 : defaultNodeFilter;
        this[symbols_1.kNodeSelector] = (_7 = opts.nodeSelector) !== null && _7 !== void 0 ? _7 : roundRobinSelector();
        this[symbols_1.kHeaders] = Object.assign({}, {
            'user-agent': userAgent
        }, (opts.enableMetaHeader == null ? true : opts.enableMetaHeader) ? {
            'x-elastic-client-meta': `et=${clientVersion},js=${nodeVersion}`
        } : null, opts.compression === true ? {
            'accept-encoding': 'gzip,deflate'
        } : null, lowerCaseHeaders(opts.headers));
        this[symbols_1.kDiagnostic] = (_8 = opts.diagnostic) !== null && _8 !== void 0 ? _8 : new Diagnostic_1.default();
        this[symbols_1.kConnectionPool] = opts.connectionPool;
        this[symbols_1.kSerializer] = (_9 = opts.serializer) !== null && _9 !== void 0 ? _9 : new Serializer_1.default();
        this[symbols_1.kContext] = (_10 = opts.context) !== null && _10 !== void 0 ? _10 : null;
        this[symbols_1.kGenerateRequestId] = (_11 = opts.generateRequestId) !== null && _11 !== void 0 ? _11 : generateRequestId();
        this[symbols_1.kOpaqueIdPrefix] = (_12 = opts.opaqueIdPrefix) !== null && _12 !== void 0 ? _12 : null;
        this[symbols_1.kName] = (_13 = opts.name) !== null && _13 !== void 0 ? _13 : 'elastic-transport-js';
        this[symbols_1.kMaxRetries] = typeof opts.maxRetries === 'number' ? opts.maxRetries : 3;
        this[symbols_1.kCompression] = opts.compression === true;
        this[symbols_1.kRequestTimeout] = opts.requestTimeout != null ? toMs(opts.requestTimeout) : null;
        this[symbols_1.kRetryOnTimeout] = opts.retryOnTimeout != null ? opts.retryOnTimeout : false;
        this[symbols_1.kSniffInterval] = (_14 = opts.sniffInterval) !== null && _14 !== void 0 ? _14 : false;
        this[symbols_1.kSniffEnabled] = typeof this[symbols_1.kSniffInterval] === 'number';
        this[symbols_1.kNextSniff] = this[symbols_1.kSniffEnabled] ? Date.now() + this[symbols_1.kSniffInterval] : 0;
        this[symbols_1.kIsSniffing] = false;
        this[symbols_1.kSniffOnConnectionFault] = (_15 = opts.sniffOnConnectionFault) !== null && _15 !== void 0 ? _15 : false;
        this[symbols_1.kSniffEndpoint] = (_16 = opts.sniffEndpoint) !== null && _16 !== void 0 ? _16 : null;
        this[symbols_1.kProductCheck] = (_17 = opts.productCheck) !== null && _17 !== void 0 ? _17 : null;
        this[symbols_1.kMaxResponseSize] = (_18 = opts.maxResponseSize) !== null && _18 !== void 0 ? _18 : node_buffer_1.default.constants.MAX_STRING_LENGTH;
        this[symbols_1.kMaxCompressedResponseSize] = (_19 = opts.maxCompressedResponseSize) !== null && _19 !== void 0 ? _19 : node_buffer_1.default.constants.MAX_LENGTH;
        this[symbols_1.kJsonContentType] = (_21 = (_20 = opts.vendoredHeaders) === null || _20 === void 0 ? void 0 : _20.jsonContentType) !== null && _21 !== void 0 ? _21 : 'application/json';
        this[symbols_1.kNdjsonContentType] = (_23 = (_22 = opts.vendoredHeaders) === null || _22 === void 0 ? void 0 : _22.ndjsonContentType) !== null && _23 !== void 0 ? _23 : 'application/x-ndjson';
        this[symbols_1.kAcceptHeader] = (_25 = (_24 = opts.vendoredHeaders) === null || _24 === void 0 ? void 0 : _24.accept) !== null && _25 !== void 0 ? _25 : 'application/json, text/plain';
        this[symbols_1.kRedaction] = (_26 = opts.redaction) !== null && _26 !== void 0 ? _26 : {
            type: 'replace',
            additionalKeys: []
        };
        this[symbols_1.kRetryBackoff] = (_27 = opts.retryBackoff) !== null && _27 !== void 0 ? _27 : retryBackoff;
        this[symbols_1.kOtelTracer] = api_1.default.trace.getTracer('@elastic/transport', clientVersion);
        const otelEnabledDefault = node_process_1.default.env.OTEL_ELASTICSEARCH_ENABLED != null ? node_process_1.default.env.OTEL_ELASTICSEARCH_ENABLED.toLowerCase() !== 'false' : true;
        this[symbols_1.kOtelOptions] = Object.assign({}, {
            enabled: otelEnabledDefault,
            suppressInternalInstrumentation: false
        }, (_28 = opts.openTelemetry) !== null && _28 !== void 0 ? _28 : {});
        if (opts.sniffOnStart === true) {
            this.sniff({
                reason: Transport.sniffReasons.SNIFF_ON_START,
                requestId: this[symbols_1.kGenerateRequestId]({
                    method: 'GET',
                    path: this[symbols_1.kSniffEndpoint]
                }, {
                    context: this[symbols_1.kContext]
                }),
                context: this[symbols_1.kContext]
            });
        }
    }
    get connectionPool() {
        return this[symbols_1.kConnectionPool];
    }
    get sniffEnabled() {
        return this[symbols_1.kSniffEnabled];
    }
    get nextSniff() {
        return this[symbols_1.kNextSniff];
    }
    get sniffEndpoint() {
        return this[symbols_1.kSniffEndpoint];
    }
    get isSniffing() {
        return this[symbols_1.kIsSniffing];
    }
    set isSniffing(val) {
        if (typeof val !== 'boolean') {
            throw new errors_1.ConfigurationError(`isSniffing must be a boolean, instead got ${typeof val}`);
        }
        this[symbols_1.kIsSniffing] = val;
    }
    get diagnostic() {
        return this[symbols_1.kDiagnostic];
    }
    async _request(params, options = {}, otelSpan) {
        var _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24;
        const connectionParams = {
            method: params.method,
            path: params.path
        };
        const meta = {
            context: null,
            request: {
                params: connectionParams,
                options,
                id: (_6 = options.id) !== null && _6 !== void 0 ? _6 : this[symbols_1.kGenerateRequestId](params, options)
            },
            name: this[symbols_1.kName],
            connection: null,
            attempts: 0,
            aborted: false
        };
        const returnMeta = (_7 = options.meta) !== null && _7 !== void 0 ? _7 : false;
        if (this[symbols_1.kContext] != null && options.context != null) {
            meta.context = Object.assign({}, this[symbols_1.kContext], options.context);
        } else if (this[symbols_1.kContext] !== null) {
            meta.context = this[symbols_1.kContext];
        } else if (options.context != null) {
            meta.context = options.context;
        }
        const result = {
            // the default body value can't be `null`
            // as it's a valid JSON value
            body: undefined,
            statusCode: 0,
            headers: {},
            meta,
            get warnings () {
                var _61;
                if (((_61 = this.headers) === null || _61 === void 0 ? void 0 : _61.warning) == null) {
                    return null;
                }
                const { warning } = this.headers;
                // if multiple HTTP headers have the same name, Undici represents them as an array
                const warnings = Array.isArray(warning) ? warning : [
                    warning
                ];
                return warnings.flatMap((w)=>w.split(/(?!\B"[^"]*),(?![^"]*"\B)/)).filter((warning)=>warning.match(/^\d\d\d Elasticsearch-/));
            }
        };
        // We should not retry if we are sending a stream body, because we should store in memory
        // a copy of the stream to be able to send it again, but since we don't know in advance
        // the size of the stream, we risk to take too much memory.
        // Furthermore, copying every time the stream is very a expensive operation.
        const maxRetries = isStream((_8 = params.body) !== null && _8 !== void 0 ? _8 : params.bulkBody) ? 0 : typeof options.maxRetries === 'number' ? options.maxRetries : this[symbols_1.kMaxRetries];
        const compression = typeof options.compression === 'boolean' ? options.compression : this[symbols_1.kCompression];
        const signal = options.signal;
        const maxResponseSize = (_9 = options.maxResponseSize) !== null && _9 !== void 0 ? _9 : this[symbols_1.kMaxResponseSize];
        const maxCompressedResponseSize = (_10 = options.maxCompressedResponseSize) !== null && _10 !== void 0 ? _10 : this[symbols_1.kMaxCompressedResponseSize];
        const errorOptions = {
            redaction: typeof options.redaction === 'object' ? options.redaction : this[symbols_1.kRedaction]
        };
        this[symbols_1.kDiagnostic].emit('serialization', null, result);
        const headers = Object.assign({}, this[symbols_1.kHeaders], lowerCaseHeaders(options.headers));
        if (options.opaqueId !== undefined) {
            headers['x-opaque-id'] = typeof this[symbols_1.kOpaqueIdPrefix] === 'string' ? this[symbols_1.kOpaqueIdPrefix] + options.opaqueId // eslint-disable-line
             : options.opaqueId;
        }
        // handle json body
        if (params.body != null) {
            if (shouldSerialize(params.body)) {
                try {
                    connectionParams.body = this[symbols_1.kSerializer].serialize(params.body);
                } catch (err) {
                    this[symbols_1.kDiagnostic].emit('request', err, result);
                    throw err;
                }
                headers['content-type'] = (_11 = headers['content-type']) !== null && _11 !== void 0 ? _11 : this[symbols_1.kJsonContentType];
                headers.accept = (_12 = headers.accept) !== null && _12 !== void 0 ? _12 : this[symbols_1.kJsonContentType];
            } else {
                if (params.body !== '') {
                    headers['content-type'] = (_13 = headers['content-type']) !== null && _13 !== void 0 ? _13 : 'text/plain';
                    headers.accept = (_14 = headers.accept) !== null && _14 !== void 0 ? _14 : this[symbols_1.kAcceptHeader];
                }
                connectionParams.body = params.body;
            }
        // handle ndjson body
        } else if (params.bulkBody != null) {
            if (shouldSerialize(params.bulkBody)) {
                try {
                    connectionParams.body = this[symbols_1.kSerializer].ndserialize(params.bulkBody);
                } catch (err) {
                    this[symbols_1.kDiagnostic].emit('request', err, result);
                    throw err;
                }
            } else {
                connectionParams.body = params.bulkBody;
            }
            if (connectionParams.body !== '') {
                headers['content-type'] = (_15 = headers['content-type']) !== null && _15 !== void 0 ? _15 : this[symbols_1.kNdjsonContentType];
                headers.accept = (_16 = headers.accept) !== null && _16 !== void 0 ? _16 : this[symbols_1.kJsonContentType];
            }
        }
        // serializes the querystring
        if (options.querystring == null) {
            connectionParams.querystring = this[symbols_1.kSerializer].qserialize(params.querystring);
        } else {
            connectionParams.querystring = this[symbols_1.kSerializer].qserialize(Object.assign({}, params.querystring, options.querystring));
        }
        // handle compression
        if (connectionParams.body !== '' && connectionParams.body != null) {
            if (isStream(connectionParams.body)) {
                if (compression) {
                    headers['content-encoding'] = 'gzip';
                    connectionParams.body = connectionParams.body.pipe(createGzip());
                }
            } else if (compression) {
                try {
                    connectionParams.body = await gzip(connectionParams.body);
                } catch (err) {
                    /* istanbul ignore next */ this[symbols_1.kDiagnostic].emit('request', err, result);
                    /* istanbul ignore next */ throw err;
                }
                headers['content-encoding'] = 'gzip';
                headers['content-length'] = '' + Buffer.byteLength(connectionParams.body); // eslint-disable-line
            } else {
                headers['content-length'] = '' + Buffer.byteLength(connectionParams.body); // eslint-disable-line
            }
        }
        headers.accept = (_17 = headers.accept) !== null && _17 !== void 0 ? _17 : this[symbols_1.kAcceptHeader];
        // Set default content-type header for empty requests
        // Only set if no content-type is already specified and there's no body
        if (headers['content-type'] == null && (connectionParams.body == null || connectionParams.body === '')) {
            headers['content-type'] = 'application/json';
        }
        connectionParams.headers = headers;
        while(meta.attempts <= maxRetries){
            // Capture start time for request duration tracking
            const startTime = node_process_1.default.hrtime.bigint();
            try {
                if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                    throw new errors_1.RequestAbortedError('Request has been aborted by the user', result, errorOptions);
                }
                meta.connection = this.getConnection({
                    requestId: meta.request.id,
                    context: meta.context
                });
                if (meta.connection === null) {
                    throw new errors_1.NoLivingConnectionsError('There are no living connections', result, errorOptions);
                }
                // generate required OpenTelemetry attributes from the request URL
                const requestUrl = meta.connection.url;
                otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttributes({
                    'url.full': requestUrl.toString(),
                    'server.address': requestUrl.hostname
                });
                if (requestUrl.port === '') {
                    if (requestUrl.protocol === 'https:') {
                        otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('server.port', 443);
                    } else if (requestUrl.protocol === 'http:') {
                        otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('server.port', 80);
                    }
                } else {
                    const port = parseInt(requestUrl.port, 10);
                    if (!Number.isNaN(port)) otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('server.port', port);
                }
                this[symbols_1.kDiagnostic].emit('request', null, result);
                // set timeout defaults
                let timeout = (_19 = (_18 = options.requestTimeout) !== null && _18 !== void 0 ? _18 : this[symbols_1.kRequestTimeout]) !== null && _19 !== void 0 ? _19 : undefined;
                if (timeout != null) timeout = toMs(timeout);
                // perform the actual http request
                let { statusCode, headers, body } = await meta.connection.request(connectionParams, {
                    requestId: meta.request.id,
                    name: this[symbols_1.kName],
                    context: meta.context,
                    maxResponseSize,
                    maxCompressedResponseSize,
                    signal,
                    timeout,
                    ...options.asStream === true ? {
                        asStream: true
                    } : null
                });
                result.statusCode = statusCode;
                result.headers = headers;
                otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('db.response.status_code', statusCode.toString());
                if (headers['x-found-handling-cluster'] != null) {
                    otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('db.namespace', headers['x-found-handling-cluster']);
                }
                if (headers['x-found-handling-instance'] != null) {
                    otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('elasticsearch.node.name', headers['x-found-handling-instance']);
                }
                if (this[symbols_1.kProductCheck] != null && headers['x-elastic-product'] !== this[symbols_1.kProductCheck] && statusCode >= 200 && statusCode < 300) {
                    /* eslint-disable @typescript-eslint/prefer-ts-expect-error */ // @ts-ignore
                    throw new errors_1.ProductNotSupportedError(this[symbols_1.kProductCheck], result, errorOptions);
                /* eslint-enable @typescript-eslint/prefer-ts-expect-error */ }
                if (options.asStream === true) {
                    result.body = body;
                    // Calculate request duration in milliseconds
                    const endTime = node_process_1.default.hrtime.bigint();
                    meta.duration = Number(endTime - startTime) / 1e6;
                    this[symbols_1.kDiagnostic].emit('response', null, result);
                    return returnMeta ? result : body;
                }
                const contentEncoding = ((_20 = headers['content-encoding']) !== null && _20 !== void 0 ? _20 : '').toLowerCase();
                if (contentEncoding.includes('gzip') || contentEncoding.includes('deflate')) {
                    body = await unzip(body);
                }
                if (Buffer.isBuffer(body) && !(0, BaseConnection_1.isBinary)((_21 = headers['content-type']) !== null && _21 !== void 0 ? _21 : '')) {
                    body = body.toString();
                }
                const isHead = params.method === 'HEAD';
                // we should attempt the payload deserialization only if:
                //    - a `content-type` is defined and is equal to `application/json`
                //    - the request is not a HEAD request
                //    - the payload is not an empty string
                if (headers['content-type'] !== undefined && (((_22 = headers['content-type']) === null || _22 === void 0 ? void 0 : _22.includes('application/json')) || ((_23 = headers['content-type']) === null || _23 === void 0 ? void 0 : _23.includes('application/vnd.elasticsearch+json'))) && !isHead && body !== '') {
                    result.body = this[symbols_1.kSerializer].deserialize(body);
                } else {
                    // cast to boolean if the request method was HEAD and there was no error
                    result.body = isHead && statusCode < 400 ? true : body;
                }
                // we should ignore the statusCode if the user has configured the `ignore` field with
                // the statusCode we just got or if the request method is HEAD and the statusCode is 404
                const ignoreStatusCode = Array.isArray(options.ignore) && options.ignore.includes(statusCode) || isHead && statusCode === 404;
                if (!ignoreStatusCode && (statusCode === 502 || statusCode === 503 || statusCode === 504)) {
                    // if the statusCode is 502/3/4 we should run our retry strategy
                    // and mark the connection as dead
                    this[symbols_1.kConnectionPool].markDead(meta.connection);
                    // retry logic
                    if (meta.attempts < maxRetries) {
                        meta.attempts++;
                        debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);
                        continue;
                    }
                } else {
                    // everything has worked as expected, let's mark
                    // the connection as alive (or confirm it)
                    this[symbols_1.kConnectionPool].markAlive(meta.connection);
                }
                if (!ignoreStatusCode && statusCode >= 400) {
                    throw new errors_1.ResponseError(result, errorOptions);
                } else {
                    // cast to boolean if the request method was HEAD
                    if (isHead && statusCode === 404) {
                        result.body = false;
                    }
                    // Calculate request duration in milliseconds
                    const endTime = node_process_1.default.hrtime.bigint();
                    meta.duration = Number(endTime - startTime) / 1e6;
                    this[symbols_1.kDiagnostic].emit('response', null, result);
                    return returnMeta ? result : result.body;
                }
            } catch (error) {
                // Calculate request duration in milliseconds
                const endTime = node_process_1.default.hrtime.bigint();
                meta.duration = Number(endTime - startTime) / 1e6;
                switch(error.name){
                    // should not retry
                    case 'ProductNotSupportedError':
                    case 'NoLivingConnectionsError':
                    case 'DeserializationError':
                    case 'ResponseError':
                        this[symbols_1.kDiagnostic].emit('response', error, result);
                        throw error;
                    case 'RequestAbortedError':
                        {
                            meta.aborted = true;
                            // Wrap the error to get a clean stack trace
                            const wrappedError = new errors_1.RequestAbortedError(error.message, result, errorOptions);
                            this[symbols_1.kDiagnostic].emit('response', wrappedError, result);
                            throw wrappedError;
                        }
                    // should maybe retry
                    // @ts-expect-error `case` fallthrough is intentional: should retry if retryOnTimeout is true
                    case 'TimeoutError':
                        if (!this[symbols_1.kRetryOnTimeout]) {
                            const wrappedError = new errors_1.TimeoutError(error.message, result, errorOptions);
                            this[symbols_1.kDiagnostic].emit('response', wrappedError, result);
                            throw wrappedError;
                        }
                    // should retry
                    // eslint-disable-next-line no-fallthrough
                    case 'ConnectionError':
                        {
                            // if there is an error in the connection
                            // let's mark the connection as dead
                            this[symbols_1.kConnectionPool].markDead(meta.connection);
                            if (this[symbols_1.kSniffOnConnectionFault]) {
                                this.sniff({
                                    reason: Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,
                                    requestId: meta.request.id,
                                    context: meta.context
                                });
                            }
                            // retry logic
                            if (meta.attempts < maxRetries) {
                                meta.attempts++;
                                debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);
                                // don't use exponential backoff until retrying on each node
                                if (meta.attempts >= this[symbols_1.kConnectionPool].size) {
                                    // exponential backoff on retries, with jitter
                                    const backoff = (_24 = options.retryBackoff) !== null && _24 !== void 0 ? _24 : this[symbols_1.kRetryBackoff];
                                    const backoffWait = backoff(0, 4, meta.attempts);
                                    if (backoffWait > 0) {
                                        await (0, promises_1.setTimeout)(backoffWait * 1000);
                                    }
                                }
                                continue;
                            }
                            // Wrap the error to get a clean stack trace
                            const wrappedError = error.name === 'TimeoutError' ? new errors_1.TimeoutError(error.message, result, errorOptions) : new errors_1.ConnectionError(error.message, result, errorOptions);
                            this[symbols_1.kDiagnostic].emit('response', wrappedError, result);
                            throw wrappedError;
                        }
                    // edge cases, such as bad compression
                    default:
                        this[symbols_1.kDiagnostic].emit('response', error, result);
                        throw error;
                }
            }
        }
        return returnMeta ? result : result.body;
    }
    async request(params, options = {}) {
        var _6, _7, _8, _9, _10, _11;
        const otelOptions = Object.assign({}, this[symbols_1.kOtelOptions], (_6 = options.openTelemetry) !== null && _6 !== void 0 ? _6 : {});
        // wrap in OpenTelemetry span
        if (((_7 = otelOptions === null || otelOptions === void 0 ? void 0 : otelOptions.enabled) !== null && _7 !== void 0 ? _7 : true) && ((_8 = params.meta) === null || _8 === void 0 ? void 0 : _8.name) != null) {
            let context = api_1.default.context.active();
            if ((_9 = otelOptions.suppressInternalInstrumentation) !== null && _9 !== void 0 ? _9 : false) {
                context = (0, core_1.suppressTracing)(context);
            }
            // gather OpenTelemetry attributes
            const attributes = {
                'db.system': 'elasticsearch',
                'http.request.method': params.method,
                'db.operation.name': (_10 = params.meta) === null || _10 === void 0 ? void 0 : _10.name
            };
            // add path params as otel attributes
            if (((_11 = params.meta) === null || _11 === void 0 ? void 0 : _11.pathParts) != null) {
                for (const [key, value] of Object.entries(params.meta.pathParts)){
                    if (value == null) continue;
                    attributes[`db.operation.parameter.${key}`] = value.toString();
                    if ([
                        'index',
                        '_index',
                        'indices'
                    ].includes(key)) {
                        let indices = [];
                        if (typeof value === 'string') {
                            indices.push(value);
                        } else if (Array.isArray(value)) {
                            indices = indices.concat(value.map((v)=>v.toString()));
                        } else if (typeof value === 'object') {
                            try {
                                const keys = Object.keys(value);
                                indices = indices.concat(keys.map((v)=>v.toString()));
                            } catch  {
                            // ignore
                            }
                        }
                        if (indices.length > 0) attributes['db.collection.name'] = indices.join(', ');
                    }
                }
            }
            return await this[symbols_1.kOtelTracer].startActiveSpan(params.meta.name, {
                attributes,
                kind: api_1.SpanKind.CLIENT
            }, context, async (otelSpan)=>{
                var _6;
                let response;
                try {
                    response = await this._request(params, options, otelSpan);
                } catch (err) {
                    otelSpan.recordException(err);
                    otelSpan.setStatus({
                        code: api_1.SpanStatusCode.ERROR
                    });
                    otelSpan.setAttribute('error.type', (_6 = err.name) !== null && _6 !== void 0 ? _6 : 'Error');
                    throw err;
                } finally{
                    otelSpan.end();
                }
                return response;
            });
        } else {
            return await this._request(params, options);
        }
    }
    getConnection(opts) {
        const now = Date.now();
        if (this[symbols_1.kSniffEnabled] && now > this[symbols_1.kNextSniff]) {
            this[symbols_1.kNextSniff] = now + this[symbols_1.kSniffInterval];
            this.sniff({
                reason: Transport.sniffReasons.SNIFF_INTERVAL,
                requestId: opts.requestId,
                context: opts.context
            });
        }
        return this[symbols_1.kConnectionPool].getConnection({
            filter: this[symbols_1.kNodeFilter],
            selector: this[symbols_1.kNodeSelector],
            requestId: opts.requestId,
            name: this[symbols_1.kName],
            context: opts.context,
            now
        });
    }
    /* istanbul ignore next */ sniff(opts) {}
}
_a = symbols_1.kNodeFilter, _b = symbols_1.kNodeSelector, _c = symbols_1.kHeaders, _d = symbols_1.kDiagnostic, _e = symbols_1.kConnectionPool, _f = symbols_1.kSerializer, _g = symbols_1.kContext, _h = symbols_1.kGenerateRequestId, _j = symbols_1.kOpaqueIdPrefix, _k = symbols_1.kName, _l = symbols_1.kMaxRetries, _m = symbols_1.kCompression, _o = symbols_1.kRequestTimeout, _p = symbols_1.kRetryOnTimeout, _q = symbols_1.kSniffEnabled, _r = symbols_1.kNextSniff, _s = symbols_1.kIsSniffing, _t = symbols_1.kSniffInterval, _u = symbols_1.kSniffOnConnectionFault, _v = symbols_1.kSniffEndpoint, _w = symbols_1.kProductCheck, _x = symbols_1.kMaxResponseSize, _y = symbols_1.kMaxCompressedResponseSize, _z = symbols_1.kJsonContentType, _0 = symbols_1.kNdjsonContentType, _1 = symbols_1.kAcceptHeader, _2 = symbols_1.kRedaction, _3 = symbols_1.kRetryBackoff, _4 = symbols_1.kOtelTracer, _5 = symbols_1.kOtelOptions;
Object.defineProperty(Transport, "sniffReasons", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        SNIFF_ON_START: 'sniff-on-start',
        SNIFF_INTERVAL: 'sniff-interval',
        SNIFF_ON_CONNECTION_FAULT: 'sniff-on-connection-fault',
        DEFAULT: 'default'
    }
});
exports.default = Transport;
function toMs(time) {
    if (typeof time === 'string') {
        return (0, ms_1.default)(time);
    }
    return time;
}
function shouldSerialize(obj) {
    return typeof obj !== 'string' && typeof obj.pipe !== 'function' && !Buffer.isBuffer(obj);
}
function isStream(obj) {
    return obj != null && typeof obj.pipe === 'function';
}
function defaultNodeFilter(node) {
    return true;
}
function roundRobinSelector() {
    let current = -1;
    return function _roundRobinSelector(connections) {
        if (++current >= connections.length) {
            current = 0;
        }
        return connections[current];
    };
}
function generateRequestId() {
    const maxInt = 2147483647;
    let nextReqId = 0;
    return function genReqId(params, options) {
        return nextReqId = nextReqId + 1 & maxInt;
    };
}
function lowerCaseHeaders(oldHeaders) {
    if (oldHeaders == null) return null;
    const newHeaders = {};
    for(const header in oldHeaders){
        // @ts-expect-error
        newHeaders[header.toLowerCase()] = oldHeaders[header];
    }
    return newHeaders;
}
/**
 * Function for calculating how long to sleep, in seconds, before the next request retry
 * Uses the AWS "equal jitter" algorithm noted in this post:
 * https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
 * @param min The minimum number of seconds to wait
 * @param max The maximum number of seconds to wait
 * @param attempt How many retry attempts have been made
 * @returns The number of seconds to wait before the next retry
 */ function retryBackoff(min, max, attempt) {
    const ceiling = Math.min(max, 2 ** attempt) / 2;
    return ceiling + (Math.random() * (ceiling - min) + min);
} //# sourceMappingURL=Transport.js.map
}),
"[project]/node_modules/@elastic/transport/lib/connection/HttpConnection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
/* eslint-disable @typescript-eslint/restrict-template-expressions */ const hpagent_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/hpagent/index.js [app-route] (ecmascript)"));
const node_http_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:http [external] (node:http, cjs)"));
const node_https_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:https [external] (node:https, cjs)"));
const debug_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const node_buffer_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)"));
const BaseConnection_1 = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/BaseConnection.js [app-route] (ecmascript)"));
const symbols_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/symbols.js [app-route] (ecmascript)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)");
const promises_1 = __turbopack_context__.r("[externals]/node:timers/promises [external] (node:timers/promises, cjs)");
const debug = (0, debug_1.default)('elasticsearch');
const INVALID_PATH_REGEX = /[^\u0021-\u00ff]/;
const MAX_BUFFER_LENGTH = node_buffer_1.default.constants.MAX_LENGTH;
const MAX_STRING_LENGTH = node_buffer_1.default.constants.MAX_STRING_LENGTH;
const noop = ()=>{};
/**
 * A connection to an Elasticsearch node, managed by the `http` client in the standard library
 */ class HttpConnection extends BaseConnection_1.default {
    constructor(opts){
        super(opts);
        Object.defineProperty(this, "agent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "makeRequest", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (typeof opts.agent === 'function') {
            this.agent = opts.agent(opts);
        } else if (typeof opts.agent === 'boolean') {
            this.agent = undefined;
        } else {
            if (opts.agent != null && !isHttpAgentOptions(opts.agent)) {
                throw new errors_1.ConfigurationError('Bad agent configuration for Http agent');
            }
            const agentOptions = Object.assign({}, {
                keepAlive: true,
                keepAliveMsecs: 1000,
                maxSockets: 256,
                maxFreeSockets: 256,
                scheduling: 'lifo'
            }, opts.agent);
            if (opts.proxy != null) {
                const proxyAgentOptions = {
                    ...agentOptions,
                    proxy: opts.proxy
                };
                this.agent = this.url.protocol === 'http:' ? new hpagent_1.default.HttpProxyAgent(proxyAgentOptions) : new hpagent_1.default.HttpsProxyAgent(Object.assign({}, proxyAgentOptions, this.tls));
            } else {
                this.agent = this.url.protocol === 'http:' ? new node_http_1.default.Agent(agentOptions) : new node_https_1.default.Agent(Object.assign({}, agentOptions, this.tls));
            }
        }
        this.makeRequest = this.url.protocol === 'http:' ? node_http_1.default.request : node_https_1.default.request;
    }
    async request(params, options) {
        return await new Promise((resolve, reject)=>{
            var _a, _b;
            let cleanedListeners = false;
            const maxResponseSize = (_a = options.maxResponseSize) !== null && _a !== void 0 ? _a : MAX_STRING_LENGTH;
            const maxCompressedResponseSize = (_b = options.maxCompressedResponseSize) !== null && _b !== void 0 ? _b : MAX_BUFFER_LENGTH;
            const requestParams = this.buildRequestObject(params, options);
            // https://github.com/nodejs/node/commit/b961d9fd83
            if (INVALID_PATH_REGEX.test(requestParams.path)) {
                return reject(new TypeError(`ERR_UNESCAPED_CHARACTERS: ${requestParams.path}`));
            }
            debug('Starting a new request', params);
            // tracking response.end, request.finish and the value of the returnable response object here is necessary:
            // we only know a request is truly finished when one of the following is true:
            // - request.finish and response.end have both fired (success)
            // - request.error has fired (failure)
            // - response.close has fired (failure)
            let responseEnded = false;
            let requestFinished = false;
            let connectionRequestResponse;
            let request;
            try {
                request = this.makeRequest(requestParams);
            } catch (err) {
                return reject(err);
            }
            const abortListener = ()=>{
                request.destroy(new errors_1.RequestAbortedError('Request aborted'));
            };
            this._openRequests++;
            if (options.signal != null) {
                options.signal.addEventListener('abort', abortListener, {
                    once: true
                });
            }
            let response;
            const onResponseClose = ()=>{
                return reject(new errors_1.ConnectionError('Connection closed while reading the body'));
            };
            const onResponse = (res)=>{
                var _a, _b;
                response = res;
                cleanListeners();
                if (options.asStream === true) {
                    return resolve({
                        body: response,
                        statusCode: response.statusCode,
                        headers: response.headers
                    });
                }
                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();
                const isCompressed = contentEncoding.includes('gzip') || contentEncoding.includes('deflate');
                const bodyIsBinary = (0, BaseConnection_1.isBinary)((_b = response.headers['content-type']) !== null && _b !== void 0 ? _b : '');
                /* istanbul ignore else */ if (response.headers['content-length'] !== undefined) {
                    const contentLength = Number(response.headers['content-length']);
                    if (isCompressed && contentLength > maxCompressedResponseSize) {
                        response.destroy();
                        return reject(new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`));
                    } else if (contentLength > maxResponseSize) {
                        response.destroy();
                        return reject(new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${maxResponseSize})`));
                    }
                }
                // if the response is compressed, we must handle it
                // as buffer for allowing decompression later
                let payload = isCompressed || bodyIsBinary ? new Array() : '';
                const onData = isCompressed || bodyIsBinary ? onDataAsBuffer : onDataAsString;
                let currentLength = 0;
                function onDataAsBuffer(chunk) {
                    currentLength += Buffer.byteLength(chunk);
                    if (currentLength > maxCompressedResponseSize) {
                        response.destroy(new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`));
                    } else {
                        payload.push(chunk);
                    }
                }
                function onDataAsString(chunk) {
                    currentLength += Buffer.byteLength(chunk);
                    if (currentLength > maxResponseSize) {
                        response.destroy(new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed string (${maxResponseSize})`));
                    } else {
                        payload = `${payload}${chunk}`;
                    }
                }
                const onEnd = ()=>{
                    response.removeListener('data', onData);
                    response.removeListener('end', onEnd);
                    responseEnded = true;
                    connectionRequestResponse = {
                        body: isCompressed || bodyIsBinary ? Buffer.concat(payload) : payload,
                        statusCode: response.statusCode,
                        headers: response.headers
                    };
                    if (requestFinished) {
                        response.removeListener('close', onResponseClose);
                        return resolve(connectionRequestResponse);
                    }
                };
                if (!isCompressed && !bodyIsBinary) {
                    response.setEncoding('utf8');
                }
                this.diagnostic.emit('deserialization', null, options);
                response.on('data', onData);
                response.on('end', onEnd);
                response.on('close', onResponseClose);
            };
            const onTimeout = ()=>{
                cleanListeners();
                request.once('error', noop); // we need to catch the request aborted error
                request.destroy();
                return reject(new errors_1.TimeoutError('Request timed out'));
            };
            const onError = (err)=>{
                var _a, _b, _c, _d, _e, _f, _g, _h;
                // @ts-expect-error
                let { name, message, code } = err;
                // ignore this error, it means we got a response body for a request that didn't expect a body (e.g. HEAD)
                // rather than failing, let it return a response with an empty string as body
                if (code === 'HPE_INVALID_CONSTANT' && message.startsWith('Parse Error: Expected HTTP/')) return;
                cleanListeners();
                if (name === 'RequestAbortedError') {
                    return reject(err);
                }
                if (code === 'ECONNRESET') {
                    message += ` - Local: ${(_b = (_a = request.socket) === null || _a === void 0 ? void 0 : _a.localAddress) !== null && _b !== void 0 ? _b : 'unknown'}:${(_d = (_c = request.socket) === null || _c === void 0 ? void 0 : _c.localPort) !== null && _d !== void 0 ? _d : 'unknown'}, Remote: ${(_f = (_e = request.socket) === null || _e === void 0 ? void 0 : _e.remoteAddress) !== null && _f !== void 0 ? _f : 'unknown'}:${(_h = (_g = request.socket) === null || _g === void 0 ? void 0 : _g.remotePort) !== null && _h !== void 0 ? _h : 'unknown'}`;
                } else if (code === 'EPIPE') {
                    message = 'Response aborted while reading the body';
                }
                return reject(new errors_1.ConnectionError(message));
            };
            const onSocket = (socket)=>{
                /* istanbul ignore else */ if (!socket.isSessionReused()) {
                    socket.once('secureConnect', ()=>{
                        const issuerCertificate = (0, BaseConnection_1.getIssuerCertificate)(socket);
                        /* istanbul ignore next */ if (issuerCertificate == null) {
                            onError(new Error('Invalid or malformed certificate'));
                            request.once('error', noop); // we need to catch the request aborted error
                            return request.destroy();
                        }
                        // Check if fingerprint matches
                        /* istanbul ignore else */ if (!(0, BaseConnection_1.isCaFingerprintMatch)(this[symbols_1.kCaFingerprint], issuerCertificate.fingerprint256)) {
                            onError(new Error('Server certificate CA fingerprint does not match the value configured in caFingerprint'));
                            request.once('error', noop); // we need to catch the request aborted error
                            return request.destroy();
                        }
                    });
                }
            };
            const onFinish = ()=>{
                requestFinished = true;
                if (responseEnded) {
                    response === null || response === void 0 ? void 0 : response.removeListener('close', onResponseClose);
                    if (connectionRequestResponse != null) {
                        return resolve(connectionRequestResponse);
                    } else {
                        return reject(new Error('No response body received'));
                    }
                }
            };
            const cleanListeners = ()=>{
                if (cleanedListeners) return;
                this._openRequests--;
                // we do NOT stop listening to request.error here
                // all errors we care about in the request/response lifecycle will bubble up to request.error, and may occur even after the request has been sent
                request.removeListener('response', onResponse);
                request.removeListener('timeout', onTimeout);
                request.removeListener('socket', onSocket);
                if (options.signal != null) {
                    if ('removeEventListener' in options.signal) {
                        options.signal.removeEventListener('abort', abortListener);
                    } else {
                        options.signal.removeListener('abort', abortListener);
                    }
                }
                cleanedListeners = true;
            };
            request.on('response', onResponse);
            request.on('timeout', onTimeout);
            request.on('error', onError);
            request.on('finish', onFinish);
            if (this[symbols_1.kCaFingerprint] != null && requestParams.protocol === 'https:') {
                request.on('socket', onSocket);
            }
            // Disables the Nagle algorithm
            request.setNoDelay(true);
            // starts the request
            if (isStream(params.body)) {
                (0, node_stream_1.pipeline)(params.body, request, (err)=>{
                    /* istanbul ignore if  */ if (err != null && !cleanedListeners) {
                        cleanListeners();
                        return reject(err);
                    }
                });
            } else {
                request.end(params.body);
            }
        });
    }
    async close() {
        debug('Closing connection', this.id);
        while(this._openRequests > 0){
            await (0, promises_1.setTimeout)(1000);
        }
        /* istanbul ignore else */ if (this.agent !== undefined) {
            this.agent.destroy();
        }
    }
    buildRequestObject(params, options) {
        var _a, _b;
        const url = this.url;
        let search = url.search;
        let pathname = url.pathname;
        const request = {
            protocol: url.protocol,
            hostname: url.hostname[0] === '[' ? url.hostname.slice(1, -1) : url.hostname,
            path: '',
            // https://github.com/elastic/elasticsearch-js/issues/843
            port: url.port !== '' ? url.port : undefined,
            headers: this.headers,
            agent: this.agent,
            // only set a timeout if it has a value; default to no timeout
            // see https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-network.html#_http_client_configuration
            timeout: (_b = (_a = options.timeout) !== null && _a !== void 0 ? _a : this.timeout) !== null && _b !== void 0 ? _b : undefined
        };
        const paramsKeys = Object.keys(params);
        for(let i = 0, len = paramsKeys.length; i < len; i++){
            const key = paramsKeys[i];
            if (key === 'path') {
                pathname = resolve(pathname, params[key]);
            } else if (key === 'querystring' && Boolean(params[key])) {
                if (search === '') {
                    search = `?${params[key]}`;
                } else {
                    search += `&${params[key]}`;
                }
            } else if (key === 'headers') {
                request.headers = Object.assign({}, request.headers, params.headers);
            } else {
                // @ts-expect-error
                request[key] = params[key];
            }
        }
        request.path = pathname + search;
        return request;
    }
}
exports.default = HttpConnection;
function isStream(obj) {
    return obj != null && typeof obj.pipe === 'function';
}
function resolve(host, path) {
    const hostEndWithSlash = host[host.length - 1] === '/';
    const pathStartsWithSlash = path[0] === '/';
    if (hostEndWithSlash && pathStartsWithSlash) {
        return host + path.slice(1);
    } else if (hostEndWithSlash !== pathStartsWithSlash) {
        return host + path;
    } else {
        return host + '/' + path;
    }
}
/* istanbul ignore next */ function isHttpAgentOptions(opts) {
    if (opts.keepAliveTimeout != null) return false;
    if (opts.keepAliveMaxTimeout != null) return false;
    if (opts.keepAliveTimeoutThreshold != null) return false;
    if (opts.pipelining != null) return false;
    if (opts.maxHeaderSize != null) return false;
    if (opts.connections != null) return false;
    return true;
} //# sourceMappingURL=HttpConnection.js.map
}),
"[project]/node_modules/@elastic/transport/lib/connection/UndiciConnection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
/* eslint-disable @typescript-eslint/restrict-template-expressions */ const debug_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const node_buffer_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)"));
const BaseConnection_1 = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/BaseConnection.js [app-route] (ecmascript)"));
const undici_1 = __turbopack_context__.r("[project]/node_modules/undici/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)");
const symbols_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/symbols.js [app-route] (ecmascript)");
const debug = (0, debug_1.default)('elasticsearch');
const INVALID_PATH_REGEX = /[^\u0021-\u00ff]/;
const MAX_BUFFER_LENGTH = node_buffer_1.default.constants.MAX_LENGTH;
const MAX_STRING_LENGTH = node_buffer_1.default.constants.MAX_STRING_LENGTH;
/**
 * A connection to an Elasticsearch node, managed by the Undici HTTP client library
 */ class Connection extends BaseConnection_1.default {
    constructor(opts){
        var _a, _b, _c;
        super(opts);
        Object.defineProperty(this, "pool", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (opts.proxy != null) {
            throw new errors_1.ConfigurationError('Undici connection can\'t work with proxies');
        }
        if (typeof opts.agent === 'boolean') {
            throw new errors_1.ConfigurationError('Undici connection agent options can\'t be a boolean');
        }
        // if agent is a function, its returned value must be an Undici object with a `request()` function that works the same as Pool.request()
        // NOTE: providing an agent function will ignore built-in handling of `caFingerprint` and `tls` options, so they must be handled by the implementer
        if (typeof opts.agent === 'function') {
            this.pool = opts.agent(opts);
        } else {
            if (opts.agent != null && !isUndiciAgentOptions(opts.agent)) {
                throw new errors_1.ConfigurationError('Bad agent configuration for Undici agent');
            }
            const undiciOptions = {
                keepAliveTimeout: 600e3,
                keepAliveMaxTimeout: 600e3,
                keepAliveTimeoutThreshold: 1000,
                pipelining: 1,
                maxHeaderSize: 16384,
                connections: 256,
                // only set a timeout if it has a value; default to no timeout
                // see https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-network.html#_http_client_configuration
                headersTimeout: (_a = this.timeout) !== null && _a !== void 0 ? _a : 0,
                bodyTimeout: (_b = this.timeout) !== null && _b !== void 0 ? _b : 0,
                ...opts.agent
            };
            if (this[symbols_1.kCaFingerprint] !== null) {
                const caFingerprint = this[symbols_1.kCaFingerprint];
                const connector = (0, undici_1.buildConnector)((_c = this.tls) !== null && _c !== void 0 ? _c : {});
                undiciOptions.connect = function(opts, cb) {
                    connector(opts, (err, socket)=>{
                        if (err != null) {
                            return cb(err, null);
                        }
                        if (caFingerprint !== null && isTlsSocket(opts, socket)) {
                            const issuerCertificate = (0, BaseConnection_1.getIssuerCertificate)(socket);
                            /* istanbul ignore next */ if (issuerCertificate == null) {
                                socket.destroy();
                                return cb(new Error('Invalid or malformed certificate'), null);
                            }
                            // Certificate will be empty if a session is reused. In this case, getPeerCertificate
                            // will return an empty object, causing a fingeprint check to fail. But, if the session
                            // is being reused, it means this socket's peer certificate fingerprint has already been
                            // checked, so we can skip it and assume the connection is secure.
                            // See https://github.com/nodejs/node/issues/3940#issuecomment-166696776
                            if (Object.keys(issuerCertificate).length === 0 && socket.isSessionReused()) {
                                return cb(null, socket);
                            }
                            // Check if fingerprint matches
                            /* istanbul ignore else */ if (!(0, BaseConnection_1.isCaFingerprintMatch)(caFingerprint, issuerCertificate.fingerprint256)) {
                                socket.destroy();
                                return cb(new Error('Server certificate CA fingerprint does not match the value configured in caFingerprint'), null);
                            }
                        }
                        return cb(null, socket);
                    });
                };
            } else if (this.tls !== null) {
                undiciOptions.connect = this.tls;
            }
            this.pool = new undici_1.Pool(this.url.toString(), undiciOptions);
        }
    }
    async request(params, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const maxResponseSize = (_a = options.maxResponseSize) !== null && _a !== void 0 ? _a : MAX_STRING_LENGTH;
        const maxCompressedResponseSize = (_b = options.maxCompressedResponseSize) !== null && _b !== void 0 ? _b : MAX_BUFFER_LENGTH;
        const requestParams = {
            origin: this.url,
            method: params.method,
            path: params.path + (params.querystring == null || params.querystring === '' ? '' : `?${params.querystring}`),
            headers: Object.assign({}, this.headers, params.headers),
            body: params.body,
            signal: (_c = options.signal) !== null && _c !== void 0 ? _c : new AbortController().signal
        };
        if (requestParams.path[0] !== '/') {
            requestParams.path = `/${requestParams.path}`;
        }
        // undici does not support per-request timeouts,
        // to address this issue, we default to the constructor
        // timeout (which is handled by undici) and create a local
        // setTimeout callback if the request-specific timeout
        // is different from the constructor timeout.
        let timedout = false;
        let timeoutId;
        if (options.timeout != null && options.timeout !== this.timeout) {
            timeoutId = setTimeout(()=>{
                timedout = true;
                requestParams.signal.dispatchEvent(new Event('abort'));
            }, options.timeout);
        }
        // https://github.com/nodejs/node/commit/b961d9fd83
        if (INVALID_PATH_REGEX.test(requestParams.path)) {
            throw new TypeError(`ERR_UNESCAPED_CHARACTERS: ${requestParams.path}`);
        }
        debug('Starting a new request', params);
        let response;
        try {
            response = await this.pool.request(requestParams);
            if (timeoutId != null) clearTimeout(timeoutId);
        } catch (err) {
            if (timeoutId != null) clearTimeout(timeoutId);
            switch(err.code){
                case 'UND_ERR_ABORTED':
                case DOMException.ABORT_ERR:
                    throw timedout ? new errors_1.TimeoutError('Request timed out') : new errors_1.RequestAbortedError('Request aborted');
                case 'UND_ERR_HEADERS_TIMEOUT':
                    throw new errors_1.TimeoutError('Request timed out');
                case 'UND_ERR_SOCKET':
                    throw new errors_1.ConnectionError(`${err.message} - Local: ${(_e = (_d = err.socket) === null || _d === void 0 ? void 0 : _d.localAddress) !== null && _e !== void 0 ? _e : 'unknown'}:${(_g = (_f = err.socket) === null || _f === void 0 ? void 0 : _f.localPort) !== null && _g !== void 0 ? _g : 'unknown'}, Remote: ${(_j = (_h = err.socket) === null || _h === void 0 ? void 0 : _h.remoteAddress) !== null && _j !== void 0 ? _j : 'unknown'}:${(_l = (_k = err.socket) === null || _k === void 0 ? void 0 : _k.remotePort) !== null && _l !== void 0 ? _l : 'unknown'}`); // eslint-disable-line
                default:
                    throw new errors_1.ConnectionError(err.message);
            }
        }
        if (options.asStream === true) {
            return {
                statusCode: response.statusCode,
                headers: response.headers,
                body: response.body
            };
        }
        // @ts-expect-error Assume header is not string[] for now.
        const contentEncoding = ((_m = response.headers['content-encoding']) !== null && _m !== void 0 ? _m : '').toLowerCase();
        const isCompressed = contentEncoding.includes('gzip') || contentEncoding.includes('deflate'); // eslint-disable-line
        const bodyIsBinary = (0, BaseConnection_1.isBinary)((_o = response.headers['content-type']) !== null && _o !== void 0 ? _o : '');
        /* istanbul ignore else */ if (response.headers['content-length'] !== undefined) {
            const contentLength = Number(response.headers['content-length']);
            if (isCompressed && contentLength > maxCompressedResponseSize) {
                response.body.destroy();
                throw new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`);
            } else if (contentLength > maxResponseSize) {
                response.body.destroy();
                throw new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${maxResponseSize})`);
            }
        }
        this.diagnostic.emit('deserialization', null, options);
        try {
            if (isCompressed || bodyIsBinary) {
                let currentLength = 0;
                const payload = [];
                for await (const chunk of response.body){
                    currentLength += Buffer.byteLength(chunk);
                    if (currentLength > maxCompressedResponseSize) {
                        response.body.destroy();
                        throw new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`);
                    }
                    payload.push(chunk);
                }
                return {
                    statusCode: response.statusCode,
                    headers: response.headers,
                    body: Buffer.concat(payload)
                };
            } else {
                const payload = [];
                let currentLength = 0;
                response.body.setEncoding('utf8');
                for await (const chunk of response.body){
                    currentLength += Buffer.byteLength(chunk);
                    if (currentLength > maxResponseSize) {
                        response.body.destroy();
                        throw new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed string (${maxResponseSize})`);
                    }
                    payload.push(chunk);
                }
                return {
                    statusCode: response.statusCode,
                    headers: response.headers,
                    body: Buffer.concat(payload).toString('utf8')
                };
            }
        } catch (err) {
            if (err.name === 'RequestAbortedError') {
                throw err;
            }
            throw new errors_1.ConnectionError(err.message);
        }
    }
    async close() {
        debug('Closing connection', this.id);
        await this.pool.close();
    }
}
exports.default = Connection;
/* istanbul ignore next */ function isUndiciAgentOptions(opts) {
    if (opts.keepAlive != null) return false;
    if (opts.keepAliveMsecs != null) return false;
    if (opts.maxSockets != null) return false;
    if (opts.maxFreeSockets != null) return false;
    if (opts.scheduling != null) return false;
    if (opts.proxy != null) return false;
    return true;
}
function isTlsSocket(opts, socket) {
    return socket !== null && opts.protocol === 'https:';
} //# sourceMappingURL=UndiciConnection.js.map
}),
"[project]/node_modules/@elastic/transport/lib/connection/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UndiciConnection = exports.HttpConnection = exports.BaseConnection = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const BaseConnection_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/BaseConnection.js [app-route] (ecmascript)"));
exports.BaseConnection = BaseConnection_1.default;
const HttpConnection_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/HttpConnection.js [app-route] (ecmascript)"));
exports.HttpConnection = HttpConnection_1.default;
const UndiciConnection_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/UndiciConnection.js [app-route] (ecmascript)"));
exports.UndiciConnection = UndiciConnection_1.default; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultNodeFilter = defaultNodeFilter;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_url_1 = __turbopack_context__.r("[externals]/node:url [external] (node:url, cjs)");
const debug_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const Diagnostic_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/Diagnostic.js [app-route] (ecmascript)"));
const symbols_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/symbols.js [app-route] (ecmascript)");
const connection_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)");
const debug = (0, debug_1.default)('elasticsearch');
function defaultNodeFilter(conn) {
    if (conn.roles != null) {
        if (// avoid master-only nodes
        conn.roles.master && !conn.roles.data && !conn.roles.ingest && !conn.roles.ml) return false;
    }
    return true;
}
/**
 * Manages the HTTP connections to each Elasticsearch node,
 * keeping track of which are currently dead or alive, and
 * provides the functionality for deciding which node to send
 * a request to.
 */ class BaseConnectionPool {
    constructor(opts){
        var _b;
        Object.defineProperty(this, "connections", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "Connection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "diagnostic", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "auth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_agent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_proxy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // list of nodes and weights
        this.connections = [];
        // how many nodes we have in our scheduler
        this.size = this.connections.length;
        this.Connection = opts.Connection;
        this.diagnostic = (_b = opts.diagnostic) !== null && _b !== void 0 ? _b : new Diagnostic_1.default();
        this.auth = opts.auth;
        this._tls = opts.tls;
        this._agent = opts.agent;
        this._proxy = opts.proxy;
        this[symbols_1.kCaFingerprint] = opts.caFingerprint;
    }
    markAlive(connection) {
        connection.status = connection_1.BaseConnection.statuses.ALIVE;
        return this;
    }
    markDead(connection) {
        connection.status = connection_1.BaseConnection.statuses.DEAD;
        return this;
    }
    getConnection(opts) {
        throw new errors_1.ConfigurationError('The getConnection method should be implemented by extended classes');
    }
    /**
     * Creates a new connection instance.
     */ createConnection(opts) {
        if (typeof opts === 'string') {
            opts = this.urlToHost(opts);
        }
        if (this.auth != null) {
            opts.auth = this.auth;
        } else if (opts.url.username !== '' && opts.url.password !== '') {
            opts.auth = {
                username: decodeURIComponent(opts.url.username),
                password: decodeURIComponent(opts.url.password)
            };
        }
        /* istanbul ignore else */ if (opts.tls == null) opts.tls = this._tls;
        /* istanbul ignore else */ if (opts.agent == null) opts.agent = this._agent;
        /* istanbul ignore else */ if (opts.proxy == null) opts.proxy = this._proxy;
        /* istanbul ignore else */ if (opts.diagnostic == null) opts.diagnostic = this.diagnostic;
        /* istanbul ignore else */ if (opts.caFingerprint == null) opts.caFingerprint = this[symbols_1.kCaFingerprint];
        const connection = new this.Connection(opts);
        for (const conn of this.connections){
            if (conn.id === connection.id) {
                throw new Error(`Connection with id '${connection.id}' is already present`);
            }
        }
        return connection;
    }
    /**
     * Adds a new connection to the pool.
     *
     * @param connection Connection options, or the URL of a node
     * @returns This ConnectionPool instance
     */ addConnection(connection) {
        if (Array.isArray(connection)) {
            const connections = [];
            for (const conn of connection){
                connections.push(this.createConnection(conn));
            }
            return this.update([
                ...this.connections,
                ...connections
            ]);
        } else {
            return this.update([
                ...this.connections,
                this.createConnection(connection)
            ]);
        }
    }
    /**
     * Removes a connection from the pool.
     *
     * @param connection The connection to remove
     * @returns This ConnectionPool instance
     */ removeConnection(connection) {
        debug('Removing connection', connection);
        return this.update(this.connections.filter((c)=>c.id !== connection.id));
    }
    /**
     * Empties the connection pool.
     *
     * @returns {ConnectionPool}
     */ async empty() {
        debug('Emptying the connection pool');
        const connections = this.connections;
        this.connections = [];
        this.size = 0;
        for (const connection of connections){
            await connection.close();
        }
    }
    /**
     * Update the ConnectionPool with new connections.
     *
     * @param nodes array of connections
     * @returns {ConnectionPool}
     */ update(nodes) {
        debug('Updating the connection pool');
        const newConnections = [];
        const oldConnections = [];
        for (const node of nodes){
            // if we already have a given connection in the pool
            // we mark it as alive and we do not close the connection
            // to avoid socket issues
            const connectionById = this.connections.find((c)=>c.id === node.id);
            const connectionByUrl = this.connections.find((c)=>c.id === node.url.href);
            if (connectionById != null) {
                debug(`The connection with id '${node.id}' is already present`);
                this.markAlive(connectionById);
                newConnections.push(connectionById);
            // in case the user has passed a single url (or an array of urls),
            // the connection id will be the full href; to avoid closing valid connections
            // because are not present in the pool, we check also the node url,
            // and if is already present we update its id with the ES provided one.
            } else if (connectionByUrl != null) {
                connectionByUrl.id = node.id;
                this.markAlive(connectionByUrl);
                newConnections.push(connectionByUrl);
            } else {
                if (node instanceof connection_1.BaseConnection) {
                    newConnections.push(node);
                } else {
                    newConnections.push(this.createConnection(node));
                }
            }
        }
        const ids = nodes.map((c)=>c.id);
        // remove all the dead connections and old connections
        for (const connection of this.connections){
            if (!ids.includes(connection.id)) {
                oldConnections.push(connection);
            }
        }
        // close old connections
        for (const connection of oldConnections){
            connection.close().catch(/* istanbul ignore next */ ()=>{});
        }
        this.connections = newConnections;
        this.size = this.connections.length;
        return this;
    }
    /**
     * Transforms the nodes objects to a host object.
     *
     * @param {object} nodes
     * @returns {array} hosts
     */ nodesToHost(nodes, protocol) {
        const ids = Object.keys(nodes);
        const hosts = [];
        for(let i = 0, len = ids.length; i < len; i++){
            const node = nodes[ids[i]];
            // newly-added nodes do not have http assigned yet, so skip
            if (node.http === undefined) continue;
            // If there is no protocol in
            // the `publish_address` new URL will throw
            // the publish_address can have two forms:
            //   - ip:port
            //   - hostname/ip:port
            // if we encounter the second case, we should
            // use the hostname instead of the ip
            let address = node.http.publish_address;
            const parts = address.split('/');
            // the url is in the form of hostname/ip:port
            if (parts.length > 1) {
                const hostname = parts[0];
                const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1);
                address = `${hostname}:${port}`;
            }
            address = address.slice(0, 4) === 'http' ? address : `${protocol}//${address}`;
            hosts.push({
                url: new node_url_1.URL(address),
                id: ids[i]
            });
        }
        return hosts;
    }
    /**
     * Transforms an url string to a host object
     *
     * @param {string} url
     * @returns {object} host
     */ urlToHost(url) {
        return {
            url: new node_url_1.URL(url)
        };
    }
}
_a = symbols_1.kCaFingerprint;
exports.default = BaseConnectionPool; //# sourceMappingURL=BaseConnectionPool.js.map
}),
"[project]/node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const connection_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/index.js [app-route] (ecmascript)");
const BaseConnectionPool_1 = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js [app-route] (ecmascript)"));
class WeightedConnectionPool extends BaseConnectionPool_1.default {
    constructor(opts){
        super(opts);
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxWeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "greatestCommonDivisor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "currentWeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // index choosen last time
        this.index = -1;
        // max weight of all nodes
        this.maxWeight = 0;
        // greatest common divisor of all nodes weights
        this.greatestCommonDivisor = 0;
        // current weight in scheduling
        this.currentWeight = 0;
    }
    /**
     * Returns a connection, even if the connection might be dead.
     *
     * @param {object} options (filter)
     * @returns {object|null} connection
     */ getConnection(opts) {
        const filter = opts.filter != null ? opts.filter : BaseConnectionPool_1.defaultNodeFilter;
        // we should be able to find the next node in 1 array scan,
        // if we don't, it means that we are in an infinite loop
        let counter = 0;
        while(counter++ < this.size){
            // 0 <= index < size
            this.index = (this.index + 1) % this.size;
            if (this.index === 0) {
                this.currentWeight = this.currentWeight - this.greatestCommonDivisor;
                if (this.currentWeight <= 0) {
                    this.currentWeight = this.maxWeight;
                    /* istanbul ignore if */ if (this.currentWeight === 0) {
                        return null;
                    }
                }
            }
            const connection = this.connections[this.index];
            if (connection.weight >= this.currentWeight && filter(connection)) {
                return connection;
            }
        }
        return null;
    }
    /**
     * Set the weight of a connection to the maximum value.
     * If sniffing is not enabled and there is only
     * one node, this method is a noop.
     *
     * @param {object} connection
     */ markAlive(connection) {
        if (this.size === 1 || connection.status === connection_1.BaseConnection.statuses.ALIVE) return this;
        connection.status = connection_1.BaseConnection.statuses.ALIVE;
        connection.deadCount = 0;
        connection.weight = Math.round(1000 / this.size);
        this.maxWeight = Math.max(...this.connections.map((c)=>c.weight));
        this.greatestCommonDivisor = this.connections.map((c)=>c.weight).reduce(getGreatestCommonDivisor, 0);
        return this;
    }
    /**
     * Decreases the connection weight.
     * If sniffing is not enabled and there is only
     * one node, this method is a noop.
     *
     * @param {object} connection
     */ markDead(connection) {
        if (this.size === 1) return this;
        connection.status = connection_1.BaseConnection.statuses.DEAD;
        connection.deadCount++;
        connection.weight -= Math.round(Math.pow(Math.log2(connection.weight), connection.deadCount));
        /* istanbul ignore if */ if (connection.weight <= 0) connection.weight = 1;
        this.maxWeight = Math.max(...this.connections.map((c)=>c.weight));
        this.greatestCommonDivisor = this.connections.map((c)=>c.weight).reduce(getGreatestCommonDivisor, 0);
        return this;
    }
    /**
     * Empties the connection pool.
     *
     * @returns {ConnectionPool}
     */ async empty() {
        await super.empty();
        this.maxWeight = 0;
        this.greatestCommonDivisor = 0;
        this.index = -1;
        this.currentWeight = 0;
    }
    /**
     * Update the ConnectionPool with new connections.
     *
     * @param {array} array of connections
     * @returns {ConnectionPool}
     */ update(connections) {
        super.update(connections);
        this.connections.forEach((connection)=>{
            connection.weight = Math.round(1000 / this.size);
        });
        this.maxWeight = Math.max(...this.connections.map((c)=>c.weight));
        this.greatestCommonDivisor = this.connections.map((c)=>c.weight).reduce(getGreatestCommonDivisor, 0);
        this.index = -1;
        this.currentWeight = 0;
        return this;
    }
}
exports.default = WeightedConnectionPool;
function getGreatestCommonDivisor(a, b) {
    if (b === 0) return a;
    return getGreatestCommonDivisor(b, a % b);
} //# sourceMappingURL=WeightedConnectionPool.js.map
}),
"[project]/node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const BaseConnectionPool_1 = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js [app-route] (ecmascript)"));
const node_assert_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:assert [external] (node:assert, cjs)"));
const debug_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const connection_1 = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/index.js [app-route] (ecmascript)");
const debug = (0, debug_1.default)('elasticsearch');
class ClusterConnectionPool extends BaseConnectionPool_1.default {
    constructor(opts){
        var _a, _b, _c;
        super(opts);
        Object.defineProperty(this, "dead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resurrectTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resurrectTimeoutCutoff", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pingTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resurrectStrategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "roundRobinIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "useWeightedRoundRobin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dead = [];
        this.roundRobinIndex = 0;
        this.useWeightedRoundRobin = (_a = opts.useWeightedRoundRobin) !== null && _a !== void 0 ? _a : false;
        // the resurrect timeout is 60s
        this.resurrectTimeout = 1000 * 60;
        // number of consecutive failures after which
        // the timeout doesn't increase
        this.resurrectTimeoutCutoff = 5;
        this.pingTimeout = (_b = opts.pingTimeout) !== null && _b !== void 0 ? _b : 3000;
        const resurrectStrategy = (_c = opts.resurrectStrategy) !== null && _c !== void 0 ? _c : 'ping';
        this.resurrectStrategy = ClusterConnectionPool.resurrectStrategies[resurrectStrategy];
        (0, node_assert_1.default)(this.resurrectStrategy != null, `Invalid resurrection strategy: '${resurrectStrategy}'`);
    }
    /**
     * Marks a connection as 'alive'.
     * If needed removes the connection from the dead list
     * and then resets the `deadCount`.
     *
     * @param {object} connection
     */ markAlive(connection) {
        const { id } = connection;
        debug(`Marking as 'alive' connection '${id}'`);
        const index = this.dead.indexOf(id);
        if (index > -1) this.dead.splice(index, 1);
        connection.status = connection_1.BaseConnection.statuses.ALIVE;
        connection.deadCount = 0;
        connection.resurrectTimeout = 0;
        return this;
    }
    /**
     * Marks a connection as 'dead'.
     * If needed adds the connection to the dead list
     * and then increments the `deadCount`.
     *
     * @param {object} connection
     */ markDead(connection) {
        const { id } = connection;
        debug(`Marking as 'dead' connection '${id}'`);
        if (!this.dead.includes(id)) {
            // It might happen that `markDead` is called jsut after
            // a pool update, and in such case we will add to the dead
            // list a node that no longer exist. The following check verify
            // that the connection is still part of the pool before
            // marking it as dead.
            for(let i = 0; i < this.size; i++){
                if (this.connections[i].id === id) {
                    this.dead.push(id);
                    break;
                }
            }
        }
        connection.status = connection_1.BaseConnection.statuses.DEAD;
        connection.deadCount++;
        // resurrectTimeout formula:
        // `resurrectTimeout * 2 ** min(deadCount - 1, resurrectTimeoutCutoff)`
        connection.resurrectTimeout = Date.now() + this.resurrectTimeout * Math.pow(2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff));
        // sort the dead list in ascending order
        // based on the resurrectTimeout
        this.dead.sort((a, b)=>{
            const conn1 = this.connections.find((c)=>c.id === a);
            const conn2 = this.connections.find((c)=>c.id === b);
            return conn1.resurrectTimeout - conn2.resurrectTimeout;
        });
        return this;
    }
    /**
     * If enabled, tries to resurrect a connection with the given
     * resurrect strategy ('ping', 'optimistic', 'none').
     *
     * @param {object} { now, requestId }
     */ resurrect(opts) {
        if (this.resurrectStrategy === 0 || this.dead.length === 0) {
            debug('Nothing to resurrect');
            return;
        }
        // the dead list is sorted in ascending order based on the timeout
        // so the first element will always be the one with the smaller timeout
        const connection = this.connections.find((c)=>c.id === this.dead[0]);
        if (opts.now < connection.resurrectTimeout) {
            debug('Nothing to resurrect');
            return;
        }
        const { id } = connection;
        // ping strategy
        if (this.resurrectStrategy === 1) {
            connection.request({
                method: 'HEAD',
                path: '/'
            }, {
                timeout: this.pingTimeout,
                requestId: opts.requestId,
                name: opts.name,
                context: opts.context
            }).then(({ statusCode })=>{
                let isAlive = true;
                if (statusCode === 502 || statusCode === 503 || statusCode === 504) {
                    debug(`Resurrect: connection '${id}' is still dead`);
                    this.markDead(connection);
                    isAlive = false;
                } else {
                    debug(`Resurrect: connection '${id}' is now alive`);
                    this.markAlive(connection);
                }
                this.diagnostic.emit('resurrect', null, {
                    strategy: 'ping',
                    name: opts.name,
                    request: {
                        id: opts.requestId
                    },
                    isAlive,
                    connection
                });
            }).catch((err)=>{
                this.markDead(connection);
                this.diagnostic.emit('resurrect', err, {
                    strategy: 'ping',
                    name: opts.name,
                    request: {
                        id: opts.requestId
                    },
                    isAlive: false,
                    connection
                });
            });
        // optimistic strategy
        } else {
            debug(`Resurrect: optimistic resurrection for connection '${id}'`);
            this.dead.splice(this.dead.indexOf(id), 1);
            connection.status = connection_1.BaseConnection.statuses.ALIVE;
            this.diagnostic.emit('resurrect', null, {
                strategy: 'optimistic',
                name: opts.name,
                request: {
                    id: opts.requestId
                },
                isAlive: true,
                connection
            });
        }
    }
    roundRobinSelector(connections) {
        if (connections.length === 0) return null;
        const selected = connections[this.roundRobinIndex % connections.length];
        this.roundRobinIndex = (this.roundRobinIndex + 1) % connections.length;
        return selected;
    }
    weightedRoundRobinSelector(connections) {
        var _a, _b;
        if (connections.length === 0) return null;
        let totalWeight = 0;
        for (const conn of connections){
            totalWeight += (_a = conn.weight) !== null && _a !== void 0 ? _a : 1;
        }
        if (totalWeight === 0) {
            return this.roundRobinSelector(connections);
        }
        let currentWeight = 0;
        const targetWeight = this.roundRobinIndex % totalWeight;
        for (const conn of connections){
            currentWeight += (_b = conn.weight) !== null && _b !== void 0 ? _b : 1;
            if (currentWeight > targetWeight) {
                this.roundRobinIndex = (this.roundRobinIndex + 1) % totalWeight;
                return conn;
            }
        }
        return connections[0];
    }
    /**
     * Returns an alive connection if present,
     * otherwise returns a dead connection.
     * By default it filters the `master` only nodes.
     * It uses the selector to choose which
     * connection return.
     *
     * @param {object} options (filter and selector)
     * @returns {object|null} connection
     */ getConnection(opts) {
        const filter = opts.filter != null ? opts.filter : BaseConnectionPool_1.defaultNodeFilter;
        const selector = opts.selector != null ? opts.selector : this.useWeightedRoundRobin ? this.weightedRoundRobinSelector.bind(this) : this.roundRobinSelector.bind(this);
        this.resurrect({
            now: opts.now,
            requestId: opts.requestId,
            name: opts.name,
            context: opts.context
        });
        const noAliveConnections = this.size === this.dead.length;
        // TODO: can we cache this?
        const connections = [];
        for(let i = 0; i < this.size; i++){
            const connection = this.connections[i];
            if (noAliveConnections || connection.status === connection_1.BaseConnection.statuses.ALIVE) {
                if (filter(connection)) {
                    connections.push(connection);
                }
            }
        }
        if (connections.length === 0) return null;
        return selector(connections);
    }
    /**
     * Empties the connection pool.
     *
     * @returns {ConnectionPool}
     */ async empty() {
        await super.empty();
        this.dead = [];
        this.roundRobinIndex = 0;
    }
    /**
     * Update the ConnectionPool with new connections.
     *
     * @param {array} array of connections
     * @returns {ConnectionPool}
     */ update(connections) {
        super.update(connections);
        this.dead = [];
        this.roundRobinIndex = 0;
        return this;
    }
}
Object.defineProperty(ClusterConnectionPool, "resurrectStrategies", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        none: 0,
        ping: 1,
        optimistic: 2
    }
});
exports.default = ClusterConnectionPool; //# sourceMappingURL=ClusterConnectionPool.js.map
}),
"[project]/node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const BaseConnectionPool_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js [app-route] (ecmascript)"));
class CloudConnectionPool extends BaseConnectionPool_1.default {
    constructor(opts){
        super(opts);
        Object.defineProperty(this, "cloudConnection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.cloudConnection = null;
    }
    /**
     * Returns the only cloud connection.
     *
     * @returns {object} connection
     */ getConnection(opts) {
        return this.cloudConnection;
    }
    /**
     * Empties the connection pool.
     *
     * @returns {ConnectionPool}
     */ async empty() {
        await super.empty();
        this.cloudConnection = null;
    }
    /**
     * Update the ConnectionPool with new connections.
     *
     * @param {array} array of connections
     * @returns {ConnectionPool}
     */ update(connections) {
        super.update(connections);
        this.cloudConnection = this.connections[0];
        return this;
    }
}
exports.default = CloudConnectionPool; //# sourceMappingURL=CloudConnectionPool.js.map
}),
"[project]/node_modules/@elastic/transport/lib/pool/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CloudConnectionPool = exports.ClusterConnectionPool = exports.WeightedConnectionPool = exports.BaseConnectionPool = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const BaseConnectionPool_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js [app-route] (ecmascript)"));
exports.BaseConnectionPool = BaseConnectionPool_1.default;
const WeightedConnectionPool_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js [app-route] (ecmascript)"));
exports.WeightedConnectionPool = WeightedConnectionPool_1.default;
const ClusterConnectionPool_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js [app-route] (ecmascript)"));
exports.ClusterConnectionPool = ClusterConnectionPool_1.default;
const CloudConnectionPool_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js [app-route] (ecmascript)"));
exports.CloudConnectionPool = CloudConnectionPool_1.default; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@elastic/transport/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */ const { default: Diagnostic, events } = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/Diagnostic.js [app-route] (ecmascript)");
const Transport = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/Transport.js [app-route] (ecmascript)").default;
const { BaseConnection, HttpConnection, UndiciConnection } = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/connection/index.js [app-route] (ecmascript)");
const { BaseConnectionPool, ClusterConnectionPool, CloudConnectionPool, WeightedConnectionPool } = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/pool/index.js [app-route] (ecmascript)");
const Serializer = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/Serializer.js [app-route] (ecmascript)").default;
const errors = __turbopack_context__.r("[project]/node_modules/@elastic/transport/lib/errors.js [app-route] (ecmascript)");
module.exports = {
    Diagnostic,
    Transport,
    BaseConnection,
    HttpConnection,
    UndiciConnection,
    BaseConnectionPool,
    ClusterConnectionPool,
    CloudConnectionPool,
    WeightedConnectionPool,
    Serializer,
    errors,
    events
};
}),
];

//# sourceMappingURL=node_modules_%40elastic_transport_8f24c69c._.js.map