module.exports = [
"[project]/node_modules/dotenv/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"dotenv","version":"17.2.3","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"homepage":"https://github.com/motdotla/dotenv#readme","funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}});}),
"[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const packageJson = __turbopack_context__.r("[project]/node_modules/dotenv/package.json (json)");
const version = packageJson.version;
// Array of tips to display randomly
const TIPS = [
    'üîê encrypt with Dotenvx: https://dotenvx.com',
    'üîê prevent committing .env to code: https://dotenvx.com/precommit',
    'üîê prevent building .env in docker: https://dotenvx.com/prebuild',
    'üì° add observability to secrets: https://dotenvx.com/ops',
    'üë• sync secrets across teammates & machines: https://dotenvx.com/ops',
    'üóÇÔ∏è backup and recover secrets: https://dotenvx.com/ops',
    '‚úÖ audit secrets and track compliance: https://dotenvx.com/ops',
    'üîÑ add secrets lifecycle management: https://dotenvx.com/ops',
    'üîë add access controls to secrets: https://dotenvx.com/ops',
    'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`',
    '‚öôÔ∏è  specify custom .env file path with { path: \'/custom/path/.env\' }',
    '‚öôÔ∏è  enable debug logging with { debug: true }',
    '‚öôÔ∏è  override existing env vars with { override: true }',
    '‚öôÔ∏è  suppress all logs with { quiet: true }',
    '‚öôÔ∏è  write to custom object with { processEnv: myObject }',
    '‚öôÔ∏è  load multiple .env files with { path: [\'.env.local\', \'.env\'] }'
];
// Get a random tip from the tips array
function _getRandomTip() {
    return TIPS[Math.floor(Math.random() * TIPS.length)];
}
function parseBoolean(value) {
    if (typeof value === 'string') {
        return ![
            'false',
            '0',
            'no',
            'off',
            ''
        ].includes(value.toLowerCase());
    }
    return Boolean(value);
}
function supportsAnsi() {
    return process.stdout.isTTY // && process.env.TERM !== 'dumb'
    ;
}
function dim(text) {
    return supportsAnsi() ? `\x1b[2m${text}\x1b[0m` : text;
}
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
// Parse src into an Object
function parse(src) {
    const obj = {};
    // Convert buffer to string
    let lines = src.toString();
    // Convert line breaks to same format
    lines = lines.replace(/\r\n?/mg, '\n');
    let match;
    while((match = LINE.exec(lines)) != null){
        const key = match[1];
        // Default undefined or null to empty string
        let value = match[2] || '';
        // Remove whitespace
        value = value.trim();
        // Check if double quoted
        const maybeQuote = value[0];
        // Remove surrounding quotes
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');
        // Expand newlines if double quoted
        if (maybeQuote === '"') {
            value = value.replace(/\\n/g, '\n');
            value = value.replace(/\\r/g, '\r');
        }
        // Add to object
        obj[key] = value;
    }
    return obj;
}
function _parseVault(options) {
    options = options || {};
    const vaultPath = _vaultPath(options);
    options.path = vaultPath; // parse .env.vault
    const result = DotenvModule.configDotenv(options);
    if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = 'MISSING_DATA';
        throw err;
    }
    // handle scenario for comma separated keys - for use with key rotation
    // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
    const keys = _dotenvKey(options).split(',');
    const length = keys.length;
    let decrypted;
    for(let i = 0; i < length; i++){
        try {
            // Get full key
            const key = keys[i].trim();
            // Get instructions for decrypt
            const attrs = _instructions(result, key);
            // Decrypt
            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
            break;
        } catch (error) {
            // last key
            if (i + 1 >= length) {
                throw error;
            }
        // try next key
        }
    }
    // Parse decrypted .env string
    return DotenvModule.parse(decrypted);
}
function _warn(message) {
    console.error(`[dotenv@${version}][WARN] ${message}`);
}
function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
}
function _log(message) {
    console.log(`[dotenv@${version}] ${message}`);
}
function _dotenvKey(options) {
    // prioritize developer directly setting options.DOTENV_KEY
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
    }
    // secondary infra already contains a DOTENV_KEY environment variable
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
    }
    // fallback to empty string
    return '';
}
function _instructions(result, dotenvKey) {
    // Parse DOTENV_KEY. Format is a URI
    let uri;
    try {
        uri = new URL(dotenvKey);
    } catch (error) {
        if (error.code === 'ERR_INVALID_URL') {
            const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
            err.code = 'INVALID_DOTENV_KEY';
            throw err;
        }
        throw error;
    }
    // Get decrypt key
    const key = uri.password;
    if (!key) {
        const err = new Error('INVALID_DOTENV_KEY: Missing key part');
        err.code = 'INVALID_DOTENV_KEY';
        throw err;
    }
    // Get environment
    const environment = uri.searchParams.get('environment');
    if (!environment) {
        const err = new Error('INVALID_DOTENV_KEY: Missing environment part');
        err.code = 'INVALID_DOTENV_KEY';
        throw err;
    }
    // Get ciphertext payload
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
    ;
    if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
        throw err;
    }
    return {
        ciphertext,
        key
    };
}
function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
            for (const filepath of options.path){
                if (fs.existsSync(filepath)) {
                    possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
                }
            }
        } else {
            possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
        }
    } else {
        possibleVaultPath = path.resolve(process.cwd(), '.env.vault');
    }
    if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
    }
    return null;
}
function _resolveHome(envPath) {
    return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options) {
    const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options && options.debug);
    const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (debug || !quiet) {
        _log('Loading env from encrypted .env.vault');
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
        processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return {
        parsed
    };
}
function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), '.env');
    let encoding = 'utf8';
    let processEnv = process.env;
    if (options && options.processEnv != null) {
        processEnv = options.processEnv;
    }
    let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options && options.debug);
    let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (options && options.encoding) {
        encoding = options.encoding;
    } else {
        if (debug) {
            _debug('No encoding is specified. UTF-8 is used by default');
        }
    }
    let optionPaths = [
        dotenvPath
    ] // default, look for .env
    ;
    if (options && options.path) {
        if (!Array.isArray(options.path)) {
            optionPaths = [
                _resolveHome(options.path)
            ];
        } else {
            optionPaths = []; // reset default
            for (const filepath of options.path){
                optionPaths.push(_resolveHome(filepath));
            }
        }
    }
    // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
    // parsed data, we will combine it with process.env (or options.processEnv if provided).
    let lastError;
    const parsedAll = {};
    for (const path of optionPaths){
        try {
            // Specifying an encoding returns a string instead of a buffer
            const parsed = DotenvModule.parse(fs.readFileSync(path, {
                encoding
            }));
            DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
            if (debug) {
                _debug(`Failed to load ${path} ${e.message}`);
            }
            lastError = e;
        }
    }
    const populated = DotenvModule.populate(processEnv, parsedAll, options);
    // handle user settings DOTENV_CONFIG_ options inside .env file(s)
    debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);
    quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
    if (debug || !quiet) {
        const keysCount = Object.keys(populated).length;
        const shortPaths = [];
        for (const filePath of optionPaths){
            try {
                const relative = path.relative(process.cwd(), filePath);
                shortPaths.push(relative);
            } catch (e) {
                if (debug) {
                    _debug(`Failed to load ${filePath} ${e.message}`);
                }
                lastError = e;
            }
        }
        _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`);
    }
    if (lastError) {
        return {
            parsed: parsedAll,
            error: lastError
        };
    } else {
        return {
            parsed: parsedAll
        };
    }
}
// Populates process.env from .env file
function config(options) {
    // fallback to original dotenv if DOTENV_KEY is not set
    if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    // dotenvKey exists but .env.vault file does not exist
    if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
}
function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), 'hex');
    let ciphertext = Buffer.from(encrypted, 'base64');
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
        const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === 'Invalid key length';
        const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';
        if (isRange || invalidKeyLength) {
            const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
            err.code = 'INVALID_DOTENV_KEY';
            throw err;
        } else if (decryptionFailed) {
            const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
            err.code = 'DECRYPTION_FAILED';
            throw err;
        } else {
            throw error;
        }
    }
}
// Populate process.env with parsed values
function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    const populated = {};
    if (typeof parsed !== 'object') {
        const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
        err.code = 'OBJECT_REQUIRED';
        throw err;
    }
    // Set process.env
    for (const key of Object.keys(parsed)){
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
            if (override === true) {
                processEnv[key] = parsed[key];
                populated[key] = parsed[key];
            }
            if (debug) {
                if (override === true) {
                    _debug(`"${key}" is already defined and WAS overwritten`);
                } else {
                    _debug(`"${key}" is already defined and was NOT overwritten`);
                }
            }
        } else {
            processEnv[key] = parsed[key];
            populated[key] = parsed[key];
        }
    }
    return populated;
}
const DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
};
module.exports.configDotenv = DotenvModule.configDotenv;
module.exports._configVault = DotenvModule._configVault;
module.exports._parseVault = DotenvModule._parseVault;
module.exports.config = DotenvModule.config;
module.exports.decrypt = DotenvModule.decrypt;
module.exports.parse = DotenvModule.parse;
module.exports.populate = DotenvModule.populate;
module.exports = DotenvModule;
}),
"[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.getValueAsString = function getValueString(value) {
    if (Number.isNaN(value)) {
        return 'Nan';
    } else if (!Number.isFinite(value)) {
        if (value < 0) {
            return '-Inf';
        } else {
            return '+Inf';
        }
    } else {
        return `${value}`;
    }
};
exports.removeLabels = function removeLabels(hashMap, labels, sortedLabelNames) {
    const hash = hashObject(labels, sortedLabelNames);
    delete hashMap[hash];
};
exports.setValue = function setValue(hashMap, value, labels) {
    const hash = hashObject(labels);
    hashMap[hash] = {
        value: typeof value === 'number' ? value : 0,
        labels: labels || {}
    };
    return hashMap;
};
exports.setValueDelta = function setValueDelta(hashMap, deltaValue, labels, hash = '') {
    const value = typeof deltaValue === 'number' ? deltaValue : 0;
    if (hashMap[hash]) {
        hashMap[hash].value += value;
    } else {
        hashMap[hash] = {
            value,
            labels
        };
    }
    return hashMap;
};
exports.getLabels = function(labelNames, args) {
    if (typeof args[0] === 'object') {
        return args[0];
    }
    if (labelNames.length !== args.length) {
        throw new Error(`Invalid number of arguments (${args.length}): "${args.join(', ')}" for label names (${labelNames.length}): "${labelNames.join(', ')}".`);
    }
    const acc = {};
    for(let i = 0; i < labelNames.length; i++){
        acc[labelNames[i]] = args[i];
    }
    return acc;
};
function fastHashObject(keys, labels) {
    if (keys.length === 0) {
        return '';
    }
    let hash = '';
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const value = labels[key];
        if (value === undefined) continue;
        hash += `${key}:${value},`;
    }
    return hash;
}
function hashObject(labels, labelNames) {
    // We don't actually need a hash here. We just need a string that
    // is unique for each possible labels object and consistent across
    // calls with equivalent labels objects.
    if (labelNames) {
        return fastHashObject(labelNames, labels);
    }
    const keys = Object.keys(labels);
    if (keys.length > 1) {
        keys.sort(); // need consistency across calls
    }
    return fastHashObject(keys, labels);
}
exports.hashObject = hashObject;
exports.isObject = function isObject(obj) {
    return obj !== null && typeof obj === 'object';
};
exports.nowTimestamp = function nowTimestamp() {
    return Date.now() / 1000;
};
class Grouper extends Map {
    /**
	 * Adds the `value` to the `key`'s array of values.
	 * @param {*} key Key to set.
	 * @param {*} value Value to add to `key`'s array.
	 * @returns {undefined} undefined.
	 */ add(key, value) {
        if (this.has(key)) {
            this.get(key).push(value);
        } else {
            this.set(key, [
                value
            ]);
        }
    }
}
exports.Grouper = Grouper;
}),
"[project]/node_modules/prom-client/lib/registry.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { getValueAsString } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
class Registry {
    static get PROMETHEUS_CONTENT_TYPE() {
        return 'text/plain; version=0.0.4; charset=utf-8';
    }
    static get OPENMETRICS_CONTENT_TYPE() {
        return 'application/openmetrics-text; version=1.0.0; charset=utf-8';
    }
    constructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE){
        this._metrics = {};
        this._collectors = [];
        this._defaultLabels = {};
        if (regContentType !== Registry.PROMETHEUS_CONTENT_TYPE && regContentType !== Registry.OPENMETRICS_CONTENT_TYPE) {
            throw new TypeError(`Content type ${regContentType} is unsupported`);
        }
        this._contentType = regContentType;
    }
    getMetricsAsArray() {
        return Object.values(this._metrics);
    }
    async getMetricsAsString(metrics) {
        const metric = typeof metrics.getForPromString === 'function' ? await metrics.getForPromString() : await metrics.get();
        const name = escapeString(metric.name);
        const help = `# HELP ${name} ${escapeString(metric.help)}`;
        const type = `# TYPE ${name} ${metric.type}`;
        const values = [
            help,
            type
        ];
        const defaultLabels = Object.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;
        const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;
        for (const val of metric.values || []){
            let { metricName = name, labels = {} } = val;
            const { sharedLabels = {} } = val;
            if (isOpenMetrics && metric.type === 'counter') {
                metricName = `${metricName}_total`;
            }
            if (defaultLabels) {
                labels = {
                    ...labels,
                    ...defaultLabels,
                    ...labels
                };
            }
            // We have to flatten these separately to avoid duplicate labels appearing
            // between the base labels and the shared labels
            const formattedLabels = formatLabels(labels, sharedLabels);
            const flattenedShared = flattenSharedLabels(sharedLabels);
            const labelParts = [
                ...formattedLabels,
                flattenedShared
            ].filter(Boolean);
            const labelsString = labelParts.length ? `{${labelParts.join(',')}}` : '';
            let fullMetricLine = `${metricName}${labelsString} ${getValueAsString(val.value)}`;
            const { exemplar } = val;
            if (exemplar && isOpenMetrics) {
                const formattedExemplars = formatLabels(exemplar.labelSet);
                fullMetricLine += ` # {${formattedExemplars.join(',')}} ${getValueAsString(exemplar.value)} ${exemplar.timestamp}`;
            }
            values.push(fullMetricLine);
        }
        return values.join('\n');
    }
    async metrics() {
        const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;
        const promises = this.getMetricsAsArray().map((metric)=>{
            if (isOpenMetrics && metric.type === 'counter') {
                metric.name = standardizeCounterName(metric.name);
            }
            return this.getMetricsAsString(metric);
        });
        const resolves = await Promise.all(promises);
        return isOpenMetrics ? `${resolves.join('\n')}\n# EOF\n` : `${resolves.join('\n\n')}\n`;
    }
    registerMetric(metric) {
        if (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {
            throw new Error(`A metric with the name ${metric.name} has already been registered.`);
        }
        this._metrics[metric.name] = metric;
    }
    clear() {
        this._metrics = {};
        this._defaultLabels = {};
    }
    async getMetricsAsJSON() {
        const metrics = [];
        const defaultLabelNames = Object.keys(this._defaultLabels);
        const promises = [];
        for (const metric of this.getMetricsAsArray()){
            promises.push(metric.get());
        }
        const resolves = await Promise.all(promises);
        for (const item of resolves){
            if (item.values && defaultLabelNames.length > 0) {
                for (const val of item.values){
                    // Make a copy before mutating
                    val.labels = Object.assign({}, val.labels);
                    for (const labelName of defaultLabelNames){
                        val.labels[labelName] = val.labels[labelName] || this._defaultLabels[labelName];
                    }
                }
            }
            metrics.push(item);
        }
        return metrics;
    }
    removeSingleMetric(name) {
        delete this._metrics[name];
    }
    getSingleMetricAsString(name) {
        return this.getMetricsAsString(this._metrics[name]);
    }
    getSingleMetric(name) {
        return this._metrics[name];
    }
    setDefaultLabels(labels) {
        this._defaultLabels = labels;
    }
    resetMetrics() {
        for(const metric in this._metrics){
            this._metrics[metric].reset();
        }
    }
    get contentType() {
        return this._contentType;
    }
    setContentType(metricsContentType) {
        if (metricsContentType === Registry.OPENMETRICS_CONTENT_TYPE || metricsContentType === Registry.PROMETHEUS_CONTENT_TYPE) {
            this._contentType = metricsContentType;
        } else {
            throw new Error(`Content type ${metricsContentType} is unsupported`);
        }
    }
    static merge(registers) {
        const regType = registers[0].contentType;
        for (const reg of registers){
            if (reg.contentType !== regType) {
                throw new Error('Registers can only be merged if they have the same content type');
            }
        }
        const mergedRegistry = new Registry(regType);
        const metricsToMerge = registers.reduce((acc, reg)=>acc.concat(reg.getMetricsAsArray()), []);
        metricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);
        return mergedRegistry;
    }
}
function formatLabels(labels, exclude) {
    const { hasOwnProperty } = Object.prototype;
    const formatted = [];
    for (const [name, value] of Object.entries(labels)){
        if (!exclude || !hasOwnProperty.call(exclude, name)) {
            formatted.push(`${name}="${escapeLabelValue(value)}"`);
        }
    }
    return formatted;
}
const sharedLabelCache = new WeakMap();
function flattenSharedLabels(labels) {
    const cached = sharedLabelCache.get(labels);
    if (cached) {
        return cached;
    }
    const formattedLabels = formatLabels(labels);
    const flattened = formattedLabels.join(',');
    sharedLabelCache.set(labels, flattened);
    return flattened;
}
function escapeLabelValue(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return escapeString(str).replace(/"/g, '\\"');
}
function escapeString(str) {
    return str.replace(/\\/g, '\\\\').replace(/\n/g, '\\n');
}
function standardizeCounterName(name) {
    return name.replace(/_total$/, '');
}
module.exports = Registry;
module.exports.globalRegistry = new Registry();
}),
"[project]/node_modules/prom-client/lib/validation.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
// These are from https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels
const metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;
const labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
exports.validateMetricName = function(name) {
    return metricRegexp.test(name);
};
exports.validateLabelName = function(names = []) {
    return names.every((name)=>labelRegexp.test(name));
};
exports.validateLabel = function validateLabel(savedLabels, labels) {
    for(const label in labels){
        if (!savedLabels.includes(label)) {
            throw new Error(`Added label "${label}" is not included in initial labelset: ${util.inspect(savedLabels)}`);
        }
    }
};
}),
"[project]/node_modules/prom-client/lib/metric.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Registry = __turbopack_context__.r("[project]/node_modules/prom-client/lib/registry.js [app-route] (ecmascript)");
const { isObject } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
const { validateMetricName, validateLabelName } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/validation.js [app-route] (ecmascript)");
/**
 * @abstract
 */ class Metric {
    constructor(config, defaults = {}){
        if (!isObject(config)) {
            throw new TypeError('constructor expected a config object');
        }
        Object.assign(this, {
            labelNames: [],
            registers: [
                Registry.globalRegistry
            ],
            aggregator: 'sum',
            enableExemplars: false
        }, defaults, config);
        if (!this.registers) {
            // in case config.registers is `undefined`
            this.registers = [
                Registry.globalRegistry
            ];
        }
        if (!this.help) {
            throw new Error('Missing mandatory help parameter');
        }
        if (!this.name) {
            throw new Error('Missing mandatory name parameter');
        }
        if (!validateMetricName(this.name)) {
            throw new Error('Invalid metric name');
        }
        if (!validateLabelName(this.labelNames)) {
            throw new Error('Invalid label name');
        }
        if (this.collect && typeof this.collect !== 'function') {
            throw new Error('Optional "collect" parameter must be a function');
        }
        if (this.labelNames) {
            this.sortedLabelNames = [
                ...this.labelNames
            ].sort();
        } else {
            this.sortedLabelNames = [];
        }
        this.reset();
        for (const register of this.registers){
            if (this.enableExemplars && register.contentType === Registry.PROMETHEUS_CONTENT_TYPE) {
                throw new TypeError('Exemplars are supported only on OpenMetrics registries');
            }
            register.registerMetric(this);
        }
    }
    reset() {
    /* abstract */ }
}
module.exports = {
    Metric
};
}),
"[project]/node_modules/prom-client/lib/exemplar.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Class representing an OpenMetrics exemplar.
 *
 * @property {object} labelSet
 * @property {number} value
 * @property {number} [timestamp]
 * */ class Exemplar {
    constructor(labelSet = {}, value = null){
        this.labelSet = labelSet;
        this.value = value;
    }
    /**
	 * Validation for the label set format.
	 * https://github.com/OpenObservability/OpenMetrics/blob/d99b705f611b75fec8f450b05e344e02eea6921d/specification/OpenMetrics.md#exemplars
	 *
	 * @param {object} labelSet - Exemplar labels.
	 * @throws {RangeError}
	 * @return {void}
	 */ validateExemplarLabelSet(labelSet) {
        let res = '';
        for (const [labelName, labelValue] of Object.entries(labelSet)){
            res += `${labelName}${labelValue}`;
        }
        if (res.length > 128) {
            throw new RangeError('Label set size must be smaller than 128 UTF-8 chars');
        }
    }
}
module.exports = Exemplar;
}),
"[project]/node_modules/prom-client/lib/counter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Counter metric
 */ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const { hashObject, isObject, getLabels, removeLabels, nowTimestamp } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
const { validateLabel } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/validation.js [app-route] (ecmascript)");
const { Metric } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metric.js [app-route] (ecmascript)");
const Exemplar = __turbopack_context__.r("[project]/node_modules/prom-client/lib/exemplar.js [app-route] (ecmascript)");
class Counter extends Metric {
    constructor(config){
        super(config);
        this.type = 'counter';
        this.defaultLabels = {};
        this.defaultValue = 1;
        this.defaultExemplarLabelSet = {};
        if (config.enableExemplars) {
            this.enableExemplars = true;
            this.inc = this.incWithExemplar;
        } else {
            this.inc = this.incWithoutExemplar;
        }
    }
    /**
	 * Increment counter
	 * @param {object} labels - What label you want to be incremented
	 * @param {Number} value - Value to increment, if omitted increment with 1
	 * @returns {object} results - object with information about the inc operation
	 * @returns {string} results.labelHash - hash representation of the labels
	 */ incWithoutExemplar(labels, value) {
        let hash = '';
        if (isObject(labels)) {
            hash = hashObject(labels, this.sortedLabelNames);
            validateLabel(this.labelNames, labels);
        } else {
            value = labels;
            labels = {};
        }
        if (value && !Number.isFinite(value)) {
            throw new TypeError(`Value is not a valid number: ${util.format(value)}`);
        }
        if (value < 0) {
            throw new Error('It is not possible to decrease a counter');
        }
        if (value === null || value === undefined) value = 1;
        setValue(this.hashMap, value, labels, hash);
        return {
            labelHash: hash
        };
    }
    /**
	 * Increment counter with exemplar, same as inc but accepts labels for an
	 * exemplar.
	 * If no label is provided the current exemplar labels are kept unchanged
	 * (defaults to empty set).
	 *
	 * @param {object} incOpts - Object with options about what metric to increase
	 * @param {object} incOpts.labels - What label you want to be incremented,
	 *                                  defaults to null (metric with no labels)
	 * @param {Number} incOpts.value - Value to increment, defaults to 1
	 * @param {object} incOpts.exemplarLabels - Key-value  labels for the
	 *                                          exemplar, defaults to empty set {}
	 * @returns {void}
	 */ incWithExemplar({ labels = this.defaultLabels, value = this.defaultValue, exemplarLabels = this.defaultExemplarLabelSet } = {}) {
        const res = this.incWithoutExemplar(labels, value);
        this.updateExemplar(exemplarLabels, value, res.labelHash);
    }
    updateExemplar(exemplarLabels, value, hash) {
        if (exemplarLabels === this.defaultExemplarLabelSet) return;
        if (!isObject(this.hashMap[hash].exemplar)) {
            this.hashMap[hash].exemplar = new Exemplar();
        }
        this.hashMap[hash].exemplar.validateExemplarLabelSet(exemplarLabels);
        this.hashMap[hash].exemplar.labelSet = exemplarLabels;
        this.hashMap[hash].exemplar.value = value ? value : 1;
        this.hashMap[hash].exemplar.timestamp = nowTimestamp();
    }
    /**
	 * Reset counter
	 * @returns {void}
	 */ reset() {
        this.hashMap = {};
        if (this.labelNames.length === 0) {
            setValue(this.hashMap, 0);
        }
    }
    async get() {
        if (this.collect) {
            const v = this.collect();
            if (v instanceof Promise) await v;
        }
        return {
            help: this.help,
            name: this.name,
            type: this.type,
            values: Object.values(this.hashMap),
            aggregator: this.aggregator
        };
    }
    labels(...args) {
        const labels = getLabels(this.labelNames, args) || {};
        return {
            inc: this.inc.bind(this, labels)
        };
    }
    remove(...args) {
        const labels = getLabels(this.labelNames, args) || {};
        validateLabel(this.labelNames, labels);
        return removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);
    }
}
function setValue(hashMap, value, labels = {}, hash = '') {
    if (hashMap[hash]) {
        hashMap[hash].value += value;
    } else {
        hashMap[hash] = {
            value,
            labels
        };
    }
    return hashMap;
}
module.exports = Counter;
}),
"[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Gauge metric
 */ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const { setValue, setValueDelta, getLabels, hashObject, isObject, removeLabels } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
const { validateLabel } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/validation.js [app-route] (ecmascript)");
const { Metric } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metric.js [app-route] (ecmascript)");
class Gauge extends Metric {
    constructor(config){
        super(config);
        this.type = 'gauge';
    }
    /**
	 * Set a gauge to a value
	 * @param {object} labels - Object with labels and their values
	 * @param {Number} value - Value to set the gauge to, must be positive
	 * @returns {void}
	 */ set(labels, value) {
        value = getValueArg(labels, value);
        labels = getLabelArg(labels);
        set(this, labels, value);
    }
    /**
	 * Reset gauge
	 * @returns {void}
	 */ reset() {
        this.hashMap = {};
        if (this.labelNames.length === 0) {
            setValue(this.hashMap, 0, {});
        }
    }
    /**
	 * Increment a gauge value
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @param {Number} value - Value to increment - if omitted, increment with 1
	 * @returns {void}
	 */ inc(labels, value) {
        value = getValueArg(labels, value);
        labels = getLabelArg(labels);
        if (value === undefined) value = 1;
        setDelta(this, labels, value);
    }
    /**
	 * Decrement a gauge value
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @param {Number} value - Value to decrement - if omitted, decrement with 1
	 * @returns {void}
	 */ dec(labels, value) {
        value = getValueArg(labels, value);
        labels = getLabelArg(labels);
        if (value === undefined) value = 1;
        setDelta(this, labels, -value);
    }
    /**
	 * Set the gauge to current unix epoch
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @returns {void}
	 */ setToCurrentTime(labels) {
        const now = Date.now() / 1000;
        if (labels === undefined) {
            this.set(now);
        } else {
            this.set(labels, now);
        }
    }
    /**
	 * Start a timer
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @returns {function} - Invoke this function to set the duration in seconds since you started the timer.
	 * @example
	 * var done = gauge.startTimer();
	 * makeXHRRequest(function(err, response) {
	 *	done(); //Duration of the request will be saved
	 * });
	 */ startTimer(labels) {
        const start = process.hrtime();
        return (endLabels)=>{
            const delta = process.hrtime(start);
            const value = delta[0] + delta[1] / 1e9;
            this.set(Object.assign({}, labels, endLabels), value);
            return value;
        };
    }
    async get() {
        if (this.collect) {
            const v = this.collect();
            if (v instanceof Promise) await v;
        }
        return {
            help: this.help,
            name: this.name,
            type: this.type,
            values: Object.values(this.hashMap),
            aggregator: this.aggregator
        };
    }
    _getValue(labels) {
        const hash = hashObject(labels || {}, this.sortedLabelNames);
        return this.hashMap[hash] ? this.hashMap[hash].value : 0;
    }
    labels(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        return {
            inc: this.inc.bind(this, labels),
            dec: this.dec.bind(this, labels),
            set: this.set.bind(this, labels),
            setToCurrentTime: this.setToCurrentTime.bind(this, labels),
            startTimer: this.startTimer.bind(this, labels)
        };
    }
    remove(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);
    }
}
function set(gauge, labels, value) {
    if (typeof value !== 'number') {
        throw new TypeError(`Value is not a valid number: ${util.format(value)}`);
    }
    validateLabel(gauge.labelNames, labels);
    setValue(gauge.hashMap, value, labels);
}
function setDelta(gauge, labels, delta) {
    if (typeof delta !== 'number') {
        throw new TypeError(`Delta is not a valid number: ${util.format(delta)}`);
    }
    validateLabel(gauge.labelNames, labels);
    const hash = hashObject(labels, gauge.sortedLabelNames);
    setValueDelta(gauge.hashMap, delta, labels, hash);
}
function getLabelArg(labels) {
    return isObject(labels) ? labels : {};
}
function getValueArg(labels, value) {
    return isObject(labels) ? value : labels;
}
module.exports = Gauge;
}),
"[project]/node_modules/prom-client/lib/histogram.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Histogram
 */ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const { getLabels, hashObject, isObject, removeLabels, nowTimestamp } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
const { validateLabel } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/validation.js [app-route] (ecmascript)");
const { Metric } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metric.js [app-route] (ecmascript)");
const Exemplar = __turbopack_context__.r("[project]/node_modules/prom-client/lib/exemplar.js [app-route] (ecmascript)");
class Histogram extends Metric {
    constructor(config){
        super(config, {
            buckets: [
                0.005,
                0.01,
                0.025,
                0.05,
                0.1,
                0.25,
                0.5,
                1,
                2.5,
                5,
                10
            ]
        });
        this.type = 'histogram';
        this.defaultLabels = {};
        this.defaultExemplarLabelSet = {};
        this.enableExemplars = false;
        for (const label of this.labelNames){
            if (label === 'le') {
                throw new Error('le is a reserved label keyword');
            }
        }
        this.upperBounds = this.buckets;
        this.bucketValues = this.upperBounds.reduce((acc, upperBound)=>{
            acc[upperBound] = 0;
            return acc;
        }, {});
        if (config.enableExemplars) {
            this.enableExemplars = true;
            this.bucketExemplars = this.upperBounds.reduce((acc, upperBound)=>{
                acc[upperBound] = null;
                return acc;
            }, {});
            Object.freeze(this.bucketExemplars);
            this.observe = this.observeWithExemplar;
        } else {
            this.observe = this.observeWithoutExemplar;
        }
        Object.freeze(this.bucketValues);
        Object.freeze(this.upperBounds);
        if (this.labelNames.length === 0) {
            this.hashMap = {
                [hashObject({})]: createBaseValues({}, this.bucketValues, this.bucketExemplars)
            };
        }
    }
    /**
	 * Observe a value in histogram
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @param {Number} value - Value to observe in the histogram
	 * @returns {void}
	 */ observeWithoutExemplar(labels, value) {
        observe.call(this, labels === 0 ? 0 : labels || {})(value);
    }
    observeWithExemplar({ labels = this.defaultLabels, value, exemplarLabels = this.defaultExemplarLabelSet } = {}) {
        observe.call(this, labels === 0 ? 0 : labels || {})(value);
        this.updateExemplar(labels, value, exemplarLabels);
    }
    updateExemplar(labels, value, exemplarLabels) {
        if (Object.keys(exemplarLabels).length === 0) return;
        const hash = hashObject(labels, this.sortedLabelNames);
        const bound = findBound(this.upperBounds, value);
        const { bucketExemplars } = this.hashMap[hash];
        let exemplar = bucketExemplars[bound];
        if (!isObject(exemplar)) {
            exemplar = new Exemplar();
            bucketExemplars[bound] = exemplar;
        }
        exemplar.validateExemplarLabelSet(exemplarLabels);
        exemplar.labelSet = exemplarLabels;
        exemplar.value = value;
        exemplar.timestamp = nowTimestamp();
    }
    async get() {
        const data = await this.getForPromString();
        data.values = data.values.map(splayLabels);
        return data;
    }
    async getForPromString() {
        if (this.collect) {
            const v = this.collect();
            if (v instanceof Promise) await v;
        }
        const data = Object.values(this.hashMap);
        const values = data.map(extractBucketValuesForExport(this)).reduce(addSumAndCountForExport(this), []);
        return {
            name: this.name,
            help: this.help,
            type: this.type,
            values,
            aggregator: this.aggregator
        };
    }
    reset() {
        this.hashMap = {};
    }
    /**
	 * Initialize the metrics for the given combination of labels to zero
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @returns {void}
	 */ zero(labels) {
        const hash = hashObject(labels, this.sortedLabelNames);
        this.hashMap[hash] = createBaseValues(labels, this.bucketValues, this.bucketExemplars);
    }
    /**
	 * Start a timer that could be used to logging durations
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @param {object} exemplarLabels - Object with labels for exemplar where key is the label key and value is label value. Can only be one level deep
	 * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds
	 * @example
	 * var end = histogram.startTimer();
	 * makeExpensiveXHRRequest(function(err, res) {
	 * 	const duration = end(); //Observe the duration of expensiveXHRRequest and returns duration in seconds
	 * 	console.log('Duration', duration);
	 * });
	 */ startTimer(labels, exemplarLabels) {
        return this.enableExemplars ? startTimerWithExemplar.call(this, labels, exemplarLabels)() : startTimer.call(this, labels)();
    }
    labels(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        return {
            observe: observe.call(this, labels),
            startTimer: startTimer.call(this, labels)
        };
    }
    remove(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);
    }
}
function startTimer(startLabels) {
    return ()=>{
        const start = process.hrtime();
        return (endLabels)=>{
            const delta = process.hrtime(start);
            const value = delta[0] + delta[1] / 1e9;
            this.observe(Object.assign({}, startLabels, endLabels), value);
            return value;
        };
    };
}
function startTimerWithExemplar(startLabels, startExemplarLabels) {
    return ()=>{
        const start = process.hrtime();
        return (endLabels, endExemplarLabels)=>{
            const delta = process.hrtime(start);
            const value = delta[0] + delta[1] / 1e9;
            this.observe({
                labels: Object.assign({}, startLabels, endLabels),
                value,
                exemplarLabels: Object.assign({}, startExemplarLabels, endExemplarLabels)
            });
            return value;
        };
    };
}
function setValuePair(labels, value, metricName, exemplar, sharedLabels = {}) {
    return {
        labels,
        sharedLabels,
        value,
        metricName,
        exemplar
    };
}
function findBound(upperBounds, value) {
    for(let i = 0; i < upperBounds.length; i++){
        const bound = upperBounds[i];
        if (value <= bound) {
            return bound;
        }
    }
    return -1;
}
function observe(labels) {
    return (value)=>{
        const labelValuePair = convertLabelsAndValues(labels, value);
        validateLabel(this.labelNames, labelValuePair.labels);
        if (!Number.isFinite(labelValuePair.value)) {
            throw new TypeError(`Value is not a valid number: ${util.format(labelValuePair.value)}`);
        }
        const hash = hashObject(labelValuePair.labels, this.sortedLabelNames);
        let valueFromMap = this.hashMap[hash];
        if (!valueFromMap) {
            valueFromMap = createBaseValues(labelValuePair.labels, this.bucketValues, this.bucketExemplars);
        }
        const b = findBound(this.upperBounds, labelValuePair.value);
        valueFromMap.sum += labelValuePair.value;
        valueFromMap.count += 1;
        if (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b)) {
            valueFromMap.bucketValues[b] += 1;
        }
        this.hashMap[hash] = valueFromMap;
    };
}
function createBaseValues(labels, bucketValues, bucketExemplars) {
    const result = {
        labels,
        bucketValues: {
            ...bucketValues
        },
        sum: 0,
        count: 0
    };
    if (bucketExemplars) {
        result.bucketExemplars = {
            ...bucketExemplars
        };
    }
    return result;
}
function convertLabelsAndValues(labels, value) {
    return isObject(labels) ? {
        labels,
        value
    } : {
        value: labels,
        labels: {}
    };
}
function extractBucketValuesForExport(histogram) {
    const name = `${histogram.name}_bucket`;
    return (bucketData)=>{
        let acc = 0;
        const buckets = histogram.upperBounds.map((upperBound)=>{
            acc += bucketData.bucketValues[upperBound];
            return setValuePair({
                le: upperBound
            }, acc, name, bucketData.bucketExemplars ? bucketData.bucketExemplars[upperBound] : null, bucketData.labels);
        });
        return {
            buckets,
            data: bucketData
        };
    };
}
function addSumAndCountForExport(histogram) {
    return (acc, d)=>{
        acc.push(...d.buckets);
        const infLabel = {
            le: '+Inf'
        };
        acc.push(setValuePair(infLabel, d.data.count, `${histogram.name}_bucket`, d.data.bucketExemplars ? d.data.bucketExemplars['-1'] : null, d.data.labels), setValuePair({}, d.data.sum, `${histogram.name}_sum`, undefined, d.data.labels), setValuePair({}, d.data.count, `${histogram.name}_count`, undefined, d.data.labels));
        return acc;
    };
}
function splayLabels(bucket) {
    const { sharedLabels, labels, ...newBucket } = bucket;
    for (const label of Object.keys(sharedLabels)){
        labels[label] = sharedLabels[label];
    }
    newBucket.labels = labels;
    return newBucket;
}
module.exports = Histogram;
}),
"[project]/node_modules/prom-client/lib/timeWindowQuantiles.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { TDigest } = __turbopack_context__.r("[project]/node_modules/tdigest/tdigest.js [app-route] (ecmascript)");
class TimeWindowQuantiles {
    constructor(maxAgeSeconds, ageBuckets){
        this.maxAgeSeconds = maxAgeSeconds || 0;
        this.ageBuckets = ageBuckets || 0;
        this.shouldRotate = maxAgeSeconds && ageBuckets;
        this.ringBuffer = Array(ageBuckets).fill(new TDigest());
        this.currentBuffer = 0;
        this.lastRotateTimestampMillis = Date.now();
        this.durationBetweenRotatesMillis = maxAgeSeconds * 1000 / ageBuckets || Infinity;
    }
    size() {
        const bucket = rotate.call(this);
        return bucket.size();
    }
    percentile(quantile) {
        const bucket = rotate.call(this);
        return bucket.percentile(quantile);
    }
    push(value) {
        rotate.call(this);
        this.ringBuffer.forEach((bucket)=>{
            bucket.push(value);
        });
    }
    reset() {
        this.ringBuffer.forEach((bucket)=>{
            bucket.reset();
        });
    }
    compress() {
        this.ringBuffer.forEach((bucket)=>{
            bucket.compress();
        });
    }
}
function rotate() {
    let timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;
    while(timeSinceLastRotateMillis > this.durationBetweenRotatesMillis && this.shouldRotate){
        this.ringBuffer[this.currentBuffer] = new TDigest();
        if (++this.currentBuffer >= this.ringBuffer.length) {
            this.currentBuffer = 0;
        }
        timeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;
        this.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;
    }
    return this.ringBuffer[this.currentBuffer];
}
module.exports = TimeWindowQuantiles;
}),
"[project]/node_modules/prom-client/lib/summary.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Summary
 */ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const { getLabels, hashObject, removeLabels } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
const { validateLabel } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/validation.js [app-route] (ecmascript)");
const { Metric } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metric.js [app-route] (ecmascript)");
const timeWindowQuantiles = __turbopack_context__.r("[project]/node_modules/prom-client/lib/timeWindowQuantiles.js [app-route] (ecmascript)");
const DEFAULT_COMPRESS_COUNT = 1000; // every 1000 measurements
class Summary extends Metric {
    constructor(config){
        super(config, {
            percentiles: [
                0.01,
                0.05,
                0.5,
                0.9,
                0.95,
                0.99,
                0.999
            ],
            compressCount: DEFAULT_COMPRESS_COUNT,
            hashMap: {}
        });
        this.type = 'summary';
        for (const label of this.labelNames){
            if (label === 'quantile') throw new Error('quantile is a reserved label keyword');
        }
        if (this.labelNames.length === 0) {
            this.hashMap = {
                [hashObject({})]: {
                    labels: {},
                    td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
                    count: 0,
                    sum: 0
                }
            };
        }
    }
    /**
	 * Observe a value
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @param {Number} value - Value to observe
	 * @returns {void}
	 */ observe(labels, value) {
        observe.call(this, labels === 0 ? 0 : labels || {})(value);
    }
    async get() {
        if (this.collect) {
            const v = this.collect();
            if (v instanceof Promise) await v;
        }
        const hashKeys = Object.keys(this.hashMap);
        const values = [];
        hashKeys.forEach((hashKey)=>{
            const s = this.hashMap[hashKey];
            if (s) {
                if (this.pruneAgedBuckets && s.td.size() === 0) {
                    delete this.hashMap[hashKey];
                } else {
                    extractSummariesForExport(s, this.percentiles).forEach((v)=>{
                        values.push(v);
                    });
                    values.push(getSumForExport(s, this));
                    values.push(getCountForExport(s, this));
                }
            }
        });
        return {
            name: this.name,
            help: this.help,
            type: this.type,
            values,
            aggregator: this.aggregator
        };
    }
    reset() {
        const data = Object.values(this.hashMap);
        data.forEach((s)=>{
            s.td.reset();
            s.count = 0;
            s.sum = 0;
        });
    }
    /**
	 * Start a timer that could be used to logging durations
	 * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
	 * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds
	 * @example
	 * var end = summary.startTimer();
	 * makeExpensiveXHRRequest(function(err, res) {
	 *	end(); //Observe the duration of expensiveXHRRequest
	 * });
	 */ startTimer(labels) {
        return startTimer.call(this, labels)();
    }
    labels(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        return {
            observe: observe.call(this, labels),
            startTimer: startTimer.call(this, labels)
        };
    }
    remove(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);
    }
}
function extractSummariesForExport(summaryOfLabels, percentiles) {
    summaryOfLabels.td.compress();
    return percentiles.map((percentile)=>{
        const percentileValue = summaryOfLabels.td.percentile(percentile);
        return {
            labels: Object.assign({
                quantile: percentile
            }, summaryOfLabels.labels),
            value: percentileValue ? percentileValue : 0
        };
    });
}
function getCountForExport(value, summary) {
    return {
        metricName: `${summary.name}_count`,
        labels: value.labels,
        value: value.count
    };
}
function getSumForExport(value, summary) {
    return {
        metricName: `${summary.name}_sum`,
        labels: value.labels,
        value: value.sum
    };
}
function startTimer(startLabels) {
    return ()=>{
        const start = process.hrtime();
        return (endLabels)=>{
            const delta = process.hrtime(start);
            const value = delta[0] + delta[1] / 1e9;
            this.observe(Object.assign({}, startLabels, endLabels), value);
            return value;
        };
    };
}
function observe(labels) {
    return (value)=>{
        const labelValuePair = convertLabelsAndValues(labels, value);
        validateLabel(this.labelNames, labels);
        if (!Number.isFinite(labelValuePair.value)) {
            throw new TypeError(`Value is not a valid number: ${util.format(labelValuePair.value)}`);
        }
        const hash = hashObject(labelValuePair.labels, this.sortedLabelNames);
        let summaryOfLabel = this.hashMap[hash];
        if (!summaryOfLabel) {
            summaryOfLabel = {
                labels: labelValuePair.labels,
                td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
                count: 0,
                sum: 0
            };
        }
        summaryOfLabel.td.push(labelValuePair.value);
        summaryOfLabel.count++;
        if (summaryOfLabel.count % this.compressCount === 0) {
            summaryOfLabel.td.compress();
        }
        summaryOfLabel.sum += labelValuePair.value;
        this.hashMap[hash] = summaryOfLabel;
    };
}
function convertLabelsAndValues(labels, value) {
    if (value === undefined) {
        return {
            value: labels,
            labels: {}
        };
    }
    return {
        labels,
        value
    };
}
module.exports = Summary;
}),
"[project]/node_modules/prom-client/lib/pushgateway.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
const https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
const { gzipSync } = __turbopack_context__.r("[externals]/zlib [external] (zlib, cjs)");
const { globalRegistry } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/registry.js [app-route] (ecmascript)");
class Pushgateway {
    constructor(gatewayUrl, options, registry){
        if (!registry) {
            registry = globalRegistry;
        }
        this.registry = registry;
        this.gatewayUrl = gatewayUrl;
        const { requireJobName, ...requestOptions } = {
            requireJobName: true,
            ...options
        };
        this.requireJobName = requireJobName;
        this.requestOptions = requestOptions;
    }
    pushAdd(params = {}) {
        if (this.requireJobName && !params.jobName) {
            throw new Error('Missing jobName parameter');
        }
        return useGateway.call(this, 'POST', params.jobName, params.groupings);
    }
    push(params = {}) {
        if (this.requireJobName && !params.jobName) {
            throw new Error('Missing jobName parameter');
        }
        return useGateway.call(this, 'PUT', params.jobName, params.groupings);
    }
    delete(params = {}) {
        if (this.requireJobName && !params.jobName) {
            throw new Error('Missing jobName parameter');
        }
        return useGateway.call(this, 'DELETE', params.jobName, params.groupings);
    }
}
async function useGateway(method, job, groupings) {
    // `URL` first added in v6.13.0
    // eslint-disable-next-line n/no-deprecated-api
    const gatewayUrlParsed = url.parse(this.gatewayUrl);
    const gatewayUrlPath = gatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== '/' ? gatewayUrlParsed.pathname : '';
    const jobPath = job ? `/job/${encodeURIComponent(job)}${generateGroupings(groupings)}` : '';
    const path = `${gatewayUrlPath}/metrics${jobPath}`;
    // eslint-disable-next-line n/no-deprecated-api
    const target = url.resolve(this.gatewayUrl, path);
    // eslint-disable-next-line n/no-deprecated-api
    const requestParams = url.parse(target);
    const httpModule = isHttps(requestParams.href) ? https : http;
    const options = Object.assign(requestParams, this.requestOptions, {
        method
    });
    return new Promise((resolve, reject)=>{
        if (method === 'DELETE' && options.headers) {
            delete options.headers['Content-Encoding'];
        }
        const req = httpModule.request(options, (resp)=>{
            let body = '';
            resp.setEncoding('utf8');
            resp.on('data', (chunk)=>{
                body += chunk;
            });
            resp.on('end', ()=>{
                if (resp.statusCode >= 400) {
                    reject(new Error(`push failed with status ${resp.statusCode}, ${body}`));
                } else {
                    resolve({
                        resp,
                        body
                    });
                }
            });
        });
        req.on('error', (err)=>{
            reject(err);
        });
        req.on('timeout', ()=>{
            req.destroy(new Error('Pushgateway request timed out'));
        });
        if (method !== 'DELETE') {
            this.registry.metrics().then((metrics)=>{
                if (options.headers && options.headers['Content-Encoding'] === 'gzip') {
                    metrics = gzipSync(metrics);
                }
                req.write(metrics);
                req.end();
            }).catch((err)=>{
                reject(err);
            });
        } else {
            req.end();
        }
    });
}
function generateGroupings(groupings) {
    if (!groupings) {
        return '';
    }
    return Object.keys(groupings).map((key)=>`/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`).join('');
}
function isHttps(href) {
    return href.search(/^https/) !== -1;
}
module.exports = Pushgateway;
}),
"[project]/node_modules/prom-client/lib/bucketGenerators.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.linearBuckets = (start, width, count)=>{
    if (count < 1) {
        throw new Error('Linear buckets needs a positive count');
    }
    const buckets = new Array(count);
    for(let i = 0; i < count; i++){
        buckets[i] = start + i * width;
    }
    return buckets;
};
exports.exponentialBuckets = (start, factor, count)=>{
    if (start <= 0) {
        throw new Error('Exponential buckets needs a positive start');
    }
    if (count < 1) {
        throw new Error('Exponential buckets needs a positive count');
    }
    if (factor <= 1) {
        throw new Error('Exponential buckets needs a factor greater than 1');
    }
    const buckets = new Array(count);
    for(let i = 0; i < count; i++){
        buckets[i] = start;
        start *= factor;
    }
    return buckets;
};
}),
"[project]/node_modules/prom-client/lib/metrics/processCpuTotal.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const OtelApi = __turbopack_context__.r("[project]/node_modules/@opentelemetry/api/build/esm/index.js [app-route] (ecmascript)");
const Counter = __turbopack_context__.r("[project]/node_modules/prom-client/lib/counter.js [app-route] (ecmascript)");
const PROCESS_CPU_USER_SECONDS = 'process_cpu_user_seconds_total';
const PROCESS_CPU_SYSTEM_SECONDS = 'process_cpu_system_seconds_total';
const PROCESS_CPU_SECONDS = 'process_cpu_seconds_total';
module.exports = (registry, config = {})=>{
    const registers = registry ? [
        registry
    ] : undefined;
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const exemplars = config.enableExemplars ? config.enableExemplars : false;
    const labelNames = Object.keys(labels);
    let lastCpuUsage = process.cpuUsage();
    const cpuUserUsageCounter = new Counter({
        name: namePrefix + PROCESS_CPU_USER_SECONDS,
        help: 'Total user CPU time spent in seconds.',
        enableExemplars: exemplars,
        registers,
        labelNames,
        // Use this one metric's `collect` to set all metrics' values.
        collect () {
            const cpuUsage = process.cpuUsage();
            const userUsageMicros = cpuUsage.user - lastCpuUsage.user;
            const systemUsageMicros = cpuUsage.system - lastCpuUsage.system;
            lastCpuUsage = cpuUsage;
            if (this.enableExemplars) {
                let exemplarLabels = {};
                const currentSpan = OtelApi.trace.getSpan(OtelApi.context.active());
                if (currentSpan) {
                    exemplarLabels = {
                        traceId: currentSpan.spanContext().traceId,
                        spanId: currentSpan.spanContext().spanId
                    };
                }
                cpuUserUsageCounter.inc({
                    labels,
                    value: userUsageMicros / 1e6,
                    exemplarLabels
                });
                cpuSystemUsageCounter.inc({
                    labels,
                    value: systemUsageMicros / 1e6,
                    exemplarLabels
                });
                cpuUsageCounter.inc({
                    labels,
                    value: (userUsageMicros + systemUsageMicros) / 1e6,
                    exemplarLabels
                });
            } else {
                cpuUserUsageCounter.inc(labels, userUsageMicros / 1e6);
                cpuSystemUsageCounter.inc(labels, systemUsageMicros / 1e6);
                cpuUsageCounter.inc(labels, (userUsageMicros + systemUsageMicros) / 1e6);
            }
        }
    });
    const cpuSystemUsageCounter = new Counter({
        name: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,
        help: 'Total system CPU time spent in seconds.',
        enableExemplars: exemplars,
        registers,
        labelNames
    });
    const cpuUsageCounter = new Counter({
        name: namePrefix + PROCESS_CPU_SECONDS,
        help: 'Total user and system CPU time spent in seconds.',
        enableExemplars: exemplars,
        registers,
        labelNames
    });
};
module.exports.metricNames = [
    PROCESS_CPU_USER_SECONDS,
    PROCESS_CPU_SYSTEM_SECONDS,
    PROCESS_CPU_SECONDS
];
}),
"[project]/node_modules/prom-client/lib/metrics/processStartTime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const startInSeconds = Math.round(Date.now() / 1000 - process.uptime());
const PROCESS_START_TIME = 'process_start_time_seconds';
module.exports = (registry, config = {})=>{
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
        name: namePrefix + PROCESS_START_TIME,
        help: 'Start time of the process since unix epoch in seconds.',
        registers: registry ? [
            registry
        ] : undefined,
        labelNames,
        aggregator: 'omit',
        collect () {
            this.set(labels, startInSeconds);
        }
    });
};
module.exports.metricNames = [
    PROCESS_START_TIME
];
}),
"[project]/node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const values = [
    'VmSize',
    'VmRSS',
    'VmData'
];
const PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';
const PROCESS_VIRTUAL_MEMORY = 'process_virtual_memory_bytes';
const PROCESS_HEAP = 'process_heap_bytes';
function structureOutput(input) {
    return input.split('\n').reduce((acc, string)=>{
        if (!values.some((value)=>string.startsWith(value))) {
            return acc;
        }
        const split = string.split(':');
        // Get the value
        let value = split[1].trim();
        // Remove trailing ` kb`
        value = value.substr(0, value.length - 3);
        // Make it into a number in bytes bytes
        value = Number(value) * 1024;
        acc[split[0]] = value;
        return acc;
    }, {});
}
module.exports = (registry, config = {})=>{
    const registers = registry ? [
        registry
    ] : undefined;
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const residentMemGauge = new Gauge({
        name: namePrefix + PROCESS_RESIDENT_MEMORY,
        help: 'Resident memory size in bytes.',
        registers,
        labelNames,
        // Use this one metric's `collect` to set all metrics' values.
        collect () {
            try {
                // Sync I/O is often problematic, but /proc isn't really I/O, it
                // a virtual filesystem that maps directly to in-kernel data
                // structures and never blocks.
                //
                // Node.js/libuv do this already for process.memoryUsage(), see:
                // - https://github.com/libuv/libuv/blob/a629688008694ed8022269e66826d4d6ec688b83/src/unix/linux-core.c#L506-L523
                const stat = fs.readFileSync('/proc/self/status', 'utf8');
                const structuredOutput = structureOutput(stat);
                residentMemGauge.set(labels, structuredOutput.VmRSS);
                virtualMemGauge.set(labels, structuredOutput.VmSize);
                heapSizeMemGauge.set(labels, structuredOutput.VmData);
            } catch  {
            // noop
            }
        }
    });
    const virtualMemGauge = new Gauge({
        name: namePrefix + PROCESS_VIRTUAL_MEMORY,
        help: 'Virtual memory size in bytes.',
        registers,
        labelNames
    });
    const heapSizeMemGauge = new Gauge({
        name: namePrefix + PROCESS_HEAP,
        help: 'Process heap size in bytes.',
        registers,
        labelNames
    });
};
module.exports.metricNames = [
    PROCESS_RESIDENT_MEMORY,
    PROCESS_VIRTUAL_MEMORY,
    PROCESS_HEAP
];
}),
"[project]/node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// process.memoryUsage() can throw on some platforms, see #67
function safeMemoryUsage() {
    try {
        return process.memoryUsage();
    } catch  {
        return;
    }
}
module.exports = safeMemoryUsage;
}),
"[project]/node_modules/prom-client/lib/metrics/osMemoryHeap.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const linuxVariant = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js [app-route] (ecmascript)");
const safeMemoryUsage = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js [app-route] (ecmascript)");
const PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';
function notLinuxVariant(registry, config = {}) {
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
        name: namePrefix + PROCESS_RESIDENT_MEMORY,
        help: 'Resident memory size in bytes.',
        registers: registry ? [
            registry
        ] : undefined,
        labelNames,
        collect () {
            const memUsage = safeMemoryUsage();
            // I don't think the other things returned from `process.memoryUsage()` is relevant to a standard export
            if (memUsage) {
                this.set(labels, memUsage.rss);
            }
        }
    });
}
module.exports = (registry, config)=>("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notLinuxVariant(registry, config);
module.exports.metricNames = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : [
    PROCESS_RESIDENT_MEMORY
];
}),
"[project]/node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const process = __turbopack_context__.r("[externals]/process [external] (process, cjs)");
const PROCESS_OPEN_FDS = 'process_open_fds';
module.exports = (registry, config = {})=>{
    if ("TURBOPACK compile-time truthy", 1) {
        return;
    }
    //TURBOPACK unreachable
    ;
    const namePrefix = undefined;
    const labels = undefined;
    const labelNames = undefined;
};
module.exports.metricNames = [
    PROCESS_OPEN_FDS
];
}),
"[project]/node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const PROCESS_MAX_FDS = 'process_max_fds';
let maxFds;
module.exports = (registry, config = {})=>{
    if (maxFds === undefined) {
        // This will fail if a linux-like procfs is not available.
        try {
            const limits = fs.readFileSync('/proc/self/limits', 'utf8');
            const lines = limits.split('\n');
            for (const line of lines){
                if (line.startsWith('Max open files')) {
                    const parts = line.split(/  +/);
                    maxFds = Number(parts[1]);
                    break;
                }
            }
        } catch  {
            return;
        }
    }
    if (maxFds === undefined) return;
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
        name: namePrefix + PROCESS_MAX_FDS,
        help: 'Maximum number of open file descriptors.',
        registers: registry ? [
            registry
        ] : undefined,
        labelNames,
        collect () {
            if (maxFds !== undefined) this.set(labels, maxFds);
        }
    });
};
module.exports.metricNames = [
    PROCESS_MAX_FDS
];
}),
"[project]/node_modules/prom-client/lib/metrics/eventLoopLag.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
// Check if perf_hooks module is available
let perf_hooks;
try {
    perf_hooks = __turbopack_context__.r("[externals]/perf_hooks [external] (perf_hooks, cjs)");
} catch  {
// node version is too old
}
// Reported always.
const NODEJS_EVENTLOOP_LAG = 'nodejs_eventloop_lag_seconds';
// Reported only when perf_hooks is available.
const NODEJS_EVENTLOOP_LAG_MIN = 'nodejs_eventloop_lag_min_seconds';
const NODEJS_EVENTLOOP_LAG_MAX = 'nodejs_eventloop_lag_max_seconds';
const NODEJS_EVENTLOOP_LAG_MEAN = 'nodejs_eventloop_lag_mean_seconds';
const NODEJS_EVENTLOOP_LAG_STDDEV = 'nodejs_eventloop_lag_stddev_seconds';
const NODEJS_EVENTLOOP_LAG_P50 = 'nodejs_eventloop_lag_p50_seconds';
const NODEJS_EVENTLOOP_LAG_P90 = 'nodejs_eventloop_lag_p90_seconds';
const NODEJS_EVENTLOOP_LAG_P99 = 'nodejs_eventloop_lag_p99_seconds';
function reportEventloopLag(start, gauge, labels) {
    const delta = process.hrtime(start);
    const nanosec = delta[0] * 1e9 + delta[1];
    const seconds = nanosec / 1e9;
    gauge.set(labels, seconds);
}
module.exports = (registry, config = {})=>{
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry ? [
        registry
    ] : undefined;
    let collect = ()=>{
        const start = process.hrtime();
        setImmediate(reportEventloopLag, start, lag, labels);
    };
    if (perf_hooks && perf_hooks.monitorEventLoopDelay) {
        try {
            const histogram = perf_hooks.monitorEventLoopDelay({
                resolution: config.eventLoopMonitoringPrecision
            });
            histogram.enable();
            collect = ()=>{
                const start = process.hrtime();
                setImmediate(reportEventloopLag, start, lag, labels);
                lagMin.set(labels, histogram.min / 1e9);
                lagMax.set(labels, histogram.max / 1e9);
                lagMean.set(labels, histogram.mean / 1e9);
                lagStddev.set(labels, histogram.stddev / 1e9);
                lagP50.set(labels, histogram.percentile(50) / 1e9);
                lagP90.set(labels, histogram.percentile(90) / 1e9);
                lagP99.set(labels, histogram.percentile(99) / 1e9);
                histogram.reset();
            };
        } catch (e) {
            if (e.code === 'ERR_NOT_IMPLEMENTED') {
                return; // Bun
            }
            throw e;
        }
    }
    const lag = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG,
        help: 'Lag of event loop in seconds.',
        registers,
        labelNames,
        aggregator: 'average',
        // Use this one metric's `collect` to set all metrics' values.
        collect
    });
    const lagMin = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_MIN,
        help: 'The minimum recorded event loop delay.',
        registers,
        labelNames,
        aggregator: 'min'
    });
    const lagMax = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_MAX,
        help: 'The maximum recorded event loop delay.',
        registers,
        labelNames,
        aggregator: 'max'
    });
    const lagMean = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_MEAN,
        help: 'The mean of the recorded event loop delays.',
        registers,
        labelNames,
        aggregator: 'average'
    });
    const lagStddev = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_STDDEV,
        help: 'The standard deviation of the recorded event loop delays.',
        registers,
        labelNames,
        aggregator: 'average'
    });
    const lagP50 = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_P50,
        help: 'The 50th percentile of the recorded event loop delays.',
        registers,
        labelNames,
        aggregator: 'average'
    });
    const lagP90 = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_P90,
        help: 'The 90th percentile of the recorded event loop delays.',
        registers,
        labelNames,
        aggregator: 'average'
    });
    const lagP99 = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_P99,
        help: 'The 99th percentile of the recorded event loop delays.',
        registers,
        labelNames,
        aggregator: 'average'
    });
};
module.exports.metricNames = [
    NODEJS_EVENTLOOP_LAG,
    NODEJS_EVENTLOOP_LAG_MIN,
    NODEJS_EVENTLOOP_LAG_MAX,
    NODEJS_EVENTLOOP_LAG_MEAN,
    NODEJS_EVENTLOOP_LAG_STDDEV,
    NODEJS_EVENTLOOP_LAG_P50,
    NODEJS_EVENTLOOP_LAG_P90,
    NODEJS_EVENTLOOP_LAG_P99
];
}),
"[project]/node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function aggregateByObjectName(list) {
    const data = {};
    for(let i = 0; i < list.length; i++){
        const listElement = list[i];
        if (!listElement || typeof listElement.constructor === 'undefined') {
            continue;
        }
        if (Object.hasOwnProperty.call(data, listElement.constructor.name)) {
            data[listElement.constructor.name] += 1;
        } else {
            data[listElement.constructor.name] = 1;
        }
    }
    return data;
}
function updateMetrics(gauge, data, labels) {
    gauge.reset();
    for(const key in data){
        gauge.set(Object.assign({
            type: key
        }, labels || {}), data[key]);
    }
}
module.exports = {
    aggregateByObjectName,
    updateMetrics
};
}),
"[project]/node_modules/prom-client/lib/metrics/processHandles.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { aggregateByObjectName } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js [app-route] (ecmascript)");
const { updateMetrics } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js [app-route] (ecmascript)");
const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const NODEJS_ACTIVE_HANDLES = 'nodejs_active_handles';
const NODEJS_ACTIVE_HANDLES_TOTAL = 'nodejs_active_handles_total';
module.exports = (registry, config = {})=>{
    // Don't do anything if the function is removed in later nodes (exists in node@6-12...)
    if (typeof process._getActiveHandles !== 'function') {
        return;
    }
    const registers = registry ? [
        registry
    ] : undefined;
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
        name: namePrefix + NODEJS_ACTIVE_HANDLES,
        help: 'Number of active libuv handles grouped by handle type. Every handle type is C++ class name.',
        labelNames: [
            'type',
            ...labelNames
        ],
        registers,
        collect () {
            const handles = process._getActiveHandles();
            updateMetrics(this, aggregateByObjectName(handles), labels);
        }
    });
    new Gauge({
        name: namePrefix + NODEJS_ACTIVE_HANDLES_TOTAL,
        help: 'Total number of active handles.',
        registers,
        labelNames,
        collect () {
            const handles = process._getActiveHandles();
            this.set(labels, handles.length);
        }
    });
};
module.exports.metricNames = [
    NODEJS_ACTIVE_HANDLES,
    NODEJS_ACTIVE_HANDLES_TOTAL
];
}),
"[project]/node_modules/prom-client/lib/metrics/processRequests.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const { aggregateByObjectName } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js [app-route] (ecmascript)");
const { updateMetrics } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js [app-route] (ecmascript)");
const NODEJS_ACTIVE_REQUESTS = 'nodejs_active_requests';
const NODEJS_ACTIVE_REQUESTS_TOTAL = 'nodejs_active_requests_total';
module.exports = (registry, config = {})=>{
    // Don't do anything if the function is removed in later nodes (exists in node@6)
    if (typeof process._getActiveRequests !== 'function') {
        return;
    }
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
        name: namePrefix + NODEJS_ACTIVE_REQUESTS,
        help: 'Number of active libuv requests grouped by request type. Every request type is C++ class name.',
        labelNames: [
            'type',
            ...labelNames
        ],
        registers: registry ? [
            registry
        ] : undefined,
        collect () {
            const requests = process._getActiveRequests();
            updateMetrics(this, aggregateByObjectName(requests), labels);
        }
    });
    new Gauge({
        name: namePrefix + NODEJS_ACTIVE_REQUESTS_TOTAL,
        help: 'Total number of active requests.',
        registers: registry ? [
            registry
        ] : undefined,
        labelNames,
        collect () {
            const requests = process._getActiveRequests();
            this.set(labels, requests.length);
        }
    });
};
module.exports.metricNames = [
    NODEJS_ACTIVE_REQUESTS,
    NODEJS_ACTIVE_REQUESTS_TOTAL
];
}),
"[project]/node_modules/prom-client/lib/metrics/processResources.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const { updateMetrics } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js [app-route] (ecmascript)");
const NODEJS_ACTIVE_RESOURCES = 'nodejs_active_resources';
const NODEJS_ACTIVE_RESOURCES_TOTAL = 'nodejs_active_resources_total';
module.exports = (registry, config = {})=>{
    // Don't do anything if the function does not exist in previous nodes (exists in node@17.3.0)
    if (typeof process.getActiveResourcesInfo !== 'function') {
        return;
    }
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
        name: namePrefix + NODEJS_ACTIVE_RESOURCES,
        help: 'Number of active resources that are currently keeping the event loop alive, grouped by async resource type.',
        labelNames: [
            'type',
            ...labelNames
        ],
        registers: registry ? [
            registry
        ] : undefined,
        collect () {
            const resources = process.getActiveResourcesInfo();
            const data = {};
            for(let i = 0; i < resources.length; i++){
                const resource = resources[i];
                if (Object.hasOwn(data, resource)) {
                    data[resource] += 1;
                } else {
                    data[resource] = 1;
                }
            }
            updateMetrics(this, data, labels);
        }
    });
    new Gauge({
        name: namePrefix + NODEJS_ACTIVE_RESOURCES_TOTAL,
        help: 'Total number of active resources.',
        registers: registry ? [
            registry
        ] : undefined,
        labelNames,
        collect () {
            const resources = process.getActiveResourcesInfo();
            this.set(labels, resources.length);
        }
    });
};
module.exports.metricNames = [
    NODEJS_ACTIVE_RESOURCES,
    NODEJS_ACTIVE_RESOURCES_TOTAL
];
}),
"[project]/node_modules/prom-client/lib/metrics/heapSizeAndUsed.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const safeMemoryUsage = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js [app-route] (ecmascript)");
const NODEJS_HEAP_SIZE_TOTAL = 'nodejs_heap_size_total_bytes';
const NODEJS_HEAP_SIZE_USED = 'nodejs_heap_size_used_bytes';
const NODEJS_EXTERNAL_MEMORY = 'nodejs_external_memory_bytes';
module.exports = (registry, config = {})=>{
    if (typeof process.memoryUsage !== 'function') {
        return;
    }
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry ? [
        registry
    ] : undefined;
    const namePrefix = config.prefix ? config.prefix : '';
    const collect = ()=>{
        const memUsage = safeMemoryUsage();
        if (memUsage) {
            heapSizeTotal.set(labels, memUsage.heapTotal);
            heapSizeUsed.set(labels, memUsage.heapUsed);
            if (memUsage.external !== undefined) {
                externalMemUsed.set(labels, memUsage.external);
            }
        }
    };
    const heapSizeTotal = new Gauge({
        name: namePrefix + NODEJS_HEAP_SIZE_TOTAL,
        help: 'Process heap size from Node.js in bytes.',
        registers,
        labelNames,
        // Use this one metric's `collect` to set all metrics' values.
        collect
    });
    const heapSizeUsed = new Gauge({
        name: namePrefix + NODEJS_HEAP_SIZE_USED,
        help: 'Process heap size used from Node.js in bytes.',
        registers,
        labelNames
    });
    const externalMemUsed = new Gauge({
        name: namePrefix + NODEJS_EXTERNAL_MEMORY,
        help: 'Node.js external memory size in bytes.',
        registers,
        labelNames
    });
};
module.exports.metricNames = [
    NODEJS_HEAP_SIZE_TOTAL,
    NODEJS_HEAP_SIZE_USED,
    NODEJS_EXTERNAL_MEMORY
];
}),
"[project]/node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const v8 = __turbopack_context__.r("[externals]/v8 [external] (v8, cjs)");
const METRICS = [
    'total',
    'used',
    'available'
];
const NODEJS_HEAP_SIZE = {};
METRICS.forEach((metricType)=>{
    NODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;
});
module.exports = (registry, config = {})=>{
    try {
        v8.getHeapSpaceStatistics();
    } catch (e) {
        if (e.code === 'ERR_NOT_IMPLEMENTED') {
            return; // Bun
        }
        throw e;
    }
    const registers = registry ? [
        registry
    ] : undefined;
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = [
        'space',
        ...Object.keys(labels)
    ];
    const gauges = {};
    METRICS.forEach((metricType)=>{
        gauges[metricType] = new Gauge({
            name: namePrefix + NODEJS_HEAP_SIZE[metricType],
            help: `Process heap space size ${metricType} from Node.js in bytes.`,
            labelNames,
            registers
        });
    });
    // Use this one metric's `collect` to set all metrics' values.
    gauges.total.collect = ()=>{
        for (const space of v8.getHeapSpaceStatistics()){
            const spaceName = space.space_name.substr(0, space.space_name.indexOf('_space'));
            gauges.total.set({
                space: spaceName,
                ...labels
            }, space.space_size);
            gauges.used.set({
                space: spaceName,
                ...labels
            }, space.space_used_size);
            gauges.available.set({
                space: spaceName,
                ...labels
            }, space.space_available_size);
        }
    };
};
module.exports.metricNames = Object.values(NODEJS_HEAP_SIZE);
}),
"[project]/node_modules/prom-client/lib/metrics/version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
const version = process.version;
const versionSegments = version.slice(1).split('.').map(Number);
const NODE_VERSION_INFO = 'nodejs_version_info';
module.exports = (registry, config = {})=>{
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
        name: namePrefix + NODE_VERSION_INFO,
        help: 'Node.js version info.',
        labelNames: [
            'version',
            'major',
            'minor',
            'patch',
            ...labelNames
        ],
        registers: registry ? [
            registry
        ] : undefined,
        aggregator: 'first',
        collect () {
            // Needs to be in collect() so value is present even if reg is reset
            this.labels(version, versionSegments[0], versionSegments[1], versionSegments[2], ...Object.values(labels)).set(1);
        }
    });
};
module.exports.metricNames = [
    NODE_VERSION_INFO
];
}),
"[project]/node_modules/prom-client/lib/metrics/gc.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Histogram = __turbopack_context__.r("[project]/node_modules/prom-client/lib/histogram.js [app-route] (ecmascript)");
let perf_hooks;
try {
    // eslint-disable-next-line
    perf_hooks = __turbopack_context__.r("[externals]/perf_hooks [external] (perf_hooks, cjs)");
} catch  {
// node version is too old
}
const NODEJS_GC_DURATION_SECONDS = 'nodejs_gc_duration_seconds';
const DEFAULT_GC_DURATION_BUCKETS = [
    0.001,
    0.01,
    0.1,
    1,
    2,
    5
];
const kinds = [];
if (perf_hooks && perf_hooks.constants) {
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MAJOR] = 'major';
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MINOR] = 'minor';
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_INCREMENTAL] = 'incremental';
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_WEAKCB] = 'weakcb';
}
module.exports = (registry, config = {})=>{
    if (!perf_hooks) {
        return;
    }
    const namePrefix = config.prefix ? config.prefix : '';
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const buckets = config.gcDurationBuckets ? config.gcDurationBuckets : DEFAULT_GC_DURATION_BUCKETS;
    const gcHistogram = new Histogram({
        name: namePrefix + NODEJS_GC_DURATION_SECONDS,
        help: 'Garbage collection duration by kind, one of major, minor, incremental or weakcb.',
        labelNames: [
            'kind',
            ...labelNames
        ],
        enableExemplars: false,
        buckets,
        registers: registry ? [
            registry
        ] : undefined
    });
    const obs = new perf_hooks.PerformanceObserver((list)=>{
        const entry = list.getEntries()[0];
        // Node < 16 uses entry.kind
        // Node >= 16 uses entry.detail.kind
        // See: https://nodejs.org/docs/latest-v16.x/api/deprecations.html#deprecations_dep0152_extension_performanceentry_properties
        const kind = entry.detail ? kinds[entry.detail.kind] : kinds[entry.kind];
        // Convert duration from milliseconds to seconds
        gcHistogram.observe(Object.assign({
            kind
        }, labels), entry.duration / 1000);
    });
    obs.observe({
        entryTypes: [
            'gc'
        ]
    });
};
module.exports.metricNames = [
    NODEJS_GC_DURATION_SECONDS
];
}),
"[project]/node_modules/prom-client/lib/defaultMetrics.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { isObject } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
// Default metrics.
const processCpuTotal = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/processCpuTotal.js [app-route] (ecmascript)");
const processStartTime = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/processStartTime.js [app-route] (ecmascript)");
const osMemoryHeap = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/osMemoryHeap.js [app-route] (ecmascript)");
const processOpenFileDescriptors = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js [app-route] (ecmascript)");
const processMaxFileDescriptors = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js [app-route] (ecmascript)");
const eventLoopLag = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/eventLoopLag.js [app-route] (ecmascript)");
const processHandles = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/processHandles.js [app-route] (ecmascript)");
const processRequests = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/processRequests.js [app-route] (ecmascript)");
const processResources = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/processResources.js [app-route] (ecmascript)");
const heapSizeAndUsed = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/heapSizeAndUsed.js [app-route] (ecmascript)");
const heapSpacesSizeAndUsed = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js [app-route] (ecmascript)");
const version = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/version.js [app-route] (ecmascript)");
const gc = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metrics/gc.js [app-route] (ecmascript)");
const metrics = {
    processCpuTotal,
    processStartTime,
    osMemoryHeap,
    processOpenFileDescriptors,
    processMaxFileDescriptors,
    eventLoopLag,
    ...typeof process.getActiveResourcesInfo === 'function' ? {
        processResources
    } : {},
    processHandles,
    processRequests,
    heapSizeAndUsed,
    heapSpacesSizeAndUsed,
    version,
    gc
};
const metricsList = Object.keys(metrics);
module.exports = function collectDefaultMetrics(config) {
    if (config !== null && config !== undefined && !isObject(config)) {
        throw new TypeError('config must be null, undefined, or an object');
    }
    config = {
        eventLoopMonitoringPrecision: 10,
        ...config
    };
    for (const metric of Object.values(metrics)){
        metric(config.register, config);
    }
};
module.exports.metricsList = metricsList;
}),
"[project]/node_modules/prom-client/lib/metricAggregators.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { Grouper, hashObject } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
/**
 * Returns a new function that applies the `aggregatorFn` to the values.
 * @param {Function} aggregatorFn function to apply to values.
 * @return {Function} aggregator function
 */ function AggregatorFactory(aggregatorFn) {
    return (metrics)=>{
        if (metrics.length === 0) return;
        const result = {
            help: metrics[0].help,
            name: metrics[0].name,
            type: metrics[0].type,
            values: [],
            aggregator: metrics[0].aggregator
        };
        // Gather metrics by metricName and labels.
        const byLabels = new Grouper();
        metrics.forEach((metric)=>{
            metric.values.forEach((value)=>{
                const key = hashObject(value.labels);
                byLabels.add(`${value.metricName}_${key}`, value);
            });
        });
        // Apply aggregator function to gathered metrics.
        byLabels.forEach((values)=>{
            if (values.length === 0) return;
            const valObj = {
                value: aggregatorFn(values),
                labels: values[0].labels
            };
            if (values[0].metricName) {
                valObj.metricName = values[0].metricName;
            }
            // NB: Timestamps are omitted.
            result.values.push(valObj);
        });
        return result;
    };
}
// Export for users to define their own aggregation methods.
exports.AggregatorFactory = AggregatorFactory;
/**
 * Functions that can be used to aggregate metrics from multiple registries.
 */ exports.aggregators = {
    /**
	 * @return The sum of values.
	 */ sum: AggregatorFactory((v)=>v.reduce((p, c)=>p + c.value, 0)),
    /**
	 * @return The first value.
	 */ first: AggregatorFactory((v)=>v[0].value),
    /**
	 * @return {undefined} Undefined; omits the metric.
	 */ omit: ()=>{},
    /**
	 * @return The arithmetic mean of the values.
	 */ average: AggregatorFactory((v)=>v.reduce((p, c)=>p + c.value, 0) / v.length),
    /**
	 * @return The minimum of the values.
	 */ min: AggregatorFactory((v)=>v.reduce((p, c)=>Math.min(p, c.value), Infinity)),
    /**
	 * @return The maximum of the values.
	 */ max: AggregatorFactory((v)=>v.reduce((p, c)=>Math.max(p, c.value), -Infinity))
};
}),
"[project]/node_modules/prom-client/lib/cluster.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Extends the Registry class with a `clusterMetrics` method that returns
 * aggregated metrics for all workers.
 *
 * In cluster workers, listens for and responds to requests for metrics by the
 * cluster master.
 */ const Registry = __turbopack_context__.r("[project]/node_modules/prom-client/lib/registry.js [app-route] (ecmascript)");
const { Grouper } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/util.js [app-route] (ecmascript)");
const { aggregators } = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metricAggregators.js [app-route] (ecmascript)");
// We need to lazy-load the 'cluster' module as some application servers -
// namely Passenger - crash when it is imported.
let cluster = ()=>{
    const data = __turbopack_context__.r("[externals]/cluster [external] (cluster, cjs)");
    cluster = ()=>data;
    return data;
};
const GET_METRICS_REQ = 'prom-client:getMetricsReq';
const GET_METRICS_RES = 'prom-client:getMetricsRes';
let registries = [
    Registry.globalRegistry
];
let requestCtr = 0; // Concurrency control
let listenersAdded = false;
const requests = new Map(); // Pending requests for workers' local metrics.
class AggregatorRegistry extends Registry {
    constructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE){
        super(regContentType);
        addListeners();
    }
    /**
	 * Gets aggregated metrics for all workers. The optional callback and
	 * returned Promise resolve with the same value; either may be used.
	 * @return {Promise<string>} Promise that resolves with the aggregated
	 *   metrics.
	 */ clusterMetrics() {
        const requestId = requestCtr++;
        return new Promise((resolve, reject)=>{
            let settled = false;
            function done(err, result) {
                if (settled) return;
                settled = true;
                if (err) reject(err);
                else resolve(result);
            }
            const request = {
                responses: [],
                pending: 0,
                done,
                errorTimeout: setTimeout(()=>{
                    const err = new Error('Operation timed out.');
                    request.done(err);
                }, 5000)
            };
            requests.set(requestId, request);
            const message = {
                type: GET_METRICS_REQ,
                requestId
            };
            for(const id in cluster().workers){
                // If the worker exits abruptly, it may still be in the workers
                // list but not able to communicate.
                if (cluster().workers[id].isConnected()) {
                    cluster().workers[id].send(message);
                    request.pending++;
                }
            }
            if (request.pending === 0) {
                // No workers were up
                clearTimeout(request.errorTimeout);
                process.nextTick(()=>done(null, ''));
            }
        });
    }
    get contentType() {
        return super.contentType;
    }
    /**
	 * Creates a new Registry instance from an array of metrics that were
	 * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using
	 * the method specified by their `aggregator` property, or by summation if
	 * `aggregator` is undefined.
	 * @param {Array} metricsArr Array of metrics, each of which created by
	 *   `registry.getMetricsAsJSON()`.
	 * @param {string} registryType content type of the new registry. Defaults
	 * to PROMETHEUS_CONTENT_TYPE.
	 * @return {Registry} aggregated registry.
	 */ static aggregate(metricsArr, registryType = Registry.PROMETHEUS_CONTENT_TYPE) {
        const aggregatedRegistry = new Registry();
        const metricsByName = new Grouper();
        aggregatedRegistry.setContentType(registryType);
        // Gather by name
        metricsArr.forEach((metrics)=>{
            metrics.forEach((metric)=>{
                metricsByName.add(metric.name, metric);
            });
        });
        // Aggregate gathered metrics.
        metricsByName.forEach((metrics)=>{
            const aggregatorName = metrics[0].aggregator;
            const aggregatorFn = aggregators[aggregatorName];
            if (typeof aggregatorFn !== 'function') {
                throw new Error(`'${aggregatorName}' is not a defined aggregator.`);
            }
            const aggregatedMetric = aggregatorFn(metrics);
            // NB: The 'omit' aggregator returns undefined.
            if (aggregatedMetric) {
                const aggregatedMetricWrapper = Object.assign({
                    get: ()=>aggregatedMetric
                }, aggregatedMetric);
                aggregatedRegistry.registerMetric(aggregatedMetricWrapper);
            }
        });
        return aggregatedRegistry;
    }
    /**
	 * Sets the registry or registries to be aggregated. Call from workers to
	 * use a registry/registries other than the default global registry.
	 * @param {Array<Registry>|Registry} regs Registry or registries to be
	 *   aggregated.
	 * @return {void}
	 */ static setRegistries(regs) {
        if (!Array.isArray(regs)) regs = [
            regs
        ];
        regs.forEach((reg)=>{
            if (!(reg instanceof Registry)) {
                throw new TypeError(`Expected Registry, got ${typeof reg}`);
            }
        });
        registries = regs;
    }
}
/**
 * Adds event listeners for cluster aggregation. Idempotent (safe to call more
 * than once).
 * @return {void}
 */ function addListeners() {
    if (listenersAdded) return;
    listenersAdded = true;
    if (cluster().isMaster) {
        // Listen for worker responses to requests for local metrics
        cluster().on('message', (worker, message)=>{
            if (message.type === GET_METRICS_RES) {
                const request = requests.get(message.requestId);
                if (message.error) {
                    request.done(new Error(message.error));
                    return;
                }
                message.metrics.forEach((registry)=>request.responses.push(registry));
                request.pending--;
                if (request.pending === 0) {
                    // finalize
                    requests.delete(message.requestId);
                    clearTimeout(request.errorTimeout);
                    const registry = AggregatorRegistry.aggregate(request.responses);
                    const promString = registry.metrics();
                    request.done(null, promString);
                }
            }
        });
    }
    if (cluster().isWorker) {
        // Respond to master's requests for worker's local metrics.
        process.on('message', (message)=>{
            if (message.type === GET_METRICS_REQ) {
                Promise.all(registries.map((r)=>r.getMetricsAsJSON())).then((metrics)=>{
                    process.send({
                        type: GET_METRICS_RES,
                        requestId: message.requestId,
                        metrics
                    });
                }).catch((error)=>{
                    process.send({
                        type: GET_METRICS_RES,
                        requestId: message.requestId,
                        error: error.message
                    });
                });
            }
        });
    }
}
module.exports = AggregatorRegistry;
}),
"[project]/node_modules/prom-client/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Prometheus client
 * @module Prometheus client
 */ exports.register = __turbopack_context__.r("[project]/node_modules/prom-client/lib/registry.js [app-route] (ecmascript)").globalRegistry;
exports.Registry = __turbopack_context__.r("[project]/node_modules/prom-client/lib/registry.js [app-route] (ecmascript)");
Object.defineProperty(exports, 'contentType', {
    configurable: false,
    enumerable: true,
    get () {
        return exports.register.contentType;
    },
    set (value) {
        exports.register.setContentType(value);
    }
});
exports.prometheusContentType = exports.Registry.PROMETHEUS_CONTENT_TYPE;
exports.openMetricsContentType = exports.Registry.OPENMETRICS_CONTENT_TYPE;
exports.validateMetricName = __turbopack_context__.r("[project]/node_modules/prom-client/lib/validation.js [app-route] (ecmascript)").validateMetricName;
exports.Counter = __turbopack_context__.r("[project]/node_modules/prom-client/lib/counter.js [app-route] (ecmascript)");
exports.Gauge = __turbopack_context__.r("[project]/node_modules/prom-client/lib/gauge.js [app-route] (ecmascript)");
exports.Histogram = __turbopack_context__.r("[project]/node_modules/prom-client/lib/histogram.js [app-route] (ecmascript)");
exports.Summary = __turbopack_context__.r("[project]/node_modules/prom-client/lib/summary.js [app-route] (ecmascript)");
exports.Pushgateway = __turbopack_context__.r("[project]/node_modules/prom-client/lib/pushgateway.js [app-route] (ecmascript)");
exports.linearBuckets = __turbopack_context__.r("[project]/node_modules/prom-client/lib/bucketGenerators.js [app-route] (ecmascript)").linearBuckets;
exports.exponentialBuckets = __turbopack_context__.r("[project]/node_modules/prom-client/lib/bucketGenerators.js [app-route] (ecmascript)").exponentialBuckets;
exports.collectDefaultMetrics = __turbopack_context__.r("[project]/node_modules/prom-client/lib/defaultMetrics.js [app-route] (ecmascript)");
exports.aggregators = __turbopack_context__.r("[project]/node_modules/prom-client/lib/metricAggregators.js [app-route] (ecmascript)").aggregators;
exports.AggregatorRegistry = __turbopack_context__.r("[project]/node_modules/prom-client/lib/cluster.js [app-route] (ecmascript)");
}),
"[project]/node_modules/bintrees/lib/treebase.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

function TreeBase() {}
// removes all nodes from the tree
TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
};
// returns node data if found, null otherwise
TreeBase.prototype.find = function(data) {
    var res = this._root;
    while(res !== null){
        var c = this._comparator(data, res.data);
        if (c === 0) {
            return res.data;
        } else {
            res = res.get_child(c > 0);
        }
    }
    return null;
};
// returns iterator to node if found, null otherwise
TreeBase.prototype.findIter = function(data) {
    var res = this._root;
    var iter = this.iterator();
    while(res !== null){
        var c = this._comparator(data, res.data);
        if (c === 0) {
            iter._cursor = res;
            return iter;
        } else {
            iter._ancestors.push(res);
            res = res.get_child(c > 0);
        }
    }
    return null;
};
// Returns an iterator to the tree node at or immediately after the item
TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;
    while(cur !== null){
        var c = cmp(item, cur.data);
        if (c === 0) {
            iter._cursor = cur;
            return iter;
        }
        iter._ancestors.push(cur);
        cur = cur.get_child(c > 0);
    }
    for(var i = iter._ancestors.length - 1; i >= 0; --i){
        cur = iter._ancestors[i];
        if (cmp(item, cur.data) < 0) {
            iter._cursor = cur;
            iter._ancestors.length = i;
            return iter;
        }
    }
    iter._ancestors.length = 0;
    return iter;
};
// Returns an iterator to the tree node immediately after the item
TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;
    while(iter.data() !== null && cmp(iter.data(), item) === 0){
        iter.next();
    }
    return iter;
};
// returns null if tree is empty
TreeBase.prototype.min = function() {
    var res = this._root;
    if (res === null) {
        return null;
    }
    while(res.left !== null){
        res = res.left;
    }
    return res.data;
};
// returns null if tree is empty
TreeBase.prototype.max = function() {
    var res = this._root;
    if (res === null) {
        return null;
    }
    while(res.right !== null){
        res = res.right;
    }
    return res.data;
};
// returns a null iterator
// call next() or prev() to point to an element
TreeBase.prototype.iterator = function() {
    return new Iterator(this);
};
// calls cb on each node's data, in order
TreeBase.prototype.each = function(cb) {
    var it = this.iterator(), data;
    while((data = it.next()) !== null){
        if (cb(data) === false) {
            return;
        }
    }
};
// calls cb on each node's data, in reverse order
TreeBase.prototype.reach = function(cb) {
    var it = this.iterator(), data;
    while((data = it.prev()) !== null){
        if (cb(data) === false) {
            return;
        }
    }
};
function Iterator(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
}
Iterator.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
};
// if null-iterator, returns first node
// otherwise, returns next node
Iterator.prototype.next = function() {
    if (this._cursor === null) {
        var root = this._tree._root;
        if (root !== null) {
            this._minNode(root);
        }
    } else {
        if (this._cursor.right === null) {
            // no greater node in subtree, go up to parent
            // if coming from a right child, continue up the stack
            var save;
            do {
                save = this._cursor;
                if (this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                } else {
                    this._cursor = null;
                    break;
                }
            }while (this._cursor.right === save)
        } else {
            // get the next node from the subtree
            this._ancestors.push(this._cursor);
            this._minNode(this._cursor.right);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};
// if null-iterator, returns last node
// otherwise, returns previous node
Iterator.prototype.prev = function() {
    if (this._cursor === null) {
        var root = this._tree._root;
        if (root !== null) {
            this._maxNode(root);
        }
    } else {
        if (this._cursor.left === null) {
            var save;
            do {
                save = this._cursor;
                if (this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                } else {
                    this._cursor = null;
                    break;
                }
            }while (this._cursor.left === save)
        } else {
            this._ancestors.push(this._cursor);
            this._maxNode(this._cursor.left);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};
Iterator.prototype._minNode = function(start) {
    while(start.left !== null){
        this._ancestors.push(start);
        start = start.left;
    }
    this._cursor = start;
};
Iterator.prototype._maxNode = function(start) {
    while(start.right !== null){
        this._ancestors.push(start);
        start = start.right;
    }
    this._cursor = start;
};
module.exports = TreeBase;
}),
"[project]/node_modules/bintrees/lib/rbtree.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var TreeBase = __turbopack_context__.r("[project]/node_modules/bintrees/lib/treebase.js [app-route] (ecmascript)");
function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
    this.red = true;
}
Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};
Node.prototype.set_child = function(dir, val) {
    if (dir) {
        this.right = val;
    } else {
        this.left = val;
    }
};
function RBTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}
RBTree.prototype = new TreeBase();
// returns true if inserted, false if duplicate
RBTree.prototype.insert = function(data) {
    var ret = false;
    if (this._root === null) {
        // empty tree
        this._root = new Node(data);
        ret = true;
        this.size++;
    } else {
        var head = new Node(undefined); // fake tree root
        var dir = 0;
        var last = 0;
        // setup
        var gp = null; // grandparent
        var ggp = head; // grand-grand-parent
        var p = null; // parent
        var node = this._root;
        ggp.right = this._root;
        // search down
        while(true){
            if (node === null) {
                // insert new node at the bottom
                node = new Node(data);
                p.set_child(dir, node);
                ret = true;
                this.size++;
            } else if (is_red(node.left) && is_red(node.right)) {
                // color flip
                node.red = true;
                node.left.red = false;
                node.right.red = false;
            }
            // fix red violation
            if (is_red(node) && is_red(p)) {
                var dir2 = ggp.right === gp;
                if (node === p.get_child(last)) {
                    ggp.set_child(dir2, single_rotate(gp, !last));
                } else {
                    ggp.set_child(dir2, double_rotate(gp, !last));
                }
            }
            var cmp = this._comparator(node.data, data);
            // stop if found
            if (cmp === 0) {
                break;
            }
            last = dir;
            dir = cmp < 0;
            // update helpers
            if (gp !== null) {
                ggp = gp;
            }
            gp = p;
            p = node;
            node = node.get_child(dir);
        }
        // update root
        this._root = head.right;
    }
    // make root black
    this._root.red = false;
    return ret;
};
// returns true if removed, false if not found
RBTree.prototype.remove = function(data) {
    if (this._root === null) {
        return false;
    }
    var head = new Node(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var gp = null; // grand parent
    var found = null; // found item
    var dir = 1;
    while(node.get_child(dir) !== null){
        var last = dir;
        // update helpers
        gp = p;
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;
        // save found node
        if (cmp === 0) {
            found = node;
        }
        // push the red node down
        if (!is_red(node) && !is_red(node.get_child(dir))) {
            if (is_red(node.get_child(!dir))) {
                var sr = single_rotate(node, dir);
                p.set_child(last, sr);
                p = sr;
            } else if (!is_red(node.get_child(!dir))) {
                var sibling = p.get_child(!last);
                if (sibling !== null) {
                    if (!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
                        // color flip
                        p.red = false;
                        sibling.red = true;
                        node.red = true;
                    } else {
                        var dir2 = gp.right === p;
                        if (is_red(sibling.get_child(last))) {
                            gp.set_child(dir2, double_rotate(p, last));
                        } else if (is_red(sibling.get_child(!last))) {
                            gp.set_child(dir2, single_rotate(p, last));
                        }
                        // ensure correct coloring
                        var gpc = gp.get_child(dir2);
                        gpc.red = true;
                        node.red = true;
                        gpc.left.red = false;
                        gpc.right.red = false;
                    }
                }
            }
        }
    }
    // replace and remove if found
    if (found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this.size--;
    }
    // update root and make it black
    this._root = head.right;
    if (this._root !== null) {
        this._root.red = false;
    }
    return found !== null;
};
function is_red(node) {
    return node !== null && node.red;
}
function single_rotate(root, dir) {
    var save = root.get_child(!dir);
    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);
    root.red = true;
    save.red = false;
    return save;
}
function double_rotate(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
}
module.exports = RBTree;
}),
"[project]/node_modules/bintrees/lib/bintree.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var TreeBase = __turbopack_context__.r("[project]/node_modules/bintrees/lib/treebase.js [app-route] (ecmascript)");
function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}
Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};
Node.prototype.set_child = function(dir, val) {
    if (dir) {
        this.right = val;
    } else {
        this.left = val;
    }
};
function BinTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}
BinTree.prototype = new TreeBase();
// returns true if inserted, false if duplicate
BinTree.prototype.insert = function(data) {
    if (this._root === null) {
        // empty tree
        this._root = new Node(data);
        this.size++;
        return true;
    }
    var dir = 0;
    // setup
    var p = null; // parent
    var node = this._root;
    // search down
    while(true){
        if (node === null) {
            // insert new node at the bottom
            node = new Node(data);
            p.set_child(dir, node);
            ret = true;
            this.size++;
            return true;
        }
        // stop if found
        if (this._comparator(node.data, data) === 0) {
            return false;
        }
        dir = this._comparator(node.data, data) < 0;
        // update helpers
        p = node;
        node = node.get_child(dir);
    }
};
// returns true if removed, false if not found
BinTree.prototype.remove = function(data) {
    if (this._root === null) {
        return false;
    }
    var head = new Node(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var found = null; // found item
    var dir = 1;
    while(node.get_child(dir) !== null){
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;
        if (cmp === 0) {
            found = node;
        }
    }
    if (found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this._root = head.right;
        this.size--;
        return true;
    } else {
        return false;
    }
};
module.exports = BinTree;
}),
"[project]/node_modules/bintrees/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    RBTree: __turbopack_context__.r("[project]/node_modules/bintrees/lib/rbtree.js [app-route] (ecmascript)"),
    BinTree: __turbopack_context__.r("[project]/node_modules/bintrees/lib/bintree.js [app-route] (ecmascript)")
};
}),
"[project]/node_modules/tdigest/tdigest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

//
// TDigest:
//
// approximate distribution percentiles from a stream of reals
//
var RBTree = __turbopack_context__.r("[project]/node_modules/bintrees/index.js [app-route] (ecmascript)").RBTree;
function TDigest(delta, K, CX) {
    // allocate a TDigest structure.
    //
    // delta is the compression factor, the max fraction of mass that
    // can be owned by one centroid (bigger, up to 1.0, means more
    // compression). delta=false switches off TDigest behavior and treats
    // the distribution as discrete, with no merging and exact values
    // reported.
    //
    // K is a size threshold that triggers recompression as the TDigest
    // grows during input.  (Set it to 0 to disable automatic recompression)
    //
    // CX specifies how often to update cached cumulative totals used
    // for quantile estimation during ingest (see cumulate()).  Set to
    // 0 to use exact quantiles for each new point.
    //
    this.discrete = delta === false;
    this.delta = delta || 0.01;
    this.K = K === undefined ? 25 : K;
    this.CX = CX === undefined ? 1.1 : CX;
    this.centroids = new RBTree(compare_centroid_means);
    this.nreset = 0;
    this.reset();
}
TDigest.prototype.reset = function() {
    // prepare to digest new points.
    //
    this.centroids.clear();
    this.n = 0;
    this.nreset += 1;
    this.last_cumulate = 0;
};
TDigest.prototype.size = function() {
    return this.centroids.size;
};
TDigest.prototype.toArray = function(everything) {
    // return {mean,n} of centroids as an array ordered by mean.
    //
    var result = [];
    if (everything) {
        this._cumulate(true); // be sure cumns are exact
        this.centroids.each(function(c) {
            result.push(c);
        });
    } else {
        this.centroids.each(function(c) {
            result.push({
                mean: c.mean,
                n: c.n
            });
        });
    }
    return result;
};
TDigest.prototype.summary = function() {
    var approx = this.discrete ? "exact " : "approximating ";
    var s = [
        approx + this.n + " samples using " + this.size() + " centroids",
        "min = " + this.percentile(0),
        "Q1  = " + this.percentile(0.25),
        "Q2  = " + this.percentile(0.5),
        "Q3  = " + this.percentile(0.75),
        "max = " + this.percentile(1.0)
    ];
    return s.join('\n');
};
function compare_centroid_means(a, b) {
    // order two centroids by mean.
    //
    return a.mean > b.mean ? 1 : a.mean < b.mean ? -1 : 0;
}
function compare_centroid_mean_cumns(a, b) {
    // order two centroids by mean_cumn.
    //
    return a.mean_cumn - b.mean_cumn;
}
TDigest.prototype.push = function(x, n) {
    // incorporate value or array of values x, having count n into the
    // TDigest. n defaults to 1.
    //
    n = n || 1;
    x = Array.isArray(x) ? x : [
        x
    ];
    for(var i = 0; i < x.length; i++){
        this._digest(x[i], n);
    }
};
TDigest.prototype.push_centroid = function(c) {
    // incorporate centroid or array of centroids c
    //
    c = Array.isArray(c) ? c : [
        c
    ];
    for(var i = 0; i < c.length; i++){
        this._digest(c[i].mean, c[i].n);
    }
};
TDigest.prototype._cumulate = function(exact) {
    // update cumulative counts for each centroid
    //
    // exact: falsey means only cumulate after sufficient
    // growth. During ingest, these counts are used as quantile
    // estimates, and they work well even when somewhat out of
    // date. (this is a departure from the publication, you may set CX
    // to 0 to disable).
    //
    if (this.n === this.last_cumulate || !exact && this.CX && this.CX > this.n / this.last_cumulate) {
        return;
    }
    var cumn = 0;
    this.centroids.each(function(c) {
        c.mean_cumn = cumn + c.n / 2; // half of n at the mean
        cumn = c.cumn = cumn + c.n;
    });
    this.n = this.last_cumulate = cumn;
};
TDigest.prototype.find_nearest = function(x) {
    // find the centroid closest to x. The assumption of
    // unique means and a unique nearest centroid departs from the
    // paper, see _digest() below
    //
    if (this.size() === 0) {
        return null;
    }
    var iter = this.centroids.lowerBound({
        mean: x
    }); // x <= iter || iter==null
    var c = iter.data() === null ? iter.prev() : iter.data();
    if (c.mean === x || this.discrete) {
        return c; // c is either x or a neighbor (discrete: no distance func)
    }
    var prev = iter.prev();
    if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {
        return prev;
    } else {
        return c;
    }
};
TDigest.prototype._new_centroid = function(x, n, cumn) {
    // create and insert a new centroid into the digest (don't update
    // cumulatives).
    //
    var c = {
        mean: x,
        n: n,
        cumn: cumn
    };
    this.centroids.insert(c);
    this.n += n;
    return c;
};
TDigest.prototype._addweight = function(nearest, x, n) {
    // add weight at location x to nearest centroid.  adding x to
    // nearest will not shift its relative position in the tree and
    // require reinsertion.
    //
    if (x !== nearest.mean) {
        nearest.mean += n * (x - nearest.mean) / (nearest.n + n);
    }
    nearest.cumn += n;
    nearest.mean_cumn += n / 2;
    nearest.n += n;
    this.n += n;
};
TDigest.prototype._digest = function(x, n) {
    // incorporate value x, having count n into the TDigest.
    //
    var min = this.centroids.min();
    var max = this.centroids.max();
    var nearest = this.find_nearest(x);
    if (nearest && nearest.mean === x) {
        // accumulate exact matches into the centroid without
        // limit. this is a departure from the paper, made so
        // centroids remain unique and code can be simple.
        this._addweight(nearest, x, n);
    } else if (nearest === min) {
        this._new_centroid(x, n, 0); // new point around min boundary
    } else if (nearest === max) {
        this._new_centroid(x, n, this.n); // new point around max boundary
    } else if (this.discrete) {
        this._new_centroid(x, n, nearest.cumn); // never merge
    } else {
        // conider a merge based on nearest centroid's capacity. if
        // there's not room for all of n, don't bother merging any of
        // it into nearest, as we'll have to make a new centroid
        // anyway for the remainder (departure from the paper).
        var p = nearest.mean_cumn / this.n;
        var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));
        if (max_n - nearest.n >= n) {
            this._addweight(nearest, x, n);
        } else {
            this._new_centroid(x, n, nearest.cumn);
        }
    }
    this._cumulate(false);
    if (!this.discrete && this.K && this.size() > this.K / this.delta) {
        // re-process the centroids and hope for some compression.
        this.compress();
    }
};
TDigest.prototype.bound_mean = function(x) {
    // find centroids lower and upper such that lower.mean < x <
    // upper.mean or lower.mean === x === upper.mean. Don't call
    // this for x out of bounds.
    //
    var iter = this.centroids.upperBound({
        mean: x
    }); // x < iter
    var lower = iter.prev(); // lower <= x
    var upper = lower.mean === x ? lower : iter.next();
    return [
        lower,
        upper
    ];
};
TDigest.prototype.p_rank = function(x_or_xlist) {
    // return approximate percentile-ranks (0..1) for data value x.
    // or list of x.  calculated according to
    // https://en.wikipedia.org/wiki/Percentile_rank
    //
    // (Note that in continuous mode, boundary sample values will
    // report half their centroid weight inward from 0/1 as the
    // percentile-rank. X values outside the observed range return
    // 0/1)
    //
    // this triggers cumulate() if cumn's are out of date.
    //
    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [
        x_or_xlist
    ];
    var ps = xs.map(this._p_rank, this);
    return Array.isArray(x_or_xlist) ? ps : ps[0];
};
TDigest.prototype._p_rank = function(x) {
    if (this.size() === 0) {
        return undefined;
    } else if (x < this.centroids.min().mean) {
        return 0.0;
    } else if (x > this.centroids.max().mean) {
        return 1.0;
    }
    // find centroids that bracket x and interpolate x's cumn from
    // their cumn's.
    this._cumulate(true); // be sure cumns are exact
    var bound = this.bound_mean(x);
    var lower = bound[0], upper = bound[1];
    if (this.discrete) {
        return lower.cumn / this.n;
    } else {
        var cumn = lower.mean_cumn;
        if (lower !== upper) {
            cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);
        }
        return cumn / this.n;
    }
};
TDigest.prototype.bound_mean_cumn = function(cumn) {
    // find centroids lower and upper such that lower.mean_cumn < x <
    // upper.mean_cumn or lower.mean_cumn === x === upper.mean_cumn. Don't call
    // this for cumn out of bounds.
    //
    // XXX because mean and mean_cumn give rise to the same sort order
    // (up to identical means), use the mean rbtree for our search.
    this.centroids._comparator = compare_centroid_mean_cumns;
    var iter = this.centroids.upperBound({
        mean_cumn: cumn
    }); // cumn < iter
    this.centroids._comparator = compare_centroid_means;
    var lower = iter.prev(); // lower <= cumn
    var upper = lower && lower.mean_cumn === cumn ? lower : iter.next();
    return [
        lower,
        upper
    ];
};
TDigest.prototype.percentile = function(p_or_plist) {
    // for percentage p (0..1), or for each p in a list of ps, return
    // the smallest data value q at which at least p percent of the
    // observations <= q.
    //
    // for discrete distributions, this selects q using the Nearest
    // Rank Method
    // (https://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method)
    // (in scipy, same as percentile(...., interpolation='higher')
    //
    // for continuous distributions, interpolates data values between
    // count-weighted bracketing means.
    //
    // this triggers cumulate() if cumn's are out of date.
    //
    var ps = Array.isArray(p_or_plist) ? p_or_plist : [
        p_or_plist
    ];
    var qs = ps.map(this._percentile, this);
    return Array.isArray(p_or_plist) ? qs : qs[0];
};
TDigest.prototype._percentile = function(p) {
    if (this.size() === 0) {
        return undefined;
    }
    this._cumulate(true); // be sure cumns are exact
    var h = this.n * p;
    var bound = this.bound_mean_cumn(h);
    var lower = bound[0], upper = bound[1];
    if (upper === lower || lower === null || upper === null) {
        return (lower || upper).mean;
    } else if (!this.discrete) {
        return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);
    } else if (h <= lower.cumn) {
        return lower.mean;
    } else {
        return upper.mean;
    }
};
function pop_random(choices) {
    // remove and return an item randomly chosen from the array of choices
    // (mutates choices)
    //
    var idx = Math.floor(Math.random() * choices.length);
    return choices.splice(idx, 1)[0];
}
TDigest.prototype.compress = function() {
    // TDigests experience worst case compression (none) when input
    // increases monotonically.  Improve on any bad luck by
    // reconsuming digest centroids as if they were weighted points
    // while shuffling their order (and hope for the best).
    //
    if (this.compressing) {
        return;
    }
    var points = this.toArray();
    this.reset();
    this.compressing = true;
    while(points.length > 0){
        this.push_centroid(pop_random(points));
    }
    this._cumulate(true);
    this.compressing = false;
};
function Digest(config) {
    // allocate a distribution digest structure. This is an extension
    // of a TDigest structure that starts in exact histogram (discrete)
    // mode, and automatically switches to TDigest mode for large
    // samples that appear to be from a continuous distribution.
    //
    this.config = config || {};
    this.mode = this.config.mode || 'auto'; // disc, cont, auto
    TDigest.call(this, this.mode === 'cont' ? config.delta : false);
    this.digest_ratio = this.config.ratio || 0.9;
    this.digest_thresh = this.config.thresh || 1000;
    this.n_unique = 0;
}
Digest.prototype = Object.create(TDigest.prototype);
Digest.prototype.constructor = Digest;
Digest.prototype.push = function(x_or_xlist) {
    TDigest.prototype.push.call(this, x_or_xlist);
    this.check_continuous();
};
Digest.prototype._new_centroid = function(x, n, cumn) {
    this.n_unique += 1;
    TDigest.prototype._new_centroid.call(this, x, n, cumn);
};
Digest.prototype._addweight = function(nearest, x, n) {
    if (nearest.n === 1) {
        this.n_unique -= 1;
    }
    TDigest.prototype._addweight.call(this, nearest, x, n);
};
Digest.prototype.check_continuous = function() {
    // while in 'auto' mode, if there are many unique elements, assume
    // they are from a continuous distribution and switch to 'cont'
    // mode (tdigest behavior). Return true on transition from
    // disctete to continuous.
    if (this.mode !== 'auto' || this.size() < this.digest_thresh) {
        return false;
    }
    if (this.n_unique / this.size() > this.digest_ratio) {
        this.mode = 'cont';
        this.discrete = false;
        this.delta = this.config.delta || 0.01;
        this.compress();
        return true;
    }
    return false;
};
module.exports = {
    'TDigest': TDigest,
    'Digest': Digest
};
}),
];

//# sourceMappingURL=node_modules_d0cfaef7._.js.map